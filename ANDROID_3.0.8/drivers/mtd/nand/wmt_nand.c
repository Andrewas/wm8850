/*++
linux/drivers/mtd/nand/wmt_nand.c

Copyright (c) 2008  WonderMedia Technologies, Inc.

This program is free software: you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software Foundation,
either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>.

WonderMedia Technologies, Inc.
10F, 529, Chung-Cheng Road, Hsin-Tien, Taipei 231, R.O.C.
--*/

//#include <linux/config.h>
#include <linux/module.h>
/*#include <linux/types.h>*/
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/platform_device.h>
#include <linux/string.h>
#include <linux/ioport.h>
/*#include <linux/platform_device.h>*/
#include <linux/delay.h>
#include <linux/err.h>
#include <linux/slab.h>
#include <linux/dma-mapping.h>
/*#include <linux/clk.h>*/

#include <linux/mtd/mtd.h>
#include <linux/mtd/nand.h>
#include <linux/mtd/nand_ecc.h>
/*#include <linux/mtd/partitions.h>*/
#include <linux/interrupt.h>
#include <linux/completion.h>
#include <linux/reboot.h> //Lch
#include <asm/irq.h>
#include <asm/io.h>
#include <asm/dma.h>
#include <asm/sizes.h>
#include <mach/irqs.h>
#include <mach/hardware.h>
#include "wmt_nand.h"

//#define ELSC_DEBUG
//Support Toshiba randomizer operations
#ifdef CONFIG_MTD_NAND_RANDOMIZER
#define CARE_MEMORY_ALIGNMENT
#define BYTE_SEED 2112
//support wmt randomizer
unsigned int rdmz[BYTE_SEED]= {
 0xC5F7B49E, 0x85AD42B6, 0x1888A48B, 0xFBA90A42, 0xE20E7129, 0x37E8086E, 0x6F1C1918, 0x31510E20,
 0x382771CB, 0x6107F49D, 0x901B6D0B, 0x3CD489E1, 0xA9B9CE07, 0x6B41AC61, 0x749F181D, 0xA7DDA658,
 0x405276C0, 0xB67EFB43, 0xC5EE35A6, 0xF8406534, 0x73D8093A, 0xD98028A3, 0x084CE1AF, 0xB4744210,
 0x951E02A0, 0xF657482D, 0x6C64F9D0, 0x68DB8651, 0xD1E64A45, 0x3A0FCB39, 0x9C9BB663, 0x05322DAE,
 0xA4F40077, 0x801BA102, 0xB73BE0DD, 0xA2E34B6A, 0x5A50E576, 0x83CD0C99, 0x63C1440B, 0x2F82661D,
 0x6846C973, 0xA74C29E6, 0x880E86A2, 0xB1D7E000, 0xF9B6F2B5, 0x71E5F26C, 0xE707DE1E, 0x439D5A63,
 0x1F697817, 0x23DFB560, 0xE87F6BD0, 0xBD1BBCC3, 0xB1D3A074, 0x6C1B7C0A, 0xE2823FDB, 0x17F45131,
 0x9082625D, 0xDFD364FD, 0x88DF4E2B, 0xB6FE752D, 0x5B04FF38, 0xB27648A9, 0x8C4EF297, 0x1C595F00,
 0x9E7B4520, 0x826ADDFF, 0xF83FE0EE, 0xF981B0B0, 0x1F9233D7, 0xA2C148CB, 0xF73C908E, 0x18F36125,
 0xE45D3D77, 0xB77BA7EA, 0x6D962E25, 0xFF4BF3B8, 0x7C06714F, 0x812DFFDA, 0xE499B45A, 0x73498684,
 0x11DCD8C1, 0x0FE5FAEC, 0x882C8503, 0x1CBB95F8, 0x62889F09, 0xF6798B10, 0x7FFE1FE9, 0x464DBD35,
 0x476EA249, 0xD7D7428D, 0xD885740A, 0xA034FA2C, 0xB37FD49C, 0x9AC07AD5, 0xAEFA9F54, 0x80B1AC25,
 0xAFE642C5, 0x55249024, 0xC3BD79F8, 0x78D3CAB0, 0x71523E07, 0x179AD53B, 0x4C6DE12B, 0x545E4957,
 0xE19CDBF1, 0xB9CA4748, 0xD401EF16, 0x0C7FD0DC, 0x2D55D75B, 0x8169F899, 0xBE415FAA, 0x45355DFD,
 0x1EE42A38, 0x3E167903, 0x838D4BAE, 0xACB42144, 0x8A9970D3, 0x978DB4A5, 0x45A09237, 0x431554E5,
 0xAAD8AFF7, 0x4F260392, 0xF60E8E22, 0xDEFCBB1D, 0xA6903D2E, 0x0C041572, 0x32A1E06E, 0xD41C2E5A,
 0xE43F79E1, 0xD562B75D, 0x53B35557, 0x871CF712, 0x06130B69, 0x4FE6CACB, 0xA79121F3, 0x31D1804E,
 0xA6CDBB55, 0x2B31D900, 0x6F8D96A6, 0xF90DFE42, 0x3F8E6A88, 0x5D5F338E, 0x19BEFA53, 0xA80B5EC5,
 0x33A4BCC7, 0x7C6435D9, 0xE334EF6D, 0xDABCCF28, 0x0B1E822E, 0x6BC9A2E7, 0xC12ECFFD, 0xCB2410AA,
 0x5E239332, 0xD599FC9D, 0xD2ADA8FC, 0x985F0C4C, 0xA3FBD68F, 0x1A6857C8, 0x7CF1FA13, 0xBEC591B0,
 0x4E7219DC, 0xC7B5CA12, 0x31730D81, 0x954B0433, 0xFA399921, 0x17871477, 0xA42D4816, 0xAC692951,
 0x3346763F, 0x8097EFF0, 0x9727B982, 0x5D7D302F, 0xB4D28FAB, 0x33353379, 0xB438C5BB, 0xE49DF42E,
 0xE6E4083B, 0x82BB1576, 0xFF1675C3, 0x5B33BD3D, 0xDC018912, 0xC9886442, 0xA8F895ED, 0x99E15C12,
 0x45E855E8, 0xA73B2CD4, 0x290C2256, 0x510A601B, 0xB2DC458E, 0x9493508F, 0xEB9E844E, 0x0796D9AE,
 0x79741BD6, 0xEAAC9AE2, 0xC1990396, 0x3BB91B8F, 0x51D3287A, 0x9EAECDDD, 0x10EEC66D, 0xC9EA20D4,
 0xCAE1855A, 0xA7C42760, 0x3DBF5142, 0xDD2E56F2, 0xE7C71747, 0x1202F5B2, 0xF0444344, 0x2382331B,
 0xCF4AA7A2, 0xE037CA0B, 0x9CC2706C, 0xB7AA6F63, 0x6ABFBB08, 0x5DF9FE35, 0xBF95CB8A, 0xEA64D353,
 0xBB5DB139, 0xF25BBBB3, 0xB069B05E, 0x1FA571D2, 0xCCB68970, 0xB2FA065B, 0xAC52ABC8, 0xE3C72445,
 0x70F92FFD, 0x3292E21F, 0x2FC6615E, 0x329E2283, 0x9130F29F, 0x8736745B, 0x802463EF, 0xF2173C18,
 0xC1EA46D0, 0x0F1631C4, 0x226965D6, 0x2537F5C9, 0x26875CB0, 0x05C9666E, 0x25EAFDDC, 0x9F585A5C,
 0x12D33D3B, 0xF76DD669, 0x81303E96, 0x0CD91D67, 0x8B7EE682, 0xC306750F, 0x36B85254, 0xCB0AD397,
 0x4DB9750B, 0xFB0FC7F9, 0x442540F0, 0x758785F8, 0xE7E514E6, 0xBF6E804A, 0x6B7A2EF8, 0xA41E4A67,
 0x57B36655, 0xE5E72D5D, 0xC4C5AA32, 0x43A2988E, 0x5A45A4D2, 0x40D6B8DA, 0xBD39BF62, 0x1CBFD58C,
 0xF72511B6, 0x651E46A7, 0x8F0D90C6, 0x9552850B, 0x87D4BEA3, 0x7CD7B9C6, 0x86046AF7, 0x462BB9D7,
 0xB0DA3C41, 0x7A95F448, 0x5021FF8F, 0x093EB834, 0xBD0EFD67, 0x72C81437, 0xB2E38763, 0xD1BF8C4A,
 0x889789F4, 0x52D00D1C, 0xD8D07299, 0xAC5A2B20, 0xC89C393B, 0x5636B492, 0xD375FC40, 0x89F81123,
 0xB3EA1B56, 0xC7310408, 0x3A3449A0, 0x4C1AE419, 0xF55CEDA3, 0x01415BEA, 0xF2A0F073, 0x31774DF5,
 0x00E68A8C, 0x695E5496, 0xE7749B58, 0x77327028, 0x6CD335BB, 0x98468D74, 0xDE16F10D, 0x7138FA79,
 0x5ED8D8F2, 0x54870136, 0xCDEE53A2, 0x3DB7D1AA, 0xF6754B8C, 0xC1088C28, 0xF3E5EBED, 0x567A3339,
 0xA2F60ACE, 0x994B5135, 0x5D35F7F0, 0x50FCF79A, 0xB0E1BED8, 0xAA14A632, 0xA04F3F82, 0xAC8BE3A9,
 0xCFB5AC16, 0xF484B91F, 0x10E64685, 0xE2B13DAA, 0xEC2E1E35, 0x4623393F, 0x9B81213F, 0x5C5A6F27,
 0xB1C6E1D0, 0xAF00C849, 0x3C7AC4B2, 0x24C9E2A0, 0x0FE1BA98, 0x1D810BBC, 0x8FDC584F, 0x927B1026,
 0x2566B32E, 0xBF440303, 0xED4D467E, 0x19EFBCB4, 0x31C80176, 0xDB209CD7, 0x406174B1, 0x4DA4B447,
 0x134F6EC4, 0xBC1220F6, 0xA75D2836, 0xDEB8BC5E, 0xFC48D6DE, 0x3A78CE0B, 0x3D991297, 0xE5EFADB5,
 0xEF9EB74C, 0x656D03E1, 0xBBA2BA8D, 0xE6E8C8A7, 0x3C4D86B7, 0x4ABE231B, 0x4A272C4D, 0xA920C151,
 0x8846417D, 0x55F99831, 0x7A627F14, 0x6FC991E5, 0xA3D515B2, 0x09F2B1F1, 0x5267C177, 0x284D79BC,
 0xA3AA9068, 0x83AB087B, 0x9475DA03, 0x82C0D0D8, 0xE0E242F6, 0x0E466BFE, 0x867FAF59, 0x59DF8EE2,
 0xE5AFEA82, 0x20EBD203, 0xC076152F, 0x4469C75B, 0x04047376, 0xF75654F0, 0x51B16CEC, 0xFCB7DD6A,
 0x2ECBBD1F, 0xB1BD247E, 0xB0F4FF7C, 0x690F1271, 0x7EB7C4EB, 0x9FB65038, 0x50D674D3, 0x36D6D65E,
 0x17E550E1, 0xC63458A1, 0x924C5223, 0x4B117295, 0xFA8295D6, 0x59EC8C93, 0x1E75A586, 0xF64A8961,
 0x842450ED, 0x90ECE657, 0x033CE78B, 0x03526381, 0xDFBDE0F7, 0x5430CD5D, 0x3D735887, 0x32476AE2,
 0xBD427ACC, 0x034BE2B9, 0xA250C775, 0x3F6060EC, 0x1F5A7A66, 0xD805FA64, 0x3EDE30B2, 0xF949F901,
 0x65568178, 0x6B23E8F7, 0x168608AA, 0x99F8DD2A, 0x3805726A, 0xCC6B8165, 0x0B2500B7, 0xBB48F09D,
 0x31400FF0, 0x6E914B37, 0x2C98C243, 0x53D551B5, 0x70A8691A, 0xAB51BDAC, 0xC742414E, 0x0E9B63EB,
 0x3FA0A9B5, 0x4EC5D5B7, 0x3728C137, 0x3E83B6C9, 0xDE7C3573, 0x387AF7B0, 0x463238EF, 0xCD371BC3,
 0x11C559F9, 0x7208DD6E, 0xE37C28B2, 0x3E92B719, 0x88CA0F8F, 0x75E5C16E, 0x85FC0451, 0x814BFB38,
 0x132D2A52, 0xDE0B3041, 0x99785344, 0xA6EFB8F4, 0x865DACF8, 0xF4B3FB1A, 0x7E91873E, 0xA777AB7F,
 0x588FD4D8, 0x41B9200D, 0x5C03A928, 0x035EA31D, 0x614B7336, 0xE1989B85, 0x2C67C9F7, 0x476622A1,
 0xFC8C5FF3, 0xFE4AEF65, 0x41D3E473, 0x1541A4E1, 0x1BB44300, 0xF8FB69C3, 0x3DB391DE, 0x63D8C533,
 0x526F419F, 0x031664C2, 0x85650B07, 0x624C1624, 0x324BAA7E, 0x03B4E90D, 0xB6E3B461, 0xB3445605,
 0x4A4128AF, 0x5E945F59, 0x2504F7B8, 0xDD5D13B4, 0xD3683D0C, 0x61B8B81E, 0x4BDD7B50, 0x15EBA9C6,
 0x0369E118, 0x0F3CB28D, 0xA45E0D50, 0x98C6031A, 0x40FC3B93, 0x3B0ED7E4, 0xA14E235F, 0x915E7695,
 0x5BD9F72D, 0x0BA94E45, 0x9B54A9C2, 0xCEDE74B5, 0x801321EA, 0x9C60FDA3, 0x842CD005, 0xBBB7FB29,
 0x25F37CE4, 0xE2B57DDE, 0x7983908A, 0xD544F488, 0x6B72AE10, 0x8F455719, 0x717CFD3A, 0x04003302,
 0x62FBDA4F, 0xC2D6A15B, 0x0C445245, 0xFDD48521, 0x71073894, 0x1BF40437, 0x378E0C8C, 0x98A88710,
 0x9C13B8E5, 0xB083FA4E, 0xC80DB685, 0x9E6A44F0, 0xD4DCE703, 0xB5A0D630, 0x3A4F8C0E, 0x53EED32C,
 0xA0293B60, 0x5B3F7DA1, 0x62F71AD3, 0x7C20329A, 0xB9EC049D, 0xECC01451, 0x042670D7, 0x5A3A2108,
 0xCA8F0150, 0x7B2BA416, 0xB6327CE8, 0xB46DC328, 0xE8F32522, 0x9D07E59C, 0x4E4DDB31, 0x829916D7,
 0x527A003B, 0xC00DD081, 0x5B9DF06E, 0x5171A5B5, 0xAD2872BB, 0xC1E6864C, 0xB1E0A205, 0x97C1330E,
 0x342364B9, 0x53A614F3, 0x44074351, 0xD8EBF000, 0x7CDB795A, 0x38F2F936, 0xF383EF0F, 0xA1CEAD31,
 0x0FB4BC0B, 0x11EFDAB0, 0xF43FB5E8, 0x5E8DDE61, 0x58E9D03A, 0xB60DBE05, 0xF1411FED, 0x8BFA2898,
 0xC841312E, 0xEFE9B27E, 0xC46FA715, 0x5B7F3A96, 0xAD827F9C, 0xD93B2454, 0x4627794B, 0x0E2CAF80,
 0xCF3DA290, 0x41356EFF, 0x7C1FF077, 0xFCC0D858, 0x8FC919EB, 0x5160A465, 0xFB9E4847, 0x8C79B092,
 0x722E9EBB, 0xDBBDD3F5, 0x36CB1712, 0xFFA5F9DC, 0x3E0338A7, 0x4096FFED, 0x724CDA2D, 0xB9A4C342,
 0x08EE6C60, 0x87F2FD76, 0x44164281, 0x8E5DCAFC, 0x31444F84, 0xFB3CC588, 0xBFFF0FF4, 0xA326DE9A,
 0xA3B75124, 0x6BEBA146, 0x6C42BA05, 0x501A7D16, 0xD9BFEA4E, 0x4D603D6A, 0xD77D4FAA, 0xC058D612,
 0x57F32162, 0x2A924812, 0x61DEBCFC, 0xBC69E558, 0xB8A91F03, 0x8BCD6A9D, 0xA636F095, 0xAA2F24AB,
 0x70CE6DF8, 0x5CE523A4, 0x6A00F78B, 0x863FE86E, 0x96AAEBAD, 0x40B4FC4C, 0xDF20AFD5, 0x229AAEFE,
 0x8F72151C, 0x1F0B3C81, 0x41C6A5D7, 0xD65A10A2, 0xC54CB869, 0xCBC6DA52, 0xA2D0491B, 0xA18AAA72,
 0x556C57FB, 0x279301C9, 0xFB074711, 0x6F7E5D8E, 0x53481E97, 0x06020AB9, 0x1950F037, 0xEA0E172D,
 0xF21FBCF0, 0xEAB15BAE, 0x29D9AAAB, 0xC38E7B89, 0x830985B4, 0xA7F36565, 0x53C890F9, 0x98E8C027,
 0x5366DDAA, 0x1598EC80, 0x37C6CB53, 0x7C86FF21, 0x1FC73544, 0xAEAF99C7, 0x8CDF7D29, 0xD405AF62,
 0x99D25E63, 0xBE321AEC, 0x719A77B6, 0x6D5E6794, 0x858F4117, 0xB5E4D173, 0x609767FE, 0x65920855,
 0xAF11C999, 0x6ACCFE4E, 0x6956D47E, 0xCC2F8626, 0x51FDEB47, 0x8D342BE4, 0x3E78FD09, 0x5F62C8D8,
 0x27390CEE, 0xE3DAE509, 0x98B986C0, 0xCAA58219, 0xFD1CCC90, 0x0BC38A3B, 0xD216A40B, 0xD63494A8,
 0x19A33B1F, 0x404BF7F8, 0xCB93DCC1, 0xAEBE9817, 0xDA6947D5, 0x999A99BC, 0x5A1C62DD, 0xF24EFA17,
 0x7372041D, 0xC15D8ABB, 0xFF8B3AE1, 0x2D99DE9E, 0x6E00C489, 0xE4C43221, 0x547C4AF6, 0x4CF0AE09,
 0x22F42AF4, 0x539D966A, 0x9486112B, 0x2885300D, 0xD96E22C7, 0x4A49A847, 0x75CF4227, 0x03CB6CD7,
 0x3CBA0DEB, 0x75564D71, 0xE0CC81CB, 0x1DDC8DC7, 0xA8E9943D, 0xCF5766EE, 0x08776336, 0x64F5106A,
 0x6570C2AD, 0x53E213B0, 0x1EDFA8A1, 0xEE972B79, 0x73E38BA3, 0x09017AD9, 0xF82221A2, 0x11C1198D,
 0xE7A553D1, 0x701BE505, 0xCE613836, 0x5BD537B1, 0xB55FDD84, 0x2EFCFF1A, 0xDFCAE5C5, 0xF53269A9,
 0xDDAED89C, 0x792DDDD9, 0x5834D82F, 0x0FD2B8E9, 0xE65B44B8, 0x597D032D, 0xD62955E4, 0xF1E39222,
 0xB87C97FE, 0x1949710F, 0x97E330AF, 0x994F1141, 0xC898794F, 0xC39B3A2D, 0x401231F7, 0x790B9E0C,
 0x60F52368, 0x078B18E2, 0x9134B2EB, 0x129BFAE4, 0x1343AE58, 0x02E4B337, 0x12F57EEE, 0xCFAC2D2E,
 0x89699E9D, 0x7BB6EB34, 0xC0981F4B, 0x066C8EB3, 0xC5BF7341, 0x61833A87, 0x9B5C292A, 0xE58569CB,
 0xA6DCBA85, 0x7D87E3FC, 0x2212A078, 0x3AC3C2FC, 0x73F28A73, 0x5FB74025, 0xB5BD177C, 0xD20F2533,
 0xABD9B32A, 0x72F396AE, 0x6262D519, 0x21D14C47, 0x2D22D269, 0x206B5C6D, 0x5E9CDFB1, 0x0E5FEAC6,
 0xFB9288DB, 0x328F2353, 0xC786C863, 0xCAA94285, 0x43EA5F51, 0xBE6BDCE3, 0xC302357B, 0xA315DCEB,
 0x586D1E20, 0xBD4AFA24, 0x2810FFC7, 0x849F5C1A, 0xDE877EB3, 0xB9640A1B, 0x5971C3B1, 0x68DFC625,
 0x444BC4FA, 0xA968068E, 0x6C68394C, 0xD62D1590, 0x644E1C9D, 0x2B1B5A49, 0xE9BAFE20, 0x44FC0891,
 0x59F50DAB, 0x63988204, 0x9D1A24D0, 0xA60D720C, 0x7AAE76D1, 0x80A0ADF5, 0xF9507839, 0x18BBA6FA,
 0x00734546, 0x34AF2A4B, 0x73BA4DAC, 0xBB993814, 0x36699ADD, 0xCC2346BA, 0xEF0B7886, 0x389C7D3C,
 0x2F6C6C79, 0x2A43809B, 0x66F729D1, 0x1EDBE8D5, 0x7B3AA5C6, 0xE0844614, 0xF9F2F5F6, 0x2B3D199C,
 0xD17B0567, 0x4CA5A89A, 0x2E9AFBF8, 0x287E7BCD, 0x5870DF6C, 0x550A5319, 0xD0279FC1, 0x5645F1D4,
 0xE7DAD60B, 0xFA425C8F, 0x08732342, 0xF1589ED5, 0xF6170F1A, 0xA3119C9F, 0xCDC0909F, 0x2E2D3793,
 0xD8E370E8, 0x57806424, 0x1E3D6259, 0x1264F150, 0x07F0DD4C, 0x8EC085DE, 0x47EE2C27, 0x493D8813,
 0x92B35997, 0x5FA20181, 0x76A6A33F, 0x0CF7DE5A, 0x98E400BB, 0xED904E6B, 0xA030BA58, 0x26D25A23,
 0x09A7B762, 0x5E09107B, 0x53AE941B, 0x6F5C5E2F, 0xFE246B6F, 0x9D3C6705, 0x9ECC894B, 0x72F7D6DA,
 0xF7CF5BA6, 0xB2B681F0, 0xDDD15D46, 0xF3746453, 0x9E26C35B, 0xA55F118D, 0xA5139626, 0xD49060A8,
 0xC42320BE, 0x2AFCCC18, 0xBD313F8A, 0x37E4C8F2, 0xD1EA8AD9, 0x84F958F8, 0x2933E0BB, 0x1426BCDE,
 0xD1D54834, 0xC1D5843D, 0x4A3AED01, 0x4160686C, 0x7071217B, 0x872335FF, 0x433FD7AC, 0x2CEFC771,
 0xF2D7F541, 0x9075E901, 0xE03B0A97, 0x2234E3AD, 0x020239BB, 0x7BAB2A78, 0x28D8B676, 0xFE5BEEB5,
 0x1765DE8F, 0x58DE923F, 0xD87A7FBE, 0xB4878938, 0x3F5BE275, 0xCFDB281C, 0x286B3A69, 0x9B6B6B2F,
 0x8BF2A870, 0xE31A2C50, 0xC9262911, 0x2588B94A, 0xFD414AEB, 0x2CF64649, 0x8F3AD2C3, 0xFB2544B0,
 0xC2122876, 0xC876732B, 0x819E73C5, 0x81A931C0, 0xEFDEF07B, 0xAA1866AE, 0x1EB9AC43, 0x1923B571,
 0xDEA13D66, 0x81A5F15C, 0x512863BA, 0x1FB03076, 0x0FAD3D33, 0x6C02FD32, 0x9F6F1859, 0x7CA4FC80,
 0xB2AB40BC, 0x3591F47B, 0x0B430455, 0x4CFC6E95, 0x9C02B935, 0xE635C0B2, 0x8592805B, 0x5DA4784E,
 0x98A007F8, 0xB748A59B, 0x964C6121, 0x29EAA8DA, 0x3854348D, 0x55A8DED6, 0xE3A120A7, 0x874DB1F5,
 0x9FD054DA, 0xA762EADB, 0x9B94609B, 0x9F41DB64, 0x6F3E1AB9, 0x9C3D7BD8, 0xA3191C77, 0xE69B8DE1,
 0x08E2ACFC, 0x39046EB7, 0xF1BE1459, 0x9F495B8C, 0x446507C7, 0xBAF2E0B7, 0x42FE0228, 0x40A5FD9C,
 0x89969529, 0x6F059820, 0x4CBC29A2, 0x5377DC7A, 0x432ED67C, 0x7A59FD8D, 0xBF48C39F, 0x53BBD5BF,
 0xAC47EA6C, 0x20DC9006, 0xAE01D494, 0x01AF518E, 0xB0A5B99B, 0xF0CC4DC2, 0x9633E4FB, 0xA3B31150,
 0xFE462FF9, 0xFF2577B2, 0xA0E9F239, 0x0AA0D270, 0x8DDA2180, 0x7C7DB4E1, 0x9ED9C8EF, 0xB1EC6299,
 0x2937A0CF, 0x818B3261, 0x42B28583, 0x31260B12, 0x9925D53F, 0x81DA7486, 0xDB71DA30, 0xD9A22B02,
 0xA5209457, 0x2F4A2FAC, 0x12827BDC, 0x6EAE89DA, 0x69B41E86, 0x30DC5C0F, 0x25EEBDA8, 0x0AF5D4E3,
 0x81B4F08C, 0x079E5946, 0x522F06A8, 0xCC63018D, 0x207E1DC9, 0x9D876BF2, 0xD0A711AF, 0xC8AF3B4A,
 0xADECFB96, 0x05D4A722, 0xCDAA54E1, 0x676F3A5A, 0xC00990F5, 0xCE307ED1, 0xC2166802, 0x5DDBFD94,
 0x12F9BE72, 0x715ABEEF, 0x3CC1C845, 0x6AA27A44, 0xB5B95708, 0x47A2AB8C, 0x38BE7E9D, 0x82001981,
 0xB17DED27, 0xE16B50AD, 0x86222922, 0x7EEA4290, 0xB8839C4A, 0x0DFA021B, 0x1BC70646, 0xCC544388,
 0x4E09DC72, 0xD841FD27, 0x6406DB42, 0xCF352278, 0x6A6E7381, 0x5AD06B18, 0x1D27C607, 0x29F76996,
 0xD0149DB0, 0xAD9FBED0, 0x317B8D69, 0xBE10194D, 0xDCF6024E, 0xF6600A28, 0x0213386B, 0x2D1D1084,
 0x654780A8, 0x3D95D20B, 0x5B193E74, 0x5A36E194, 0x74799291, 0xCE83F2CE, 0xA726ED98, 0xC14C8B6B,
 0xA93D001D, 0x6006E840, 0xADCEF837, 0xA8B8D2DA, 0x5694395D, 0xE0F34326, 0x58F05102, 0xCBE09987,
 0x9A11B25C, 0xA9D30A79, 0x2203A1A8, 0x6C75F800, 0x3E6DBCAD, 0x9C797C9B, 0xF9C1F787, 0xD0E75698,
 0x07DA5E05, 0x08F7ED58, 0xFA1FDAF4, 0x2F46EF30, 0xAC74E81D, 0xDB06DF02, 0x78A08FF6, 0x45FD144C,
 0x64209897, 0xF7F4D93F, 0x6237D38A, 0x2DBF9D4B, 0x56C13FCE, 0xEC9D922A, 0x2313BCA5, 0x071657C0,
 0xE79ED148, 0xA09AB77F, 0x3E0FF83B, 0xFE606C2C, 0xC7E48CF5, 0xA8B05232, 0x7DCF2423, 0xC63CD849,
 0xB9174F5D, 0x6DDEE9FA, 0x1B658B89, 0xFFD2FCEE, 0x9F019C53, 0xA04B7FF6, 0x39266D16, 0x5CD261A1,
 0x04773630, 0xC3F97EBB, 0x220B2140, 0x472EE57E, 0x18A227C2, 0x7D9E62C4, 0x5FFF87FA, 0x51936F4D,
 0x51DBA892, 0xB5F5D0A3, 0x36215D02, 0x280D3E8B, 0x6CDFF527, 0x26B01EB5, 0x6BBEA7D5, 0x602C6B09,
 0x2BF990B1, 0x15492409, 0x30EF5E7E, 0xDE34F2AC, 0xDC548F81, 0xC5E6B54E, 0xD31B784A, 0x55179255,
 0x386736FC, 0xAE7291D2, 0x35007BC5, 0xC31FF437, 0x4B5575D6, 0xA05A7E26, 0x6F9057EA, 0x114D577F,
 0xC7B90A8E, 0x8F859E40, 0x20E352EB, 0xEB2D0851, 0x62A65C34, 0xE5E36D29, 0x5168248D, 0xD0C55539,
 0xAAB62BFD, 0x93C980E4, 0x7D83A388, 0xB7BF2EC7, 0xA9A40F4B, 0x8301055C, 0x8CA8781B, 0x75070B96,
 0x790FDE78, 0xF558ADD7, 0x94ECD555, 0x61C73DC4, 0xC184C2DA, 0xD3F9B2B2, 0xA9E4487C, 0x4C746013,
 0x29B36ED5, 0x8ACC7640, 0x9BE365A9, 0x3E437F90, 0x8FE39AA2, 0xD757CCE3, 0x466FBE94, 0xEA02D7B1,
 0x4CE92F31, 0x5F190D76, 0x38CD3BDB, 0xB6AF33CA, 0xC2C7A08B, 0x5AF268B9, 0xB04BB3FF, 0xB2C9042A,
 0x5788E4CC, 0x35667F27, 0x34AB6A3F, 0xE617C313, 0x28FEF5A3, 0xC69A15F2, 0x1F3C7E84, 0x2FB1646C,
 0x939C8677, 0x71ED7284, 0xCC5CC360, 0x6552C10C, 0xFE8E6648, 0x85E1C51D, 0x690B5205, 0xEB1A4A54,
 0x0CD19D8F, 0xA025FBFC, 0xE5C9EE60, 0xD75F4C0B, 0x6D34A3EA, 0xCCCD4CDE, 0xAD0E316E, 0xF9277D0B,
 0xB9B9020E, 0xE0AEC55D, 0x7FC59D70, 0x96CCEF4F, 0xB7006244, 0x72621910, 0xAA3E257B, 0x26785704,
 0x117A157A, 0xA9CECB35, 0xCA430895, 0x94429806, 0xECB71163, 0xA524D423, 0xBAE7A113, 0x81E5B66B,
 0x9E5D06F5, 0xBAAB26B8, 0xF06640E5, 0x8EEE46E3, 0x5474CA1E, 0x67ABB377, 0x043BB19B, 0xB27A8835,
 0x32B86156, 0xA9F109D8, 0x8F6FD450, 0xF74B95BC, 0xB9F1C5D1, 0x0480BD6C, 0xFC1110D1, 0x88E08CC6,
 0xF3D2A9E8, 0x380DF282, 0xE7309C1B, 0x2DEA9BD8, 0x5AAFEEC2, 0x977E7F8D, 0xEFE572E2, 0x7A9934D4,
 0xEED76C4E, 0xBC96EEEC, 0xAC1A6C17, 0x07E95C74, 0xF32DA25C, 0x2CBE8196, 0x6B14AAF2, 0x78F1C911,
 0xDC3E4BFF, 0x8CA4B887, 0xCBF19857, 0xCCA788A0, 0xE44C3CA7, 0xE1CD9D16, 0x200918FB, 0x3C85CF06,
 0x307A91B4, 0x83C58C71, 0x489A5975, 0x094DFD72, 0x89A1D72C, 0x0172599B, 0x097ABF77, 0xE7D61697,
 0x44B4CF4E, 0xBDDB759A, 0xE04C0FA5, 0x83364759, 0xE2DFB9A0, 0x30C19D43, 0xCDAE1495, 0xF2C2B4E5,
 0x536E5D42, 0x3EC3F1FE, 0x1109503C, 0x9D61E17E, 0xB9F94539, 0x2FDBA012, 0xDADE8BBE, 0x69079299,
 0x55ECD995, 0xB979CB57, 0xB1316A8C, 0x90E8A623, 0x96916934, 0x9035AE36, 0x2F4E6FD8, 0x872FF563,
 0xFDC9446D, 0x994791A9, 0xE3C36431, 0xE554A142, 0xA1F52FA8, 0xDF35EE71, 0xE1811ABD, 0x518AEE75,
 0x2C368F10, 0xDEA57D12, 0x14087FE3, 0xC24FAE0D, 0xEF43BF59, 0xDCB2050D, 0xACB8E1D8, 0x346FE312,
 0x2225E27D, 0x54B40347, 0x36341CA6, 0xEB168AC8, 0xB2270E4E, 0x158DAD24, 0xF4DD7F10, 0xA27E0448,
 0x2CFA86D5, 0x31CC4102, 0x4E8D1268, 0xD306B906, 0xBD573B68, 0xC05056FA, 0x7CA83C1C, 0x0C5DD37D,
 0x8039A2A3, 0x1A579525, 0x39DD26D6, 0xDDCC9C0A, 0x1B34CD6E, 0x6611A35D, 0x7785BC43, 0x9C4E3E9E,
 0x97B6363C, 0x9521C04D, 0xB37B94E8, 0x0F6DF46A, 0x3D9D52E3, 0x7042230A, 0x7CF97AFB, 0x959E8CCE,
 0x68BD82B3, 0x2652D44D, 0x974D7DFC, 0x143F3DE6, 0xAC386FB6, 0xAA85298C, 0x6813CFE0, 0xAB22F8EA,
 0xF3ED6B05, 0x7D212E47, 0x843991A1, 0x78AC4F6A, 0xFB0B878D, 0xD188CE4F, 0xE6E0484F, 0x17169BC9,
 0x6C71B874, 0xABC03212, 0x0F1EB12C, 0x093278A8, 0x03F86EA6, 0xC76042EF, 0xA3F71613, 0xA49EC409,
 0xC959ACCB, 0xAFD100C0, 0x3B53519F, 0x867BEF2D, 0xCC72005D, 0x76C82735, 0xD0185D2C, 0x13692D11,
 0x84D3DBB1, 0xAF04883D, 0xA9D74A0D, 0xB7AE2F17, 0xFF1235B7, 0xCE9E3382, 0x4F6644A5, 0x397BEB6D,
 0x7BE7ADD3, 0x595B40F8, 0xEEE8AEA3, 0xF9BA3229, 0xCF1361AD, 0x52AF88C6, 0x5289CB13, 0x6A483054,
 0x6211905F, 0x157E660C, 0x5E989FC5, 0x9BF26479, 0x68F5456C, 0xC27CAC7C, 0x1499F05D, 0x0A135E6F,
 0xE8EAA41A, 0xE0EAC21E, 0x251D7680, 0xA0B03436, 0xB83890BD, 0x43919AFF, 0xA19FEBD6, 0x9677E3B8,
 0xF96BFAA0, 0xC83AF480, 0xF01D854B, 0x911A71D6, 0x01011CDD, 0x3DD5953C, 0x946C5B3B, 0xFF2DF75A,
 0x8BB2EF47, 0x2C6F491F, 0x6C3D3FDF, 0xDA43C49C, 0x1FADF13A, 0xE7ED940E, 0x94359D34, 0x4DB5B597,
 0x45F95438, 0xF18D1628, 0x64931488, 0x92C45CA5, 0xFEA0A575, 0x967B2324, 0x479D6961, 0x7D92A258,
 0xE109143B, 0xE43B3995, 0x40CF39E2, 0xC0D498E0, 0x77EF783D, 0xD50C3357, 0x8F5CD621, 0x0C91DAB8,
 0x6F509EB3, 0x40D2F8AE, 0x289431DD, 0x8FD8183B, 0x07D69E99, 0xB6017E99, 0x4FB78C2C, 0x3E527E40,
 0xD955A05E, 0x9AC8FA3D, 0x85A1822A, 0xA67E374A, 0x4E015C9A, 0xF31AE059, 0x42C9402D, 0x2ED23C27,
 0xCC5003FC, 0xDBA452CD, 0x4B263090, 0x94F5546D, 0x1C2A1A46, 0xAAD46F6B, 0xF1D09053, 0x43A6D8FA,
 0xCFE82A6D, 0xD3B1756D, 0x4DCA304D, 0xCFA0EDB2, 0x379F0D5C, 0xCE1EBDEC, 0xD18C8E3B, 0x734DC6F0,
 0x8471567E, 0x9C82375B, 0x78DF0A2C, 0xCFA4ADC6, 0xA23283E3, 0x5D79705B, 0x217F0114, 0xA052FECE,
 0x44CB4A94, 0x3782CC10, 0x265E14D1, 0x29BBEE3D, 0xA1976B3E, 0xBD2CFEC6, 0xDFA461CF, 0x29DDEADF,
 0x5623F536, 0x106E4803, 0x5700EA4A, 0x80D7A8C7, 0x5852DCCD, 0xF86626E1, 0x4B19F27D, 0xD1D988A8,
 0x7F2317FC, 0xFF92BBD9, 0x5074F91C, 0x05506938, 0xC6ED10C0, 0xBE3EDA70, 0xCF6CE477, 0xD8F6314C,
 0x949BD067, 0xC0C59930, 0x215942C1, 0x98930589, 0x4C92EA9F, 0x40ED3A43, 0x6DB8ED18, 0xECD11581,
 0x52904A2B, 0x17A517D6, 0x09413DEE, 0x375744ED, 0xB4DA0F43, 0x186E2E07, 0x92F75ED4, 0x057AEA71,
 0x40DA7846, 0x03CF2CA3, 0xA9178354, 0xE63180C6, 0x103F0EE4, 0xCEC3B5F9, 0x685388D7, 0x64579DA5,
 0x56F67DCB, 0x82EA5391, 0x66D52A70, 0xB3B79D2D, 0xE004C87A, 0x67183F68, 0x610B3401, 0x2EEDFECA,
 0x897CDF39, 0xB8AD5F77, 0x1E60E422, 0x35513D22, 0x5ADCAB84, 0xA3D155C6, 0x9C5F3F4E, 0xC1000CC0,
 0xD8BEF693, 0x70B5A856, 0x43111491, 0x3F752148, 0xDC41CE25, 0x06FD010D, 0x0DE38323, 0x662A21C4,
 0xA704EE39, 0x6C20FE93, 0x32036DA1, 0xE79A913C, 0x353739C0, 0xAD68358C, 0x0E93E303, 0x14FBB4CB,
 0x680A4ED8, 0xD6CFDF68, 0x98BDC6B4, 0x5F080CA6, 0x6E7B0127, 0xFB300514, 0x01099C35, 0x168E8842,
 0xB2A3C054, 0x1ECAE905, 0x2D8C9F3A, 0xAD1B70CA, 0x3A3CC948, 0x6741F967, 0xD39376CC, 0xE0A645B5,
 0x549E800E, 0xB0037420, 0x56E77C1B, 0xD45C696D, 0x2B4A1CAE, 0x7079A193, 0xAC782881, 0x65F04CC3,
 0xCD08D92E, 0x54E9853C, 0x1101D0D4, 0xB63AFC00, 0x9F36DE56, 0xCE3CBE4D, 0x7CE0FBC3, 0xE873AB4C,
 0x03ED2F02, 0x047BF6AC, 0x7D0FED7A, 0x97A37798, 0x563A740E, 0x6D836F81, 0x3C5047FB, 0xA2FE8A26,
 0xB2104C4B, 0x7BFA6C9F, 0xB11BE9C5, 0x16DFCEA5, 0x2B609FE7, 0xF64EC915, 0x1189DE52, 0x038B2BE0,
 0xF3CF68A4, 0xD04D5BBF, 0x1F07FC1D, 0xFF303616, 0x63F2467A, 0xD4582919, 0xBEE79211, 0xE31E6C24,
 0x5C8BA7AE, 0xB6EF74FD, 0x0DB2C5C4, 0xFFE97E77, 0x4F80CE29, 0x5025BFFB, 0x9C93368B, 0x2E6930D0,
 0x823B9B18, 0x61FCBF5D, 0x110590A0, 0x239772BF, 0x0C5113E1, 0x3ECF3162, 0xAFFFC3FD, 0x28C9B7A6,
 0xA8EDD449, 0x5AFAE851, 0x9B10AE81, 0x94069F45, 0xB66FFA93, 0x93580F5A, 0xB5DF53EA, 0xB0163584,
 0x95FCC858, 0x0AA49204, 0x1877AF3F, 0xEF1A7956, 0x6E2A47C0, 0x62F35AA7, 0xE98DBC25, 0x2A8BC92A,
 0x1C339B7E, 0xD73948E9, 0x9A803DE2, 0x618FFA1B, 0x25AABAEB, 0x502D3F13, 0xB7C82BF5, 0x08A6ABBF,
 0x63DC8547, 0xC7C2CF20, 0x9071A975, 0x75968428, 0xB1532E1A, 0xF2F1B694, 0xA8B41246, 0xE862AA9C,
 0x555B15FE, 0x49E4C072, 0xBEC1D1C4, 0xDBDF9763, 0x54D207A5, 0xC18082AE, 0x46543C0D, 0x3A8385CB,
 0xBC87EF3C, 0xFAAC56EB, 0x4A766AAA, 0x30E39EE2, 0x60C2616D, 0x69FCD959, 0xD4F2243E, 0xA63A3009,
 0x14D9B76A, 0xC5663B20, 0x4DF1B2D4, 0x1F21BFC8, 0xC7F1CD51, 0x6BABE671, 0xA337DF4A, 0xF5016BD8,
 0x26749798, 0xAF8C86BB, 0x1C669DED, 0xDB5799E5, 0xE163D045, 0xAD79345C, 0x5825D9FF, 0x59648215,
 0xABC47266, 0x9AB33F93, 0x9A55B51F, 0xF30BE189, 0x147F7AD1, 0x634D0AF9, 0x0F9E3F42, 0x97D8B236,
 0x49CE433B, 0x38F6B942, 0x662E61B0, 0x32A96086, 0xFF473324, 0xC2F0E28E, 0x3485A902, 0xF58D252A,
 0x0668CEC7, 0x5012FDFE, 0xF2E4F730, 0x6BAFA605, 0x369A51F5, 0x6666A66F, 0xD68718B7, 0x7C93BE85,
 0xDCDC8107, 0x705762AE, 0xBFE2CEB8, 0x4B6677A7, 0x5B803122, 0xB9310C88, 0x551F12BD, 0x133C2B82,
 0x88BD0ABD, 0xD4E7659A, 0x6521844A, 0xCA214C03, 0xF65B88B1, 0xD2926A11, 0xDD73D089, 0xC0F2DB35,
 0x4F2E837A, 0xDD55935C, 0xF8332072, 0x47772371, 0xAA3A650F, 0xB3D5D9BB, 0x821DD8CD, 0x593D441A,
 0x195C30AB, 0x54F884EC, 0x47B7EA28, 0xFBA5CADE, 0x5CF8E2E8, 0x82405EB6, 0x7E088868, 0x44704663,
 0x79E954F4, 0x9C06F941, 0x73984E0D, 0x16F54DEC, 0xAD57F761, 0x4BBF3FC6, 0x77F2B971, 0x3D4C9A6A,
 0x776BB627, 0xDE4B7776, 0x560D360B, 0x03F4AE3A, 0x7996D12E, 0x165F40CB, 0xB58A5579, 0xBC78E488,
 0xEE1F25FF, 0xC6525C43, 0x65F8CC2B, 0xE653C450, 0x72261E53, 0xF0E6CE8B, 0x10048C7D, 0x1E42E783,
 0x983D48DA, 0xC1E2C638, 0x244D2CBA, 0x04A6FEB9, 0xC4D0EB96, 0x80B92CCD, 0x84BD5FBB, 0x73EB0B4B,
 0x225A67A7, 0xDEEDBACD, 0xF02607D2, 0x419B23AC, 0xF16FDCD0, 0x9860CEA1, 0xE6D70A4A, 0x79615A72,
 0x29B72EA1, 0x1F61F8FF, 0x0884A81E, 0xCEB0F0BF, 0x5CFCA29C, 0x17EDD009, 0xED6F45DF, 0xB483C94C,
 0xAAF66CCA, 0x5CBCE5AB, 0xD898B546, 0x48745311, 0x4B48B49A, 0x481AD71B, 0x97A737EC, 0xC397FAB1,
 0xFEE4A236, 0xCCA3C8D4, 0x71E1B218, 0x72AA50A1, 0xD0FA97D4, 0xEF9AF738, 0xF0C08D5E, 0x28C5773A,
 0x161B4788, 0xEF52BE89, 0x8A043FF1, 0xE127D706, 0xF7A1DFAC, 0x6E590286, 0x565C70EC, 0x9A37F189,
 0x9112F13E, 0x2A5A01A3, 0x1B1A0E53, 0x758B4564, 0x59138727, 0x0AC6D692, 0x7A6EBF88, 0xD13F0224,
 0x167D436A, 0x18E62081, 0x27468934, 0x69835C83, 0x5EAB9DB4, 0x60282B7D, 0xBE541E0E, 0x862EE9BE,
 0xC01CD151, 0x0D2BCA92, 0x1CEE936B, 0x6EE64E05, 0x8D9A66B7, 0xB308D1AE, 0x3BC2DE21, 0x4E271F4F,
 0xCBDB1B1E, 0x4A90E026, 0x59BDCA74, 0x87B6FA35, 0x1ECEA971, 0xB8211185, 0x3E7CBD7D, 0xCACF4667,
 0xB45EC159, 0x13296A26, 0x4BA6BEFE, 0x0A1F9EF3, 0x561C37DB, 0x554294C6, 0x3409E7F0, 0xD5917C75,
 0xF9F6B582, 0xBE909723, 0x421CC8D0, 0xBC5627B5, 0xFD85C3C6, 0xE8C46727, 0xF3702427, 0x0B8B4DE4,
 0x3638DC3A, 0x55E01909, 0x078F5896, 0x04993C54, 0x81FC3753, 0xE3B02177, 0xD1FB8B09, 0xD24F6204,
 0x64ACD665, 0xD7E88060, 0x9DA9A8CF, 0xC33DF796, 0xE639002E, 0x3B64139A, 0xE80C2E96, 0x89B49688,
 0xC269EDD8, 0xD782441E, 0xD4EBA506, 0xDBD7178B, 0x7F891ADB, 0xE74F19C1, 0xA7B32252, 0x9CBDF5B6,
 0x3DF3D6E9, 0xACADA07C, 0xF7745751, 0xFCDD1914, 0x6789B0D6, 0xA957C463, 0x2944E589, 0xB524182A,
 0x3108C82F, 0x8ABF3306, 0xAF4C4FE2, 0x4DF9323C, 0x347AA2B6, 0xE13E563E, 0x8A4CF82E, 0x0509AF37,
 0x7475520D, 0x7075610F, 0x128EBB40, 0xD0581A1B, 0xDC1C485E, 0x21C8CD7F, 0x50CFF5EB, 0x4B3BF1DC,
 0x7CB5FD50, 0xE41D7A40, 0x780EC2A5, 0xC88D38EB, 0x00808E6E, 0x9EEACA9E, 0x4A362D9D, 0xFF96FBAD,
 0xC5D977A3, 0x9637A48F, 0x361E9FEF, 0x6D21E24E, 0x0FD6F89D, 0x73F6CA07, 0xCA1ACE9A, 0x26DADACB,
 0x22FCAA1C, 0x78C68B14, 0xB2498A44, 0xC9622E52, 0x7F5052BA, 0xCB3D9192, 0x23CEB4B0, 0xBEC9512C,
 0xF0848A1D, 0x721D9CCA, 0x20679CF1, 0xE06A4C70, 0xBBF7BC1E, 0xEA8619AB, 0x47AE6B10, 0x8648ED5C,
 0x37A84F59, 0xA0697C57, 0x944A18EE, 0xC7EC0C1D, 0x83EB4F4C, 0x5B00BF4C, 0x27DBC616, 0x1F293F20,
 0xECAAD02F, 0x4D647D1E, 0x42D0C115, 0x533F1BA5, 0xA700AE4D, 0xF98D702C, 0xA164A016, 0x17691E13,
 0xE62801FE, 0x6DD22966, 0xA5931848, 0x4A7AAA36, 0x8E150D23, 0xD56A37B5, 0x78E84829, 0xA1D36C7D,
 0xE7F41536, 0xE9D8BAB6, 0x26E51826, 0x67D076D9, 0x1BCF86AE, 0xE70F5EF6, 0x68C6471D, 0x39A6E378,
 0xC238AB3F, 0x4E411BAD, 0x3C6F8516, 0xE7D256E3, 0xD11941F1, 0x2EBCB82D, 0x10BF808A, 0x50297F67,
 0x2265A54A, 0x9BC16608, 0x932F0A68, 0x14DDF71E, 0x50CBB59F, 0xDE967F63, 0xEFD230E7, 0x14EEF56F,
 0xAB11FA9B, 0x08372401, 0xAB807525, 0xC06BD463, 0xAC296E66, 0xFC331370, 0x258CF93E, 0x68ECC454,
 0xBF918BFE, 0x7FC95DEC, 0x283A7C8E, 0x02A8349C, 0x63768860, 0xDF1F6D38, 0x67B6723B, 0xEC7B18A6,
 0x4A4DE833, 0xE062CC98, 0x90ACA160, 0xCC4982C4, 0xA649754F, 0x20769D21, 0xB6DC768C, 0xF6688AC0,
 0x29482515, 0x0BD28BEB, 0x84A09EF7, 0x9BABA276, 0xDA6D07A1, 0x0C371703, 0xC97BAF6A, 0x02BD7538,
 0xA06D3C23, 0x01E79651, 0x548BC1AA, 0x7318C063, 0x881F8772, 0xE761DAFC, 0xB429C46B, 0xB22BCED2,
 0xAB7B3EE5, 0x417529C8, 0xB36A9538, 0x59DBCE96, 0x7002643D, 0xB38C1FB4, 0x30859A00, 0x9776FF65,
 0xC4BE6F9C, 0x5C56AFBB, 0x0F307211, 0x1AA89E91, 0x2D6E55C2, 0x51E8AAE3, 0x4E2F9FA7, 0xE0800660,
 0x6C5F7B49, 0xB85AD42B, 0x21888A48, 0x9FBA90A4, 0xEE20E712, 0x837E8086, 0x06F1C191, 0xB31510E2,
 0xD382771C, 0xB6107F49, 0x1901B6D0, 0x73CD489E, 0x1A9B9CE0, 0xD6B41AC6, 0x8749F181, 0x0A7DDA65,
 0x3405276C, 0x6B67EFB4, 0x4C5EE35A, 0xAF840653, 0x373D8093, 0xFD98028A, 0x0084CE1A, 0x0B474421,
 0xD951E02A, 0x0F657482, 0x16C64F9D, 0x568DB865, 0x9D1E64A4, 0x33A0FCB3, 0xE9C9BB66, 0x705322DA,
 0x2A4F4007, 0xD801BA10, 0xAB73BE0D, 0x6A2E34B6, 0x95A50E57, 0xB83CD0C9, 0xD63C1440, 0x32F82661,
 0x66846C97, 0x2A74C29E, 0x0880E86A, 0x5B1D7E00, 0xCF9B6F2B, 0xE71E5F26, 0x3E707DE1, 0x7439D5A6,
 0x01F69781, 0x023DFB56, 0x3E87F6BD, 0x4BD1BBCC, 0xAB1D3A07, 0xB6C1B7C0, 0x1E2823FD, 0xD17F4513,
 0xD9082625, 0xBDFD364F, 0xD88DF4E2, 0x8B6FE752, 0x95B04FF3, 0x7B27648A, 0x08C4EF29, 0x01C595F0,
};


//support Toshiba randomizer
//#include "randomizer.h"
//#ifdef CARE_MEMORY_ALIGNMENT
//#include <string.h>
//#endif
/* Default values                                   */
/* User can modify these value in init_randomizer() */
//#define DEFAULT_PAGE_MAIN_SIZE      8192
#define DEFAULT_PAGE_MAIN_SIZE      16384
#define DEFAULT_PAGE_SPARE_SIZE     640
#define DEFAULT_PAGES_PER_BLOCK     256

#if(DEFAULT_PAGE_MAIN_SIZE <= 8192)
#define MAX_PAGE_MAIN_SIZE		8192
#define MAX_PAGE_SPARE_SIZE		640
#elif(DEFAULT_PAGE_MAIN_SIZE == 16384)
#define MAX_PAGE_MAIN_SIZE		16384
#define MAX_PAGE_SPARE_SIZE		1280
#else /* not supported */
#define MAX_PAGE_MAIN_SIZE		0
#define MAX_PAGE_SPARE_SIZE		0
#endif

#define MAX_PAGES_PER_BLOCK		256
#define MAX_FRAME_MAIN_BYTES	1024
#define MAX_FRAME_SPARE_BYTES	80
#define ECC_FRAMES				8

struct randomizer {
	unsigned int pgsize;
	unsigned int spsize;
	unsigned int pg_per_bk;
	unsigned int fr_size;
};

static struct randomizer rndmz = {
	DEFAULT_PAGE_MAIN_SIZE,
	DEFAULT_PAGE_SPARE_SIZE,
	DEFAULT_PAGES_PER_BLOCK,
	(DEFAULT_PAGE_MAIN_SIZE + DEFAULT_PAGE_SPARE_SIZE) / ECC_FRAMES,
};
static unsigned int init_done = 0;

/* Macros */
#define RANDOMIZE_LOOP1(a,b,c) {					\
		int jj;										\
		for (jj=0; jj<c; jj++) {					\
			*a++ = b; *a++ = b; *a++ = b; *a++ = b;	\
			*a++ = b; *a++ = b; *a++ = b; *a++ = b;	\
			*a++ = b; *a++ = b; *a++ = b; *a++ = b; \
			*a++ = b; *a++ = b; *a++ = b; *a++ = b; \
		}}

#define RANDOMIZE_LOOP2(a,b,c) {						\
		int jj;											\
		for (jj=0; jj<c; jj++) {						\
			*a++ ^= b; *a++ ^= b; *a++ ^= b; *a++ ^= b;	\
			*a++ ^= b; *a++ ^= b; *a++ ^= b; *a++ ^= b;	\
			*a++ ^= b; *a++ ^= b; *a++ ^= b; *a++ ^= b;	\
			*a++ ^= b; *a++ ^= b; *a++ ^= b; *a++ ^= b;	\
		}}

/* Random data table */
#if(DEFAULT_PAGE_MAIN_SIZE <= 8192)
static const unsigned int rand_table[ECC_FRAMES][340] =
#elif(DEFAULT_PAGE_MAIN_SIZE == 16384)
static const unsigned int rand_table[ECC_FRAMES][616] =
#endif
{
	{	0x3C9C9E80, 0x513D8625, 0xE022A2BF, 0x35E579D9,
		0x3ED49BCE, 0x53A44915, 0x75697D77, 0x15FFEC2E,
		0x855CAC7C, 0x8F24CC31, 0x63625C67, 0x04F741E4,
		0x126E61A7, 0x03C0BFA1, 0x71A08588, 0x75425365,
		0x49628766, 0x0FF7B4AE, 0xD1799A2B, 0x190CBA56,
		0x9C191683, 0x136EE354, 0x82A5C4CA, 0xC251D790,
		0x474EB0C1, 0x5F1E1FC4, 0x6C7FFE6E, 0x7B1CB8B2,
		0x2098666F, 0xDEF35CB3, 0x2DD29DA5, 0x1AE885A3,
		0x6D900FF8, 0x1F780DCD, 0xE9C6EAF3, 0x861EE045,
		0x9BFF22B8, 0xE7721783, 0x41766231, 0x6101773B,
		0x5AF3E59C, 0x0D8EA6BD, 0x7D877C4C, 0xB046540B,
		0x312C8126, 0x5E692485, 0x9F9A620F, 0xF5BA05E8,
		0xA7E42A62, 0x98A757CE, 0x0153BB15, 0x73CC0092,
		0xF7F200A6, 0xA57DE552, 0x0DEC8806, 0x21492EE2,
		0xC8443720, 0x2B728582, 0xB376C442, 0x1CE425CC,
		0xB67BE339, 0x44A044B0, 0x39B05C6D, 0xC2C3D6C3,
		0x47E8C30D, 0xBA4CE836, 0xE4795B13, 0x55FEB55E,
		0x17B84726, 0x5B7194F7, 0xE990B6D7, 0x3F2436D5,
		0x8EA9131C, 0x5BC8BBB6, 0xB5ABAE53, 0x50DDD9F5,
		0x58F2E07B, 0x0F44506B, 0x1A65D87D, 0xD45F9342,
		0x1DD5B062, 0x9979B105, 0xCB50273D, 0x8693BD9B,
		0x2230BE02, 0xE5DFAA2C, 0x31C939C7, 0x2C4FB043,
		0x479F7ABF, 0xC8CC0F3C, 0xD92EB451, 0xE08E1AF7,
		0x4790D4F9, 0x1478F887, 0x2AD1117F, 0x9CD2E5B2,
		0x7646B1B3, 0x815EA7B2, 0x8AB1219D, 0xACA71405,
		0xCCC4CF76, 0x4B9C032F, 0x8DE194A1, 0xD8340FED,
		0x93112383, 0x42CBAFA6, 0xF5064F6B, 0xB04C9F8F,
		0xA60BDBF4, 0xFCC3E2B1, 0xC80D3789, 0x2B21BC64,
		0x41DFBFBB, 0x58E77772, 0x210AE5CF, 0x5F305414,
		0x7B71384F, 0xA0E2C37A, 0x550E9AB6, 0x4BD06644,
		0xC621002E, 0x7BC8170E, 0xFCD9DBFE, 0x3AF77596,
		0x9D8B9523, 0x92ADEBF3, 0xD4066120, 0x785B9149,
		0x7FD0258F, 0x0BB6744D, 0x439814B3, 0x86CA4FF9,
		0x47BE9F29, 0x03763EA6, 0xF12F6AB7, 0xE944196B,
		0xE3658B44, 0x6AAD3A39, 0xEB91B330, 0x3DEEC003,
		0xE94BB72D, 0x3FD17CFF, 0x99529F17, 0x97CD4C75,
		0x0C38A549, 0x7C6DE818, 0x9FB14C1D, 0xA9276EA0,
		0x2D4F32B0, 0xC6FA01D4, 0x7B3D5D24, 0xEB2257F5,
		0xF6F28255, 0x24189E39, 0xBE1DDA1E, 0x1345CD46,
		0xDE38AF82, 0x48FACF42, 0x1913E6DB, 0x2570F9F5,
		0xF491A909, 0x7A1C3A41, 0xA1FD1D04, 0x6D020EAB,
		0x1FDE7E01, 0x0C941D01, 0x0E184538, 0xB51D2F54,
		0xD05236CA, 0xC4F4AA75, 0xA5435C49, 0x7F3F56EA,
		0xEEB7BA59, 0x3937CA37, 0xEC2B10AB, 0xE7EFB896,
		0x9D64E646, 0x77AC25E7, 0xAEA9BFA4, 0x12BACE1B,
		0xDF810230, 0x95A4ACAD, 0xC51B5BE3, 0xC127E936,
		0xB661DA76, 0xB65A06AF, 0x8F1A752A, 0x11B1828B,
		0xCB09D55F, 0xE31D9CB0, 0xC4992A88, 0x2539F95C,
		0xF4C290EF, 0x88B541B8, 0xE5FE4FBA, 0xFA73085D,
		0x044E6EA5, 0x4E557923, 0x6C395081, 0xA7FB76EF,
		0x21CEB8B8, 0xE6ACF148, 0x8B75FE19, 0x945ECA32,
		0x8F315B38, 0x4D2CE9C3, 0x41A2CD8D, 0xBD40CAAA,
		0xBEF7CCB9, 0xBDD7AE3B, 0xF5C2121C, 0x09D03AD3,
		0x560F1DA2, 0xC87FEBF9, 0x1232F607, 0x2DDD33E3,
		0xC65C7218, 0x9E6FAAD6, 0x6324F288, 0xD8108FB9,
		0x1338BF70, 0x3B9F125A, 0xD707E634, 0xFBF41CF4,
		0xABC3D3A6, 0x5DA350A0, 0x791DBD55, 0x225290B9,
		0xB911F882, 0x49CB5AEC, 0x3611B4E7, 0xAA809A78,
		0x4BB248FF, 0x9AEF5280, 0x03CA7425, 0xE687DF5A,
		0xD7E89551, 0x1EF5D2E0, 0xD16C0D22, 0x37420FF2,
		0xD94C9AEA, 0xBC404859, 0x3F92B7D2, 0x0E26FC23,
		0xC7CEF1B8, 0x1FACA271, 0x35875762, 0x621AC960,
		0x2BA62A3E, 0x6F3779D3, 0xF8E00CE9, 0x0622EBBF,
		0xCCE52AE0, 0x802632B5, 0xA5E04A47, 0xD1FE0C71,
		0x37E47C3E, 0x3C1E6D18, 0x3446ED24, 0x1170BA3E,
		0x3906DD6A, 0x424C39FC, 0xDBEE8903, 0x104BE414,
		0x8123D584, 0x6F169C45, 0x335A3D73, 0x2E233559,
		0xC52F297C, 0x24D36D08, 0xDB3588F9, 0x10BEAE3E,
		0x96D8598F, 0xA3136B86, 0x8AC93669, 0x029304B4,
		0x026C851A, 0x82B053C3, 0xEC1F6234, 0x021B3CA8,
		0xF030B4C9, 0xD1488D76, 0xB76B9301, 0xA0182716,
		0x9E41E106, 0x742A34A9, 0x03EEF471, 0x66AE43A9,
		0xAEBC28AD, 0x3CF47BBF, 0x9AD48E59, 0x3A8A07A0,
		0x782C28FB, 0x0D50C285, 0x36E19B0F, 0xF6E8BB1A,
		0xD6E2DC26, 0x08B7F359, 0xC037990E, 0x52D9B9D0,
		0x11ABBBC4, 0x39F39740, 0x55B7B5F7, 0x17EB7EC0,
		0xA9D8EF0E, 0xAD93E469, 0xA8553023, 0x953903B8,
		0x1909DF94, 0xD78ABBEA, 0x423B804E, 0xA96E6E09,
		0x2D1C0B56, 0x34537A2D, 0x3F3E0F9A, 0x7C535103,
		0xED6292F1, 0x66D9FA1B, 0xDC3CCFA7, 0x01A394FD,
		0x2FA421F0, 0x6AA2947F, 0x3725448B, 0xCE11652D,
		0x95174868, 0x0E0719B5, 0x0C74C022, 0x37AD7C97,
		0x3C4D54FE, 0xC6EF96DD, 0x5573E880, 0xAE77DB9C,
		0x59DC2958, 0x992FED21, 0x726AF1AD, 0x93C58C3F,
		0x9E8A1237, 0x1102664E, 0x00159709, 0x2E4EB5A4
#if(DEFAULT_PAGE_MAIN_SIZE == 16384)
	,	0x45558C69, 0xAF2EAB0D, 0xBD377318, 0xCC772BB3,
		0x80804179, 0x40B2BDB5, 0x59F8A90C, 0x190671D2,
		0x0B3E4C51, 0xB1C42560, 0xD532914C, 0x1CCA6E1C,
		0xA1752518, 0x9F5E3F78, 0x4C26A0B4, 0x57E0EC34,
		0xAC1B5E86, 0xDB6C7A9B, 0x75308F15, 0x7071CD05,
		0x63F538F6, 0x4FC29F41, 0xA669F54F, 0xA00DB01F,
		0xB00F54A2, 0x317FB8C0, 0xACC05F7C, 0xDB9930B1,
		0x62CB031E, 0xBC743AC6, 0xDA6633EC, 0x6372AEAC,
		0x612A5929, 0x066E8ED4, 0x8725BE6F, 0x23DA2A56,
		0xCA28B23A, 0xA9C2D641, 0x5F69A676, 0x1EFF1964,
		0x464B57F0, 0x95E8C9C6, 0x8EDBCF6C, 0x62DBF1D5,
		0xD9A9220B, 0xCE66DC9F, 0xE797AF62, 0x3350F6F7,
		0xB9046F8B, 0x6785EF48, 0x7344388E, 0x05AE3175,
		0xF6853BE7, 0x56987933, 0x834A355C, 0xA63562EF,
		0x8E103C5D, 0x07F3A332, 0xDA524173, 0x86862A92,
		0x0C7E0BA6, 0xA08A2645, 0x9EE792CA, 0x9178C35B,
		0x8BE8510C, 0x484C4E45, 0x999C09E4, 0xB976B3FB,
		0x5E96A52B, 0x1F46B4D6, 0x9B15341F, 0x49E074FE,
		0x6A8CDFAF, 0x202B82AA, 0x15EF1EE5, 0xE081B4B1,
		0x9B242342, 0xE7875DA9, 0x568DEE3A, 0xAD0480F8,
		0xE360EE86, 0x213E9750, 0xBAC4D02A, 0x16256AC0,
		0x06066BEB, 0x4CCCB613, 0xF9728F49, 0x87E1E318,
		0x9A468F0A, 0x3A2C746C, 0x9D7EDF09, 0x855667F8,
		0x180396E3, 0xC1C89A53, 0x53601462, 0xCCF5D82B,
		0xE5FB2A78, 0xB1E0A534, 0x551B0DBF, 0x659ED3E0,
		0x83748C47, 0xD4E6BC03, 0x41EEA8E6, 0xF6805E25,
		0x1D0BD45A, 0xD21F5646, 0x8DFEC82C, 0x615DE09B,
		0x74EE69DE, 0xBA72512D, 0x96AA85FF, 0x9A0021E5,
		0xE6CBBA31, 0x9C2801DE, 0xBD09CA03, 0xBEA4F55F,
		0x4F7ED5C2, 0xB1C140A2, 0x9EA13C25, 0x4D9F0D06,
		0x8ABE8FDB, 0x7013E3BE, 0x3F3B6A58, 0x37C0FC6A,
		0xBC37F1EB, 0x4D1250D8, 0x33711361, 0x72BE5E11,
		0x4F8431AE, 0x7A8E3B12, 0xA15B6EC8, 0x8850F959,
		0x97D8DB7C, 0x227610ED, 0x39386471, 0x309FE710,
		0x14101DB8, 0xE1381903, 0x467A40AD, 0x3B8FE091,
		0xB2DAFEF9, 0xEFF4F387, 0x2F26D268, 0x0FD9FF7E,
		0xC6775C0A, 0xC2F2C19E, 0xE98FEA5A, 0x864DD9A3,
		0x69565941, 0xA371453D, 0xD60764C7, 0x7A91679F,
		0x183281BE, 0x6FAFB304, 0x6F6125F7, 0x41DADA79,
		0x1374DA1B, 0x705F86D5, 0x74FBFED7, 0x943CE489,
		0xD3FF0996, 0x352E8AE8, 0x5BFCC929, 0x505F2A6D,
		0x3D898B7A, 0xFE1648EA, 0x16867CCE, 0xA8C73170,
		0x959F7074, 0xFC5B2866, 0x5F8C1E97, 0x6CD98DA2,
		0x9E4E4F40, 0xA89EC312, 0xF011515F, 0x1AF2BCEC,
		0x9F6A4DE7, 0xA9D2248A, 0x3AB4BEBB, 0x0AFFF617,
		0xC2AE563E, 0xC7926618, 0x31B12E33, 0x827BA0F2,
		0x893730D3, 0x01E05FD0, 0xB8D042C4, 0x3AA129B2,
		0x24B143B3, 0x87FBDA57, 0x68BCCD15, 0x8C865D2B,
		0x4E0C8B41, 0x09B771AA, 0x4152E265, 0xE128EBC8,
		0x23A75860, 0x2F8F0FE2, 0x363FFF37, 0xBD8E5C59,
		0x904C3337, 0xEF79AE59, 0x96E94ED2, 0x0D7442D1,
		0xB6C807FC, 0x8FBC06E6, 0xF4E37579, 0x430F7022,
		0xCDFF915C, 0xF3B90BC1, 0xA0BB3118, 0x3080BB9D,
		0xAD79F2CE, 0x06C7535E, 0xBEC3BE26, 0x58232A05,
		0x98964093, 0xAF349242, 0x4FCD3107, 0x7ADD02F4,
		0x53F21531, 0xCC53ABE7, 0x00A9DD8A, 0x39E60049,
		0x7BF90053, 0x52BEF2A9, 0x06F64403, 0x10A49771,
		0x64221B90, 0x15B942C1, 0x59BB6221, 0x8E7212E6,
		0x5B3DF19C, 0xA2502258, 0x9CD82E36, 0xE161EB61,
		0x23F46186, 0xDD26741B, 0x723CAD89, 0x2AFF5AAF,
		0x8BDC2393, 0xADB8CA7B, 0xF4C85B6B, 0x1F921B6A,
		0x4754898E, 0xADE45DDB, 0xDAD5D729, 0xA86EECFA,
		0xAC79703D, 0x87A22835, 0x0D32EC3E, 0x6A2FC9A1,
		0x8EEAD831, 0xCCBCD882, 0xE5A8139E, 0x4349DECD,
		0x11185F01, 0xF2EFD516, 0x98E49CE3, 0x9627D821,
		0x23CFBD5F, 0xE466079E, 0xEC975A28, 0xF0470D7B,
		0xA3C86A7C, 0x8A3C7C43, 0x156888BF, 0xCE6972D9,
		0x3B2358D9, 0xC0AF53D9, 0xC55890CE, 0x56538A02,
		0xE66267BB, 0xA5CE0197, 0xC6F0CA50, 0xEC1A07F6
#endif
	},
	{	0x04D80B34, 0x0561A687, 0xD93EC468, 0x04367851,
		0xE1606993, 0xA3901BEC, 0x6FD62702, 0x41304E2C,
		0x3D82C30C, 0xE8546853, 0x06DDE9E2, 0xCC5D8653,
		0x5D79505B, 0x78E9F67F, 0x35A91DB2, 0x74150E41,
		0xF05850F7, 0x1AA0850B, 0x6CC3371E, 0xEDD17734,
		0xADC5B94C, 0x106FE7B2, 0x816E331C, 0xA4B373A1,
		0x22577789, 0x72E72F80, 0xAA6F6BEF, 0x2ED7FC81,
		0x53B1DF1C, 0x5B27C9D2, 0x51AA6046, 0x2B720671,
		0x3212BF29, 0xAF1577D5, 0x8476019C, 0x53DCDC12,
		0x5A3816AC, 0x68A6F45A, 0x7E7C1E35, 0xF8A6A206,
		0xDBC425E3, 0xCCB3F536, 0xB9789F4F, 0x024729FB,
		0x5E4942E1, 0xD44529FE, 0x6E4A8817, 0x9D22CA5A,
		0x2B2E90D0, 0x1C0E326B, 0x18E88144, 0x6E5BF82F,
		0x789AA8FD, 0x8DDF2DBB, 0xAAE6D101, 0x5DEEB739,
		0xB2B952B0, 0x335EDB42, 0xE4D4E35B, 0x278B197E,
		0x3D15246E, 0x2204CC9C, 0x002A2F12, 0x5C9C6B49,
		0x8AAA19D2, 0x5F5C571A, 0x7B6EE630, 0x99EE5667,
		0x010182F2, 0x80657B6B, 0xB2F15318, 0x320CE2A5,
		0x167C98A2, 0x63894AC0, 0xAB642398, 0x3895DC38,
		0x43EA4A30, 0x3FBC7EF0, 0x984C4169, 0xAEC1D968,
		0x5936BC0D, 0xB7D8F437, 0xEA601F2A, 0xE0E29B0A,
		0xC6EB70ED, 0x9E853F82, 0x4DD2EB9E, 0x411A613E,
		0x611EA845, 0x62FE7181, 0x5981BEF8, 0xB7336063,
		0xC497063C, 0x79E8748D, 0xB5CC66D9, 0xC6E45D59,
		0xC254B252, 0x0CDC1DA9, 0x0F4A7DDE, 0x46B554AC,
		0x95506574, 0x5385AD82, 0xBED24DEC, 0x3CFF32C8,
		0x8C96AEE1, 0x2BD1938D, 0x1DB79FD8, 0xC4B7E3AB,
		0xB3534416, 0x9DCCB93F, 0xCF2F5FC4, 0x66A0EDEF,
		0x7308DE17, 0xCE0BDF90, 0xE688701D, 0x0A5D62EA,
		0xED0B76CF, 0xAC31F266, 0x07946AB8, 0x4D6AC4DF,
		0x1D2078BA, 0x0EE74764, 0xB5A482E6, 0x0D0D5425,
		0x18FC164D, 0x41154C8A, 0x3DCF2595, 0x23F087B6,
		0x17D1A218, 0x90989C8A, 0x333912C9, 0x73EC67F7,
		0xBC2D4B56, 0x3E8C69AD, 0x372A683E, 0x92C1E8FD,
		0xD419BF5F, 0x40560555, 0x2ADF3CCB, 0xC1036963,
		0x37484684, 0xCF0FBA53, 0xAC1BDD74, 0x5B0801F1,
		0xC7C0DD0D, 0x427C2FA0, 0x7589A154, 0x2C4AD481,
		0x0C0CD6D7, 0x98996D26, 0xF3E41F92, 0x0FC3C730,
		0x358C1F14, 0x7458E8D8, 0x3BFCBF12, 0x0BACCEF1,
		0x30062DC7, 0x839135A6, 0xA6C028C4, 0x99EBB156,
		0xCBF754F0, 0x63C14B68, 0xAA361A7F, 0xCA3DA7C1,
		0x07E8198E, 0xA9CD7906, 0x82DD51CD, 0xED01BC4A,
		0x3A16A9B4, 0xA53EAC8C, 0x1BFD9158, 0xC2BAC137,
		0xE8DDD2BD, 0x75E4A25A, 0x2D550BFF, 0x350042CB,
		0xCD977562, 0x395002BD, 0x7B129506, 0x7D49EBBE,
		0x9EFCAB85, 0x63838045, 0x3D43784A, 0x9A3F1A0C,
		0x157D1FB7, 0xE026C77D, 0x7E76D4B0, 0x6E81F9D4,
		0x796EE3D7, 0x9A24A0B1, 0x66E226C2, 0xE47DBC22,
		0x9E09625D, 0xF41D7624, 0x43B6DC91, 0x11A0F3B2,
		0x2FB1B7F8, 0x44EC20DB, 0x7270C8E2, 0x603FCF20,
		0x28203A71, 0xC3703206, 0x8CF4805B, 0x761FC123,
		0x65B5FDF3, 0xDFE9E70F, 0x5E4CA5D0, 0x1EB3FFFC,
		0x8DEEB814, 0x85E5833D, 0xD31FD5B4, 0x0D9AB347,
		0xD2ACB282, 0x47E28A7A, 0xAD0EC88F, 0xF423CE3F,
		0x3064037D, 0xDE5F6708, 0xDEC24AEF, 0x82B5B5F2,
		0x26E8B536, 0xE0BE0DAB, 0xE8F7FDAF, 0x2978C913,
		0xA7FF122D, 0x6A5C15D1, 0xB6F99352, 0xA0BE54DA,
		0x7A1317F4, 0xFD2C90D5, 0x2C0DF89D, 0x518F62E0,
		0x2B3FE0E8, 0xF9B650CC, 0xBE193C2F, 0xD8B31B45,
		0x3D9C9E80, 0x513D8724, 0xE122A2BE, 0x34E579D9,
		0x3FD49ACF, 0x53A54815, 0x74697D77, 0x14FFED2E,
		0x855DAC7C, 0x8F25CC30, 0x62635C66, 0x05F641E5,
		0x136E60A7, 0x02C1BEA1, 0x71A18489, 0x74435265,
		0x48638667, 0x0FF7B5AE, 0xD0799B2A, 0x190DBA56,
		0x9C181782, 0x126FE255, 0x82A4C5CA, 0xC350D791,
		0x464FB0C0, 0x5E1F1EC5, 0x6C7EFF6E, 0x7B1DB8B2,
		0x2198666E, 0xDFF25DB2, 0x2DD39CA5, 0x1AE884A3,
		0x6D910EF9, 0x1F790CCD, 0xE9C7EAF2, 0x861EE044,
		0x9BFF23B8, 0xE7731683, 0x41776230, 0x6001773B,
		0x5BF2E59D, 0x0C8FA6BC, 0x7D877D4C, 0xB046540A,
		0x312D8027, 0x5F682584, 0x9E9B620E, 0xF4BB04E9,
		0xA6E52A62, 0x99A657CF, 0x0053BB15, 0x72CD0092,
		0xF6F300A6, 0xA47DE553, 0x0CED8806, 0x20492FE2,
		0xC8443621, 0x2A738483, 0xB277C442, 0x1DE424CD,
		0xB67AE339, 0x45A044B0, 0x39B15C6C, 0xC3C2D7C2,
		0x46E9C20D, 0xBB4CE836, 0xE4785B13, 0x54FFB45F,
		0x17B94627, 0x5B7195F6, 0xE991B6D6, 0x3E2536D4,
		0x8EA8131D, 0x5BC9BAB7, 0xB5ABAF52, 0x51DCD9F5,
		0x59F2E07A, 0x0F45506A, 0x1A64D97C, 0xD45E9343,
		0x1DD5B162, 0x9979B105, 0xCB51263D, 0x8692BD9B,
		0x2230BE02, 0xE5DFAB2C, 0x31C939C7, 0x2D4EB142,
		0x469F7BBE, 0xC9CC0E3D, 0xD92FB450, 0xE18E1AF6,
		0x4791D4F8, 0x1578F886, 0x2AD0117F, 0x9DD2E4B3,
		0x7646B0B3, 0x815FA6B3, 0x8BB0219D, 0xACA61504,
		0xCDC4CE77, 0x4B9D022F, 0x8DE195A0, 0xD9340EED
#if(DEFAULT_PAGE_MAIN_SIZE == 16384)
	,	0x92112383, 0x43CAAFA7, 0xF5074E6B, 0xB04C9E8F,
		0xA70ADBF5, 0xFDC2E3B0, 0xC80C3789, 0x2B21BD64,
		0x40DFBFBB, 0x59E67773, 0x200BE4CF, 0x5F315414,
		0x7A71394E, 0xA0E2C27B, 0x540F9AB6, 0x4AD16644,
		0xC620012E, 0x7AC9160F, 0xFCD8DBFF, 0x3BF67597,
		0x9D8B9523, 0x92ACEBF3, 0xD5066021, 0x795A9149,
		0x7FD1248F, 0x0BB7744C, 0x439914B2, 0x87CA4EF9,
		0x46BF9E29, 0x03773EA6, 0xF12F6BB6, 0xE845186B,
		0xE3658B45, 0x6AAC3B38, 0xEB91B331, 0x3DEFC002,
		0xE94BB72D, 0x3FD17DFE, 0x99539E17, 0x97CD4D74,
		0x0C38A449, 0x7D6CE918, 0x9EB14D1C, 0xA8276FA0,
		0x2C4F33B0, 0xC6FA00D5, 0x7B3D5D25, 0xEB2356F5,
		0xF7F28254, 0x24189E38, 0xBE1CDB1E, 0x1245CD47,
		0xDE38AE83, 0x49FACE43, 0x1913E7DA, 0x2571F8F5,
		0xF590A909, 0x7A1C3A40, 0xA1FD1D05, 0x6D030EAA,
		0x1FDF7E00, 0x0C941C01, 0x0E184439, 0xB41D2F55,
		0xD15236CA, 0xC5F4AA74, 0xA4435D48, 0x7F3F57EA,
		0xEFB6BB58, 0x3937CB36, 0xEC2A11AA, 0xE6EFB996,
		0x9D65E646, 0x76AD24E7, 0xAFA8BFA5, 0x12BACE1A,
		0xDF810330, 0x95A5ACAC, 0xC41B5BE3, 0xC027E937,
		0xB760DB76, 0xB65A06AE, 0x8F1B742B, 0x11B1838A,
		0xCA09D55F, 0xE21D9DB0, 0xC4982B88, 0x2539F95D,
		0xF4C290EE, 0x88B441B9, 0xE5FF4EBB, 0xFB72095C,
		0x054E6EA4, 0x4F547923, 0x6D385180, 0xA6FB77EE,
		0x20CFB8B8, 0xE7ACF049, 0x8A75FF18, 0x945ECA32,
		0x8F315B39, 0x4D2DE8C3, 0x40A3CC8D, 0xBD41CAAA,
		0xBFF6CDB8, 0xBCD7AF3A, 0xF5C3121C, 0x08D13AD2,
		0x570E1DA3, 0xC97EEBF9, 0x1332F606, 0x2CDD33E3,
		0xC65C7218, 0x9E6EABD6, 0x6325F288, 0xD8108EB9,
		0x1239BE71, 0x3A9F135A, 0xD607E734, 0xFAF51CF4,
		0xAAC3D3A7, 0x5DA351A0, 0x791DBD55, 0x225290B8,
		0xB811F982, 0x49CB5BEC, 0x3610B5E6, 0xAB809A78,
		0x4AB348FE, 0x9BEE5380, 0x02CB7424, 0xE786DF5B,
		0xD6E99451, 0x1EF4D3E0, 0xD06D0C23, 0x36430EF3,
		0xD94D9AEA, 0xBC404858, 0x3F93B6D3, 0x0E26FC22,
		0xC7CFF0B9, 0x1EADA270, 0x34875763, 0x621AC861,
		0x2BA72A3E, 0x6F3779D3, 0xF9E00CE8, 0x0622EABF,
		0xCDE42BE0, 0x812632B4, 0xA5E14A46, 0xD0FF0C70,
		0x36E57C3E, 0x3C1E6C19, 0x3446EC25, 0x1071BA3E,
		0x3807DC6B, 0x434C38FD, 0xDAEF8803, 0x104AE514,
		0x8123D585, 0x6F179C44, 0x335B3C73, 0x2E223559,
		0xC42F297D, 0x25D26D09, 0xDA3589F8, 0x11BEAE3E,
		0x96D8588F, 0xA3136B87, 0x8AC83768, 0x029205B4,
		0x036C841B, 0x82B052C3, 0xEC1E6334, 0x031A3DA8,
		0xF030B4C8, 0xD1498C77, 0xB66B9301, 0xA0182617,
		0x9F40E107, 0x752A34A8, 0x03EFF470, 0x67AE42A9,
		0xAFBC28AC, 0x3DF47ABF, 0x9AD48E58, 0x3B8A06A1,
		0x792C28FA, 0x0D51C284, 0x36E09B0F, 0xF6E8BA1B,
		0xD7E2DC26, 0x08B6F359, 0xC036990F, 0x52D8B9D1,
		0x10ABBBC5, 0x39F39741, 0x54B7B5F7, 0x16EB7FC0,
		0xA9D9EE0F, 0xAD93E568, 0xA8543122, 0x943903B9,
		0x1809DF95, 0xD68BBAEB, 0x433A814E, 0xA86F6E08,
		0x2D1D0A57, 0x34527B2C, 0x3F3F0E9B, 0x7D525103,
		0xED6392F0, 0x67D8FB1A, 0xDD3CCEA7, 0x00A395FC,
		0x2FA520F1, 0x6BA2947E, 0x3725458A, 0xCE10652D,
		0x95174968, 0x0E0619B5, 0x0D74C022, 0x36AD7D96,
		0x3D4C55FE, 0xC6EE97DC, 0x5473E980, 0xAE76DB9D,
		0x59DD2859, 0x992FED21, 0x736AF0AD, 0x93C58D3E,
		0x9E8A1236, 0x1103664E, 0x00149709, 0x2F4EB4A5,
		0x45558D68, 0xAE2FAA0D, 0xBD377319, 0xCD762BB3,
		0x81804079, 0x40B2BCB5, 0x58F9A80D, 0x190770D3,
		0x0A3F4C50, 0xB0C52461, 0xD433904D, 0x1CCA6E1C,
		0xA0752519, 0x9E5F3E79, 0x4C26A0B4, 0x56E1EC34,
		0xAD1A5F86, 0xDB6D7A9A, 0x75318E15, 0x7070CD05,
		0x63F539F6, 0x4FC39E41, 0xA768F54F, 0xA00CB11E,
		0xB00E55A2, 0x307FB9C0, 0xADC05E7D, 0xDA9931B0,
		0x62CA031F, 0xBC743AC6, 0xDA6632ED, 0x6373AEAC,
		0x602B5829, 0x076E8ED4, 0x8625BF6E, 0x22DB2A56,
		0xCB28B23A, 0xA8C3D640, 0x5E69A776, 0x1EFE1965
#endif
	},
	{	0xB6E5CB3B, 0x181F4D79, 0xFA0FFA98, 0x618CA814,
		0x625A014E, 0xBED04A09, 0x3D37C41C, 0xE97708D3,
		0x4DCB54C4, 0x334DAE9F, 0x00A6772A, 0xE49B0025,
		0xEDE7004D, 0x49FACBA6, 0x18DB110C, 0x40925EC5,
		0x91886C42, 0x54E60907, 0x65EE8984, 0x3AC9489B,
		0x6DF4C772, 0x8A418861, 0x7263B8D8, 0x8785AF85,
		0x8CD3851A, 0x7798D16C, 0xC9F0B626, 0xA8FF69BE,
		0x2E738C4E, 0xB6E22BED, 0xD3236DAD, 0x7C4A6CA9,
		0x1D51263A, 0xB693756F, 0x6B575FA4, 0xA2B9B3EB,
		0xB2E5C1F4, 0x1E8AA0D4, 0x34C8B3F8, 0xA9BC2786,
		0x3AAB63C4, 0x33F2630A, 0x97A24C7A, 0x0D257B37,
		0x44607D04, 0xCBBF5758, 0x6293728F, 0x5A9C6384,
		0x8C3FF67D, 0x93991C7A, 0xB35E69A0, 0xC31D34ED,
		0x8E23A9F1, 0x2AF0F10D, 0x54A122FE, 0x3BA5C967,
		0xEC8C6167, 0x03BE4D67, 0x1761423B, 0x594D2A08,
		0x9B899DEE, 0x963B045E, 0x1BC32B41, 0xB3681CDB,
		0x25224607, 0x86955F4F, 0xEB0E9CD6, 0x61983D1F,
		0x4F14B7EB, 0xFB85C761, 0x91186E13, 0x56427BC8,
		0x80BF7F77, 0xB2CDEEE6, 0x4016C99F, 0xBE62A828,
		0xF4E2729C, 0x41C585F6, 0xA81E356D, 0x94A3CC88,
		0x8D40025C, 0xF4932C1E, 0xF9B1B7FF, 0x76EDEA2F,
		0x3B172B46, 0x2559D7E7, 0xAB0CC042, 0xF2B42392,
		0xFEA3481F, 0x166FE898, 0x86332865, 0x0F959CF3,
		0x8C7F3D52, 0x06EE7C4D, 0xE35ED66D, 0xD18A30D6,
		0xC7CA178A, 0xD4597670, 0xD7236762, 0x7ADF8104,
		0xD3966F5A, 0x7EA3FAFD, 0x33A63D2E, 0x2F9B9AE8,
		0x18704992, 0xFAD8D330, 0x3D639A38, 0x514EDE41,
		0x589E6661, 0x8DF500AB, 0xF67ABA4A, 0xD746ACEB,
		0xEFE505A8, 0x48303D70, 0x7D38B73C, 0x248A9B8E,
		0xBD705D07, 0x92F59D86, 0x3226CFB5, 0x4AE2F1EB,
		0xEB215312, 0xF4387480, 0x43FB3A0A, 0xDA061C55,
		0x3EBFFC00, 0x18293802, 0x1C308872, 0x693A5EAA,
		0xA3A46C95, 0x8BE955E8, 0x4986BA90, 0xFE7EAED5,
		0xDF6D77B0, 0x726E976C, 0xD9542255, 0xCDDF732D,
		0x3BCACD8C, 0xEC5B48CF, 0x5F517F4B, 0x24759D34,
		0xBF030660, 0x2B4B5959, 0x8936B6C7, 0x814ED36E,
		0x6FC0B7EC, 0x6DB40C5D, 0x1F36E856, 0x22630715,
		0x9512ABBE, 0xC53A3B61, 0x89315611, 0x4A72F3BA,
		0xE98521DD, 0x11698273, 0xCBFF9C77, 0xF7E412B8,
		0x0A9CDC49, 0x9EA8F246, 0xDA70A201, 0x4DF7EEDD,
		0x409F7171, 0xCF59E192, 0x15EAFF30, 0x29BC9564,
		0x1F62B672, 0x9A5AD187, 0x8047991B, 0x7B829555,
		0x7FED9B71, 0x79AF5F74, 0xEB872438, 0x10A374A5,
		0xAE1C3A47, 0x93FCD7F3, 0x2664ED0C, 0x58BB66C7,
		0x8DB8E430, 0x3DDC57AD, 0xC64AE511, 0xB1201D73,
		0x24727DE2, 0x743F26B4, 0xAD0ECF68, 0xF5EB38E9,
		0x5587A74F, 0xBA47A241, 0xF23A7BAA, 0x44A42171,
		0x7122F305, 0x9297B6D9, 0x6C206BCD, 0x570135F0,
		0x946790FD, 0x37DDA601, 0x0497E848, 0xCF0DBFB6,
		0xADD329A2, 0x3CE9A7C1, 0xA1DA1846, 0x6C861CE7,
		0xB39A35D5, 0x798090B0, 0x7E276DA7, 0x1C4CF944,
		0x8F9FE173, 0x3C5B45E0, 0x680FAEC6, 0xC43491C2,
		0x564F547C, 0xDE6EF2A7, 0xF3C118D1, 0x0C44D57F,
		0x9BC956C1, 0x034C6469, 0x4BC3948C, 0xA1FF18E0,
		0x6CCBF87C, 0x783CD832, 0x688CD94A, 0x20E2757C,
		0x700EB9D6, 0x869870FB, 0xB5DF1106, 0x2094CB28,
		0x0346AB0B, 0xDE2E3988, 0x66B678E6, 0x5C446AB2,
		0x895E52FA, 0x4AA5DA12, 0xB56A13F1, 0x227D5D7C,
		0x2DB1B01F, 0x4726D60F, 0x15916ED0, 0x04250A69,
		0x06D80936, 0x0561A487, 0xD93CC668, 0x06347A51,
		0xE1606991, 0xA39219EE, 0x6DD62702, 0x41304C2E,
		0x3F80C30E, 0xEA546851, 0x06DFE9E0, 0xCE5D8453,
		0x5F795059, 0x7AE9F47F, 0x35A91DB0, 0x76150C43,
		0xF25850F5, 0x1AA28509, 0x6CC1371E, 0xEDD17536,
		0xAFC5B94C, 0x106DE7B2, 0x816C331E, 0xA4B173A3,
		0x2057778B, 0x72E72F82, 0xA86F6BEF, 0x2CD7FE81,
		0x53B3DD1E, 0x5B27CBD0, 0x51A86244, 0x29720673,
		0x3012BF2B, 0xAD1775D7, 0x8674039C, 0x51DEDC10,
		0x5A3A14AE, 0x68A4F658, 0x7E7E1C37, 0xFAA4A206,
		0xDBC625E1, 0xCEB1F734, 0xBB789D4F, 0x00472BF9,
		0x5E4B40E3, 0xD64529FC, 0x6E4A8A15, 0x9D20CA5A,
		0x2B2E92D0, 0x1C0C326B, 0x1AE88144, 0x6C5BFA2D,
		0x7A98AAFD, 0x8DDD2FB9, 0xA8E6D301, 0x5DECB73B,
		0xB2BB50B2, 0x335EDB42, 0xE6D4E15B, 0x278B1B7C,
		0x3D15246C, 0x2206CC9C, 0x00282F12, 0x5E9C694B,
		0x8AAA1BD0, 0x5D5E551A, 0x7B6EE632, 0x9BEC5667,
		0x030180F2, 0x8065796B, 0xB0F3511A, 0x320EE0A7,
		0x147E98A0, 0x618B48C2, 0xA966219A, 0x3895DC38,
		0x41EA4A32, 0x3DBE7CF2, 0x984C4169, 0xACC3D968,
		0x5B34BE0D, 0xB7DAF435, 0xEA621D2A, 0xE0E09B0A,
		0xC6EB72ED, 0x9E873D82, 0x4FD0EB9E, 0x4118633C,
		0x611CAA45, 0x60FE7381, 0x5B81BCFA, 0xB5336261,
		0xC495063E, 0x79E8748D, 0xB5CC64DB, 0xC6E65D59,
		0xC056B052, 0x0EDC1DA9, 0x0D4A7FDC, 0x44B754AC,
		0x97506574, 0x5187AD80, 0xBCD24FEC, 0x3CFD32CA
#if(DEFAULT_PAGE_MAIN_SIZE == 16384)
	,	0x8C94AEE3, 0x29D3918F, 0x1FB59FDA, 0xC6B5E3AB,
		0xB3534614, 0x9DCCB93D, 0xCF2F5FC6, 0x66A2EDED,
		0x710ADC17, 0xCC0BDF92, 0xE68A701D, 0x0A5F60EA,
		0xEF0976CF, 0xAC31F066, 0x079668BA, 0x4F68C6DD,
		0x1D2078B8, 0x0EE74766, 0xB5A480E6, 0x0D0D5425,
		0x1AFC144F, 0x41154C88, 0x3FCD2795, 0x21F285B6,
		0x17D3A01A, 0x90989C88, 0x333B10CB, 0x73EE65F7,
		0xBC2D4956, 0x3E8E69AD, 0x352A6A3C, 0x92C3E8FD,
		0xD419BD5F, 0x42540755, 0x2ADF3EC9, 0xC1016B61,
		0x374A4486, 0xCD0FBA53, 0xAC19DF74, 0x590A01F1,
		0xC5C2DD0D, 0x407E2DA2, 0x7589A154, 0x2E48D681,
		0x0E0CD4D7, 0x9A996D24, 0xF1E61D92, 0x0DC3C732,
		0x358C1D16, 0x7658E8D8, 0x39FEBD12, 0x0BAECCF3,
		0x32042FC5, 0x819335A4, 0xA6C228C4, 0x99E9B354,
		0xC9F756F0, 0x63C3496A, 0xA8361A7F, 0xCA3FA5C3,
		0x07EA198C, 0xA9CD7904, 0x82DF51CD, 0xED01BC48,
		0x3816ABB4, 0xA53CAE8C, 0x1BFF9158, 0xC0BAC335,
		0xEADDD0BF, 0x77E4A05A, 0x2F5509FF, 0x370040CB,
		0xCD957760, 0x3B5000BF, 0x7B129704, 0x7D49E9BE,
		0x9CFEA987, 0x63838245, 0x3D417A48, 0x9A3F1A0E,
		0x157D1DB7, 0xE024C77F, 0x7C76D6B0, 0x6E83F9D4,
		0x796CE3D7, 0x9A26A0B1, 0x66E226C2, 0xE47DBC20,
		0x9C0B605F, 0xF41D7426, 0x43B6DE91, 0x11A0F1B2,
		0x2FB3B5FA, 0x46EC20D9, 0x7072C8E0, 0x603DCF22,
		0x2A203873, 0xC3723006, 0x8EF48059, 0x761FC321,
		0x67B5FDF1, 0xDDEBE50F, 0x5C4EA5D0, 0x1CB3FFFE,
		0x8DECBA14, 0x85E5813F, 0xD31FD7B4, 0x0F98B347,
		0xD2AEB082, 0x47E28A7A, 0xAF0CCA8D, 0xF421CE3F,
		0x3064017F, 0xDE5F670A, 0xDEC24AEF, 0x82B7B5F0,
		0x26EAB534, 0xE2BC0FA9, 0xEAF5FFAD, 0x2978C911,
		0xA5FF122F, 0x6A5E15D1, 0xB6FB9152, 0xA0BC56D8,
		0x781317F6, 0xFD2C90D5, 0x2C0DF89D, 0x518D62E2,
		0x293FE2E8, 0xFBB452CC, 0xBC1B3C2D, 0xD8B11B47,
		0x3D9C9C82, 0x533D8526, 0xE120A2BE, 0x36E579D9,
		0x3DD698CF, 0x53A74815, 0x76697D75, 0x14FDEF2C,
		0x855DAC7C, 0x8F27CC30, 0x60635E64, 0x07F443E5,
		0x116E62A5, 0x00C3BCA3, 0x71A18489, 0x76415267,
		0x4A618667, 0x0FF7B7AC, 0xD279992A, 0x1B0DB856,
		0x9C181582, 0x126FE257, 0x80A6C5C8, 0xC152D593,
		0x444FB2C0, 0x5E1F1EC7, 0x6E7CFF6E, 0x7B1FB8B0,
		0x2398646E, 0xDDF25FB0, 0x2FD19EA5, 0x18EA84A1,
		0x6D910CFB, 0x1F7B0CCD, 0xE9C5EAF2, 0x841EE244,
		0x9BFF23BA, 0xE5731683, 0x43756232, 0x6001753B,
		0x59F2E79D, 0x0C8DA6BE, 0x7F857F4C, 0xB2445608,
		0x312D8025, 0x5F6A2584, 0x9C9B620E, 0xF6B906E9,
		0xA6E72862, 0x99A457CF, 0x0251BB17, 0x72CF0090,
		0xF6F302A4, 0xA67DE551, 0x0EED8804, 0x20492DE2,
		0xCA443423, 0x2A738681, 0xB077C640, 0x1DE424CD,
		0xB47AE33B, 0x45A044B0, 0x3BB15C6C, 0xC1C2D7C2,
		0x46EBC00F, 0xBB4EE834, 0xE6785913, 0x56FDB65D,
		0x17BB4427, 0x5B7395F4, 0xE991B4D6, 0x3C2734D6,
		0x8EAA111F, 0x5BCBB8B7, 0xB5A9AF52, 0x53DCD9F5,
		0x5BF0E278, 0x0D475068, 0x1A66D97C, 0xD65C9343,
		0x1DD5B160, 0x9979B105, 0xCB53243F, 0x8692BF99,
		0x2032BC02, 0xE7DDAB2E, 0x33C939C5, 0x2F4CB340,
		0x449F7BBE, 0xC9CC0C3F, 0xDB2DB650, 0xE18C1AF6,
		0x4793D4F8, 0x1778F884, 0x2AD2117D, 0x9FD0E6B1,
		0x7646B2B1, 0x815DA6B3, 0x89B2219D, 0xAEA41704,
		0xCFC4CC77, 0x499F002F, 0x8DE195A0, 0xDB340CEF,
		0x92132183, 0x43CAAFA7, 0xF7054E6B, 0xB04C9C8F,
		0xA50ADBF7, 0xFDC0E3B2, 0xC80C358B, 0x2B23BD64,
		0x42DDBFBB, 0x5BE47773, 0x2009E6CD, 0x5F335414,
		0x7A73394C, 0xA2E0C27B, 0x540D9AB6, 0x4AD36446,
		0xC622012C, 0x7ACB140F, 0xFED8D9FF, 0x3BF67795,
		0x9F899721, 0x90AEE9F3, 0xD5046221, 0x7B589349,
		0x7DD3248D, 0x0BB7764C, 0x419B14B0, 0x85CA4EFB,
		0x46BF9E2B, 0x03773EA6, 0xF32D6BB6, 0xE8451869,
		0xE1678947, 0x68AE393A, 0xEB93B133, 0x3DEDC200,
		0xEB49B72F, 0x3FD37DFC, 0x99519E17, 0x95CF4D74
#endif
	},
	{	0xB78D4AC3, 0x9D63EF68, 0x77F03B9E, 0x008E56F3,
		0xBC9680C7, 0xAD8A52F9, 0xDC94152A, 0x3B4095B4,
		0x565C25A1, 0x381864D6, 0x34D10388, 0xD8B6F55A,
		0xF43155FB, 0x1BBB5E73, 0x51CDA702, 0xBAD96F76,
		0x6577A065, 0x66BCB784, 0xCDA9C3B6, 0x4E1736F8,
		0x7A2A48D8, 0x440C9939, 0x00505E24, 0xBC39D296,
		0x155536A1, 0xBABCAA34, 0xF6DCCD64, 0x37D9ACCE,
		0x060201E5, 0x01CAF2D6, 0x61E7A234, 0x641CC14F,
		0x28FC3141, 0xC2179085, 0x53CC4235, 0x702BB970,
		0x82D59464, 0x7A7DF8E5, 0x319882D2, 0x5987B3D0,
		0xB6687D1A, 0x6FB5E96A, 0xD5C43A54, 0xC1C13714,
		0x8DD7E4DB, 0x3D0F7A05, 0x9EA1D73D, 0x8230C678,
		0xC238558A, 0xC0FDE603, 0xB60379F5, 0x6B66C4C2,
		0x892B0C7C, 0xF2D1E81B, 0x6B99C8B7, 0x8DCDBAB2,
		0x81AC61A4, 0x1CB93A53, 0x1A94FEB9, 0x886FA859,
		0x2FA0CAE8, 0xA20F5B01, 0x79A59ED9, 0x78FB6495,
		0x19295DC7, 0x52A7231F, 0x3E6B3FB5, 0x8D6BC757,
		0x67A68C28, 0x3B99737A, 0x9F5EBE8D, 0xCC45DBDB,
		0xE214B92E, 0x9916BF25, 0xCD15E03A, 0x14BEC0D5,
		0xDF12EC9F, 0x5962E1CC, 0x0E2DD075, 0x9ED08DBB,
		0x3A40F071, 0x1CCF8ECC, 0x6B4901CD, 0x1A1AA84A,
		0x34F9289E, 0x822A9811, 0x7E9B4E2B, 0x42E50B6D,
		0x2EA74134, 0x21313911, 0x66762097, 0xE6DDCAEF,
		0x795A92AC, 0x7C1DD25B, 0x6A54D478, 0x2587D1FB,
		0xA9327BBE, 0x84A80EAA, 0x54BF7C93, 0x8302D6C2,
		0x6E94880D, 0x9B1E75A6, 0x5932BFE8, 0xB21402E3,
		0x8B85BB1A, 0x80FC5A45, 0xEA1343A8, 0x5C90AD03,
		0x1C18A9AF, 0x3533DA48, 0xE3CD3A25, 0x1A878F64,
		0x6A193A2C, 0xECB0D1B1, 0x72FD7B24, 0x165D99E7,
		0x64085E8B, 0x03276A49, 0x4D855089, 0x33D367A8,
		0x93EFACE1, 0xC68792D4, 0x516C34FE, 0x957E4B87,
		0x0ED53219, 0x539BF208, 0x05BFA29B, 0xDB027990,
		0x702C5769, 0x4B785D19, 0x36FF23B0, 0x8175876A,
		0xD5BBA17F, 0xEEC941B4, 0x5EAA12FF, 0x6E008097,
		0x9B2BEEC0, 0x76A0007F, 0xF6242F08, 0xFA92D37D,
		0x39FD530F, 0xC607058A, 0x7A82F490, 0x357E341C,
		0x2AFA3A6F, 0xC1488FFE, 0xF8ECAD61, 0xDC07F3A9,
		0xF2D8C7AF, 0x354C4163, 0xCCC54C85, 0xC9FA7940,
		0x3916C0BE, 0xE93AE84C, 0x866DBD23, 0x2241E365,
		0x5E676BF5, 0x8CD940B3, 0xE0E491C1, 0xC07A9F44,
		0x544070E6, 0x87E4600C, 0x1DE901B2, 0xEC3E8742,
		0xCE6BFBE3, 0xBBD7CB1E, 0xB89C4BA1, 0x3867FFFD,
		0x1BD97528, 0x0BCB037E, 0xA73EAF69, 0x1E31678E,
		0xA55D6105, 0x8EC515F4, 0x5F18951B, 0xE9429D7E,
		0x60C802FE, 0xBDBECE14, 0xBD8594DF, 0x056F6BE1,
		0x4CD56B68, 0xC5791E53, 0xD5EBFF5B, 0x52F09322,
		0x4BFF245E, 0xD4BC2AA3, 0x6DF723A4, 0x4179ACB1,
		0xF0262EED, 0xFB5821AB, 0x581AF13B, 0xA21BC4C5,
		0x527EC5D1, 0xF769A499, 0x7936785A, 0xB163368E,
		0x7A393905, 0xA67A0B4C, 0xC340457D, 0x6CCBF2B3,
		0x7AAD319F, 0xA64F902A, 0xECD2FAEA, 0x28FBDF58,
		0x0BBA59F8, 0x1F4E9960, 0xC0C6BCC8, 0x0EE986CB,
		0x22DCC44B, 0x00877947, 0xE2430913, 0xEC82A4CE,
		0x94C20DCE, 0x1EEF6F59, 0xA5F23354, 0x361A71AC,
		0x39302A05, 0x24DEC5AE, 0x014D8B91, 0x83A4AB27,
		0x889E6581, 0xBC3E3C8F, 0xDCF8FFDC, 0xF63E7161,
		0x4631C8DC, 0xBBE5BE61, 0x5EA33D4B, 0x30D50943,
		0xDA2318F7, 0x3EF6189B, 0xD38BD5E5, 0x093CC588,
		0x37FF4675, 0xCBE62C07, 0x86EAC464, 0xC002EA76,
		0xB2E5CF3B, 0x181B4D7D, 0xFE0BFE98, 0x6588AC10,
		0x625A014A, 0xBED44A09, 0x3937C41C, 0xED730CD3,
		0x4DCF50C4, 0x3349AE9F, 0x04A2772E, 0xE49F0021,
		0xEDE70449, 0x4DFACBA2, 0x1CDB1108, 0x40925AC5,
		0x95886846, 0x54E60D03, 0x61EE8D80, 0x3AC9489B,
		0x69F4C776, 0x8A418861, 0x7663B8D8, 0x8385AF85,
		0x8CD7811E, 0x779CD168, 0xCDF0B226, 0xACFB6DBA,
		0x2E77884E, 0xB6E62BE9, 0xD32369AD, 0x784E68AD,
		0x1D55223E, 0xB697716F, 0x6B535FA4, 0xA6B9B3EB,
		0xB6E1C5F0, 0x1A8EA0D0, 0x34CCB3F8, 0xADB82786,
		0x3AAB63C0, 0x33F2630A, 0x97A6487E, 0x0D257F33,
		0x40647904, 0xCFBB575C, 0x6693728B, 0x5E986780,
		0x883FF67D, 0x9399187E, 0xB75A6DA0, 0xC31934ED,
		0x8E27A9F1, 0x2EF0F109, 0x54A522FA, 0x3FA1CD63,
		0xEC8C6563, 0x03BA4D67, 0x1365423B, 0x5D492E08,
		0x9F8999EE, 0x923F005E, 0x1BC32B41, 0xB76818DF,
		0x25264207, 0x86955F4F, 0xEF0A9CD6, 0x6198391F,
		0x4B14B7EF, 0xFB81C765, 0x91186A17, 0x56467BC8,
		0x84BB7F77, 0xB6C9EEE6, 0x4012CD9B, 0xBE66A828,
		0xF4E67298, 0x45C185F6, 0xA81A356D, 0x94A7C88C,
		0x8D440258, 0xF497281E, 0xFDB1B3FF, 0x76EDEE2B,
		0x3F132F42, 0x215DD3E7, 0xAB08C442, 0xF6B02792,
		0xFAA7481B, 0x166FEC98, 0x82372861, 0x0B959CF7,
		0x8C7F3D56, 0x06EE7C4D, 0xE75AD66D, 0xD18A30D2,
		0xC3CE138E, 0xD05D7274, 0xD7276366, 0x7ADB8500,
		0xD7926F5E, 0x7EA7FAF9, 0x33A23D2E, 0x2B9F9AE8
#if(DEFAULT_PAGE_MAIN_SIZE == 16384)
	,	0x18704992, 0xFAD8D330, 0x39679A38, 0x514ADE45,
		0x589A6665, 0x89F504AB, 0xF27EBA4A, 0xD346ACEF,
		0xEBE505AC, 0x4C303974, 0x7D3CB33C, 0x248E9B8A,
		0xBD745907, 0x96F19D86, 0x3222CFB5, 0x4AE2F1EB,
		0xEB215312, 0xF03C7084, 0x47FB3A0A, 0xDA021C55,
		0x3ABFFC04, 0x18293802, 0x18348872, 0x6D3A5AAE,
		0xA3A06C95, 0x8BE951EC, 0x4D82BE90, 0xFA7EAED5,
		0xDF6D77B4, 0x766A976C, 0xDD502651, 0xCDDF7729,
		0x3FCAC98C, 0xE85F48CB, 0x5F557B4F, 0x20759D34,
		0xBB070264, 0x2F4B5959, 0x8D32B6C7, 0x854AD76A,
		0x6FC4B3EC, 0x6DB40C5D, 0x1F36EC52, 0x26630315,
		0x9116ABBA, 0xC13E3B61, 0x89315215, 0x4E72F3BA,
		0xE98125D9, 0x15698273, 0xCBFB9C77, 0xF3E416B8,
		0x0E98DC4D, 0x9AACF242, 0xDE70A201, 0x49F7EEDD,
		0x409B7571, 0xCB5DE192, 0x15EEFB34, 0x29B89564,
		0x1F66B276, 0x9A5AD183, 0x84439D1B, 0x7B829155,
		0x7FED9F71, 0x79AB5F74, 0xEF83243C, 0x14A370A5,
		0xAA1C3E43, 0x97F8D7F7, 0x2664ED0C, 0x58BB62C7,
		0x8DBCE034, 0x39DC57AD, 0xC24EE115, 0xB1201977,
		0x247679E6, 0x703F26B4, 0xA90ECF6C, 0xF5EF38E9,
		0x5187A74F, 0xBA43A641, 0xF23A7BAA, 0x44A42571,
		0x7122F301, 0x9693B6DD, 0x68246BC9, 0x570531F4,
		0x906794F9, 0x33DDA605, 0x0497EC48, 0xCB0DBFB6,
		0xA9D729A2, 0x3CEDA3C5, 0xA5DA1842, 0x6C861CE7,
		0xB39A31D5, 0x7D8090B0, 0x7E276DA7, 0x184CFD40,
		0x8B9FE573, 0x3C5F41E4, 0x680BAEC6, 0xC43495C2,
		0x564F547C, 0xDA6EF6A3, 0xF7C118D1, 0x0844D57F,
		0x9BC952C5, 0x0748646D, 0x4BC3908C, 0xA5FB1CE0,
		0x68CFF878, 0x7838DC32, 0x6C88DD4A, 0x24E2717C,
		0x700ABDD2, 0x869C70FB, 0xB1DF1502, 0x2090CF28,
		0x0342AF0B, 0xDE2E3D88, 0x62B67CE2, 0x58446EB2,
		0x895A56FA, 0x4AA1DE12, 0xB56E13F1, 0x26795D7C,
		0x2DB5B01B, 0x4326D60F, 0x11956AD4, 0x04250E69,
		0x06DC0932, 0x0165A087, 0xD938C66C, 0x02347E51,
		0xE5606991, 0xA39219EA, 0x6DD62706, 0x4530482E,
		0x3B84C30A, 0xEA506C51, 0x02DFEDE0, 0xCA5D8457,
		0x5F7D5059, 0x7AE9F07F, 0x31AD19B4, 0x76150C47,
		0xF25850F1, 0x1EA2810D, 0x6CC5331E, 0xEDD57136,
		0xABC5BD48, 0x1469E7B6, 0x8168371A, 0xA0B573A3,
		0x2053778F, 0x76E32F86, 0xA86B6FEB, 0x2CD7FE85,
		0x53B3D91E, 0x5F23CFD0, 0x51A86240, 0x29720277,
		0x3412BB2F, 0xAD1775D7, 0x82740798, 0x55DADC14,
		0x5A3A10AE, 0x6CA0F65C, 0x7E7E1C37, 0xFAA0A602,
		0xDFC225E5, 0xCEB5F334, 0xBB78994F, 0x00432FF9,
		0x5E4F40E3, 0xD6452DF8, 0x6A4E8A11, 0x9924CA5A,
		0x2B2A96D0, 0x1C0C366B, 0x1EE88140, 0x6C5FFA29,
		0x7A98AAF9, 0x89DD2FBD, 0xA8E2D701, 0x59ECB73F,
		0xB2BB50B2, 0x335ADF42, 0xE6D4E55B, 0x278F1B78,
		0x3D15246C, 0x2202CC9C, 0x00282B16, 0x5A9C6D4B,
		0x8AAA1BD0, 0x595E551E, 0x7F6AE636, 0x9BE85667,
		0x030180F2, 0x80617D6B, 0xB4F3511A, 0x320AE4A3,
		0x107E9CA0, 0x618B48C2, 0xA962259A, 0x3891DC3C,
		0x41EA4A32, 0x39BE7CF6, 0x98484569, 0xACC7D968,
		0x5F30BE0D, 0xB3DEF035, 0xEA62192E, 0xE4E09B0A,
		0xC2EF72E9, 0x9E873D86, 0x4FD4EB9A, 0x45186338,
		0x6118AE41, 0x60FA7781, 0x5B81B8FE, 0xB5376261,
		0xC495063E, 0x79E8708D, 0xB1CC64DF, 0xC2E65D5D,
		0xC052B452, 0x0EDC1DAD, 0x0D4E7BDC, 0x44B754AC,
		0x93546174, 0x5583AD84, 0xB8D64BEC, 0x38FD36CA,
		0x8C94AEE7, 0x29D3918B, 0x1BB59FDE, 0xC6B5E7AB,
		0xB7534214, 0x9DCCBD39, 0xCF2F5FC6, 0x66A6E9ED,
		0x710AD817, 0xCC0FDB96, 0xE28E7019, 0x0E5B64EA,
		0xEF0D72CF, 0xA835F062, 0x07966CBA, 0x4B6CC2DD,
		0x1D2478B8, 0x0EE74766, 0xB5A484E2, 0x0D0D5425,
		0x1AF8144F, 0x45114C8C, 0x3FCD2795, 0x21F281B6,
		0x13D7A01A, 0x9098988C, 0x373B10CB, 0x77EA65F7,
		0xBC2D4D52, 0x3E8E6DA9, 0x352E6A38, 0x96C3E8F9,
		0xD41DB95F, 0x42500755, 0x2ADB3ECD, 0xC5016B61,
		0x334E4086, 0xCD0FBE53, 0xA81DDB74, 0x5D0A01F1
#endif
	},
	{	0x7457C681, 0x66E5C614, 0x2F4D90FC, 0x1A4AFE66,
		0x80C8F208, 0x9F77AEB8, 0xCC27E417, 0xBC31CE01,
		0x117EEDFA, 0x273330FC, 0x6FB4DA41, 0x873268DB,
		0x1D4E53E3, 0x5CE1E312, 0xA84B44F5, 0x7E439BC6,
		0xD919CAC6, 0x06759ACE, 0x26CA8476, 0xBA925C10,
		0x3F1333DD, 0x257E00BC, 0x36875682, 0x6FD030BF,
		0x4A4C840E, 0x0D2BBE9E, 0xDF1439AD, 0xC231723E,
		0x96286FDF, 0xF7038FCA, 0x2330D42E, 0xAC8CF691,
		0x0977FEEE, 0x6D93DDCD, 0x80249B37, 0x7DCC5150,
		0xE9CDE431, 0x8A830BED, 0x51346ADA, 0x294F9119,
		0x1B8804B0, 0xE92F503C, 0xFB6367FF, 0xECDBDD56,
		0x7E265E84, 0x42BAA7CF, 0x57108984, 0xED614E25,
		0xF54F9036, 0x2CDED931, 0x056E50C2, 0x162B39EF,
		0x19FE7AAC, 0x0CDDF89A, 0xCFB4ADDA, 0xA31560A5,
		0x879D261D, 0xA1BAE4E8, 0xAF4EC6CC, 0xF4B70B00,
		0xAF25DEBC, 0xFC4FF5F3, 0x66457A5C, 0x563F35D1,
		0x30E09225, 0xF5B1A760, 0x72CE3570, 0xA294BD8A,
		0xB035CCCA, 0x13EB0857, 0xE5FC7594, 0xA78C59DF,
		0xD7CB0A59, 0x986072E8, 0xFA786778, 0x481D3715,
		0x7BE8B20E, 0x2DE33B0D, 0x64449F6B, 0x94C5E3D7,
		0xD742A624, 0xE178E009, 0x8EF77414, 0xB50438AA,
		0x747FF908, 0x30527004, 0x306811E4, 0xDA74B45D,
		0x4741D82B, 0x17D3A2D9, 0x9A057D21, 0xF5FC5DAB,
		0xBFDAEE69, 0xECD42FD8, 0xBBA04CA2, 0x9BBFEE52,
		0x7E959319, 0xD1BE9097, 0xBEAAF69E, 0x40EA3B68,
		0x770E04C8, 0x5E96B2B2, 0x1B646D8F, 0x0B94AFD4,
		0xDE8967D9, 0xDA6918BA, 0x3E6CD9A4, 0x4CC6062A,
		0x232C5775, 0x837C76C2, 0x1362A42A, 0x9CE4E775,
		0xD3034AB3, 0x2AD205E6, 0x97F739EE, 0xE7C92C71,
		0x1C31B99A, 0x3559E584, 0xBDE04502, 0x92EFDDBB,
		0x8037EAE2, 0x97BAC325, 0x2ADDF768, 0x52712BC8,
		0x3ECC65EC, 0x35B4A307, 0x09863B36, 0xF60523AA,
		0xFEDB3FE2, 0xF257BEE8, 0xDF074878, 0x2847E04B,
		0x55387C86, 0x2FF1AFEF, 0x4CC8DB18, 0xB077C48F,
		0x1B79C168, 0x72B9AE5B, 0x859CC32A, 0x634032EE,
		0x48ECF2CD, 0xE07E4C69, 0x531C9FD8, 0xEBDF70D3,
		0xA20F4F9E, 0x75864D82, 0xE574F655, 0x88494AE2,
		0xE244E702, 0x2D276DBB, 0xD048D693, 0xAE0A62E9,
		0x21CE29F3, 0x66BB4D0A, 0x082FD990, 0x971A7F6D,
		0x53AF5245, 0x78DB478B, 0x4BB53084, 0xD80D38CF,
		0x673562AB, 0xFA012161, 0xFC4EDA4F, 0x3098FB80,
		0x173FCBE6, 0x78BE82C9, 0xD0165D8D, 0x89682B85,
		0xAC9EA8F8, 0xB5DCED47, 0xEF8330A3, 0x1088ABFE,
		0x3793A48B, 0x0E90C8DA, 0x96872119, 0x4BF738C1,
		0xD09FF1F0, 0xF070B964, 0xD811BB94, 0x48C5E2F8,
		0xE0147BA5, 0x0D39E0F7, 0x63BF2A04, 0x40219F50,
		0x06845F16, 0xBD5C7A11, 0xC46DF8C5, 0xB088DC65,
		0x13B4ACF5, 0x9443BD24, 0x6BDC26E3, 0x4CF2BAF8,
		0x5A6B6136, 0x864CAD1E, 0x222BD4A9, 0x084A1CD2,
		0x0CB91264, 0x02CA410F, 0xB3708DD8, 0x0468FCA2,
		0xCBC0D223, 0x472532D5, 0xDAAD4E0C, 0x8A60905C,
		0x76098714, 0xD5A0D8A2, 0x04BFDBC1, 0x95BA09AE,
		0xBEFAA0B2, 0xF4D3E1FE, 0x625B3269, 0xEC2A188E,
		0xE5B0A0E3, 0x3C45031A, 0xD88B663C, 0xDBABE26C,
		0x578B7B90, 0x28D2CF6D, 0x03D06E34, 0x416BE647,
		0x40A6EE1F, 0xECC75E0D, 0x51D6DED7, 0x58AFFD0B,
		0xA667B33C, 0xBE469FA1, 0xA251C480, 0x52E404EE,
		0x6824775E, 0x5B2EEAAF, 0x05E80E31, 0xAAB5B928,
		0xB474205D, 0xD841EDB8, 0xFCFC386E, 0xF5414D04,
		0xBF854ACB, 0x9D6BE768, 0x77F0339E, 0x00865EF3,
		0xBC9E80C7, 0xAD8A5AF1, 0xD49C1522, 0x334895B4,
		0x56542DA1, 0x38186CD6, 0x3CD10380, 0xD8BEF552,
		0xF43155F3, 0x13BB5E7B, 0x51C5AF02, 0xB2D96F7E,
		0x6577A065, 0x66B4BF84, 0xCDA9CBB6, 0x4E1F36F0,
		0x7A2A48D8, 0x44049939, 0x0050562C, 0xB439DA96,
		0x155536A1, 0xB2BCAA3C, 0xFED4CD6C, 0x37D1ACCE,
		0x060201E5, 0x01C2FAD6, 0x69E7A234, 0x6414C947,
		0x20FC3941, 0xC2179085, 0x53C44A35, 0x7023B978,
		0x82D59464, 0x727DF8ED, 0x31908AD2, 0x598FB3D0,
		0xBE607D1A, 0x67BDE16A, 0xD5C4325C, 0xC9C13714,
		0x85DFE4D3, 0x3D0F7A0D, 0x9EA9D735, 0x8A30C670,
		0xC2305D82, 0xC0F5EE03, 0xB60371FD, 0x6B6EC4C2,
		0x892B0C7C, 0xF2D1E01B, 0x6399C8BF, 0x85CDBABA,
		0x81A469A4, 0x1CB93A5B, 0x1A9CF6B9, 0x886FA859,
		0x27A8C2E8, 0xAA075B09, 0x71AD96D9, 0x70FB6C95,
		0x19295DCF, 0x52A72317, 0x366B3FBD, 0x8D6BCF57,
		0x6FA68428, 0x3B997B72, 0x9F5EBE8D, 0xCC4DD3DB,
		0xE214B12E, 0x991EB72D, 0xC51DE032, 0x1CB6C8D5,
		0xDF1AE49F, 0x516AE1C4, 0x0E2DD875, 0x96D885BB,
		0x3A48F071, 0x1CCF8ECC, 0x6B4909C5, 0x1A1AA84A,
		0x34F1289E, 0x8A229819, 0x7E9B4E2B, 0x42E5036D,
		0x26AF4134, 0x21313119, 0x6E762097, 0xEED5CAEF,
		0x795A9AA4, 0x7C1DDA53, 0x6A5CD470, 0x2D87D1F3,
		0xA93A73BE, 0x84A00EAA, 0x54B77C9B, 0x8B02D6C2,
		0x669C800D, 0x9B1E7DA6, 0x513AB7E8, 0xBA1402E3
#if(DEFAULT_PAGE_MAIN_SIZE == 16384)
	,	0x838DB31A, 0x88F45A4D, 0xE21B43A0, 0x5C98A50B,
		0x1C18A9AF, 0x3533D248, 0xE3C53A2D, 0x1A8F876C,
		0x62193A2C, 0xE4B8D1B1, 0x72F57B2C, 0x1E5599EF,
		0x6C005E8B, 0x0B276249, 0x4D8D5081, 0x33D367A0,
		0x93E7ACE9, 0xCE8792D4, 0x51643CF6, 0x9D764B8F,
		0x0EDD3211, 0x5B93FA00, 0x05B7AA93, 0xDB0A7198,
		0x78245F61, 0x43785D19, 0x3EF72BB0, 0x89758762,
		0xD5B3A977, 0xEEC949B4, 0x56AA1AF7, 0x66088097,
		0x9B2BEEC8, 0x7EA00077, 0xFE242708, 0xFA9AD375,
		0x39FD5B07, 0xC6070582, 0x7A8AF490, 0x3D763C14,
		0x2AFA3A6F, 0xC1408FFE, 0xF8ECAD69, 0xDC0FF3A1,
		0xF2D0CFA7, 0x35444963, 0xC4CD448D, 0xC9FA7948,
		0x391EC0B6, 0xE13AE84C, 0x8665BD2B, 0x2241E365,
		0x566F63FD, 0x84D948B3, 0xE0E491C1, 0xC0729F4C,
		0x5C4070E6, 0x87E46004, 0x15E909B2, 0xE43E8F42,
		0xCE6BFBEB, 0xB3DFC31E, 0xB89C4BA9, 0x386FF7FD,
		0x1BD97D20, 0x0BCB0B76, 0xAF36AF69, 0x16396786,
		0xA5556905, 0x8ECD15F4, 0x5F189D13, 0xE94A957E,
		0x60C00AF6, 0xBDBECE1C, 0xB58D94D7, 0x0D676BE9,
		0x44DD6368, 0xCD711E5B, 0xD5E3FF5B, 0x5AF09322,
		0x43FF2C56, 0xD4B42AAB, 0x65FF23A4, 0x4971ACB9,
		0xF82626ED, 0xFB5829A3, 0x501AF933, 0xA213CCC5,
		0x5A76CDD1, 0xFF61AC91, 0x793E705A, 0xB1633686,
		0x7A39390D, 0xAE720B4C, 0xC3404575, 0x6CCBFAB3,
		0x7AAD3997, 0xAE479822, 0xECDAF2EA, 0x28FBDF58,
		0x03BA59F8, 0x1F4E9968, 0xC8C6B4C8, 0x0EE98EC3,
		0x22D4CC43, 0x0087714F, 0xEA43011B, 0xEC8AA4C6,
		0x9CC205CE, 0x16EF6F59, 0xADF23354, 0x361279A4,
		0x3938220D, 0x24D6CDA6, 0x01458B99, 0x83A4A32F,
		0x889E6D81, 0xBC3E3C8F, 0xD4F8FFDC, 0xFE367961,
		0x4631C0DC, 0xBBEDB669, 0x56AB354B, 0x30D5014B,
		0xDA2B10FF, 0x36FE109B, 0xDB83DDE5, 0x013CCD80,
		0x37F74E75, 0xC3EE240F, 0x86E2CC64, 0xC802E27E,
		0xBAE5C73B, 0x181B4D7D, 0xF60BFE98, 0x6D80AC18,
		0x6A520942, 0xBEDC4209, 0x313FC414, 0xE57B04DB,
		0x4DCF58C4, 0x3B41AE9F, 0x04A27726, 0xEC970821,
		0xE5EF0441, 0x4DFACBAA, 0x14DB1900, 0x409252CD,
		0x9580684E, 0x54E6050B, 0x69E68D88, 0x32C9489B,
		0x61FCC776, 0x8A498069, 0x7663B0D8, 0x8B85A78D,
		0x8CDF8116, 0x7794D960, 0xCDF8B226, 0xACFB6DBA,
		0x2E7F804E, 0xBEE623E9, 0xDB2361AD, 0x784E68AD,
		0x1D5D2236, 0xB6977167, 0x6B5B57AC, 0xA6B1BBE3,
		0xB6E1C5F0, 0x1A8EA8D0, 0x34C4BBF0, 0xA5B82F86,
		0x3AAB6BC0, 0x3BF26302, 0x97A6407E, 0x052D773B,
		0x4864710C, 0xCFBB5F54, 0x66937283, 0x5E986F80,
		0x883FFE75, 0x9391187E, 0xBF526DA8, 0xC3113CE5,
		0x8E2FA1F9, 0x2EF8F101, 0x54A522F2, 0x37A9C56B,
		0xE48C6D63, 0x0BB24D6F, 0x1B654233, 0x5D492E08,
		0x9F8999EE, 0x92370856, 0x1BCB2349, 0xB76018DF,
		0x2D264207, 0x8695574F, 0xEF0A9CDE, 0x6990391F,
		0x431CB7E7, 0xF389C765, 0x99106A1F, 0x564673C8,
		0x84B37F7F, 0xBEC1EEEE, 0x4812C59B, 0xBE6EA028,
		0xF4E67290, 0x4DC185F6, 0xA81A3D65, 0x9CA7C08C,
		0x8D4C0250, 0xFC97201E, 0xFDB9B3F7, 0x76E5EE2B,
		0x371B274A, 0x2155DBE7, 0xA308CC42, 0xFEB02792,
		0xFAAF401B, 0x1667EC98, 0x82372069, 0x039D94FF,
		0x8C7F3D5E, 0x0EE67C4D, 0xE752DE65, 0xD98238D2,
		0xC3C61B86, 0xD0557A74, 0xD7276366, 0x7ADB8D00,
		0xDF92675E, 0x7EAFF2F9, 0x3BA2352E, 0x239F9AE8,
		0x1078419A, 0xFAD8DB30, 0x316F9238, 0x5142DE4D,
		0x589A6E65, 0x89FD04A3, 0xFA76BA4A, 0xDB46A4EF,
		0xE3ED05A4, 0x4C38317C, 0x7D3CBB34, 0x24869B8A,
		0xB57C510F, 0x96F1958E, 0x3A22C7BD, 0x42EAF1E3,
		0xE3295312, 0xF8347884, 0x47F33A0A, 0xD20A145D,
		0x32BFFC0C, 0x1029380A, 0x183C807A, 0x653A5AAE,
		0xABA0649D, 0x83E959E4, 0x458AB698, 0xF27EAEDD,
		0xDF6D7FB4, 0x76629F64, 0xDD582651, 0xCDDF7F21,
		0x3FCAC98C, 0xE85F48CB, 0x575D734F, 0x2075953C,
		0xBB0F0264, 0x274B5959, 0x8D3AB6C7, 0x8D42DF62
#endif
	},
	{	0x7DC0FA34, 0xCE7BC3D4, 0xAB8964B8, 0x93836E28,
		0x0BBFC9A7, 0x7A1EF41A, 0x3D53AF6A, 0x15608DE0,
		0x8560BA05, 0x81EBDD06, 0x6D06E2FB, 0xD6DC8985,
		0x135618F8, 0xE5A3C136, 0xC633917F, 0x0B9B7575,
		0x0349D249, 0x387374B6, 0x3439ED73, 0x11DE51B2,
		0x4E5185D1, 0x550EB612, 0xE25B2DB3, 0xE0F7D82B,
		0x3252BA9F, 0xA44F462E, 0x6CD67E7B, 0x1BD69FAE,
		0xDE4D0950, 0x7633F6E4, 0x3FBC7D1B, 0x999AA7B7,
		0xC528635C, 0x333C6F5A, 0x8B3AC164, 0x386D91AB,
		0xBF34C93F, 0xA2D4C389, 0x1C5AB1EA, 0x2DB10B77,
		0x7490E1E2, 0x389F1D99, 0xD692128B, 0x34345194,
		0x68E3503D, 0x15443132, 0xFC379C56, 0x84CB06DA,
		0x4C5F8268, 0x42626232, 0xDCEC402F, 0xDDAB95DF,
		0xF2B43549, 0xF83AB5A6, 0xD4B8A9E0, 0x5A0FA3E7,
		0x5374E67D, 0x09411C55, 0xA86FF837, 0x1704AD85,
		0xCC39011A, 0x373CFA4D, 0xA2746FD1, 0x752804C7,
		0x071B6734, 0x11E9B49A, 0xC5368641, 0xB8314B16,
		0x3830535F, 0x6A66A590, 0xC78B745A, 0x341F0FD8,
		0xC4327458, 0xC971A363, 0xE4EBF658, 0x3CAA33DF,
		0xD800BC17, 0x164EC492, 0x9A1BA003, 0x66A7CE41,
		0x27CF59D3, 0x9D0F25A9, 0xA2C878ED, 0x3BEC961F,
		0x1CBB6422, 0xB627F500, 0x0A6F5527, 0xB714E231,
		0xF048BEC2, 0x86F0BA32, 0x7CEF5661, 0x13EA0FC4,
		0xAB6753EE, 0xDD939269, 0xAC5534EF, 0xCC10012F,
		0x3756DD91, 0xFC4100EE, 0xFD484E10, 0xF535A7EA,
		0x72FBB60E, 0x8D0E0A05, 0xF415E921, 0x7AEC7828,
		0x54F574DE, 0x83801FFD, 0xF1D95BD2, 0xB91EE743,
		0xE5A19F4F, 0x6A8892C6, 0x899B881B, 0x93F5F290,
		0x723C816D, 0xC374D198, 0x0DCA7B56, 0x4482C7CA,
		0xACDEC6FB, 0x09B39067, 0xC1C92383, 0x81E43F98,
		0xB880E0CD, 0x0FC9C008, 0x2AD31265, 0xC97C1F84,
		0x9DD6F7D7, 0x67BF873C, 0x71399653, 0x70DEEFFB,
		0x36B3FA40, 0x169716EC, 0x5F6C5FD2, 0x2C72CE0D,
		0x4BAAD20A, 0x1D9B2AE9, 0xBE303B26, 0xD3942BFC,
		0xC08114ED, 0x7B7D9D38, 0x6B1B29AF, 0x1ACED6D3,
		0x88BBC6D0, 0x9BE23CB6, 0xABC7FFB6, 0xB4E12744,
		0x86FF58AC, 0xA9695457, 0xCAFF4649, 0x92E25973,
		0xF14C4CDB, 0xF7B05247, 0xA034F366, 0x4526998B,
		0xB4EC9BA3, 0xFFC25923, 0xF27CE0B4, 0x63C66C0D,
		0xF472721A, 0x5DE41698, 0x87808AEA, 0xD897F567,
		0xF45B722F, 0x5D8E3144, 0xD9B5E5D5, 0x50F7BFB0,
		0x0675B2F1, 0x3E9C33D0, 0x918D6991, 0x1CD31D87,
		0x44A99986, 0x000FE29E, 0xD5860236, 0xD915498D,
		0x39850A9D, 0x2CDFDEB2, 0x5BE566A8, 0x6C24F249,
		0x7270441A, 0x48AD9B4D, 0x028A1733, 0x0749475E,
		0x113DDA03, 0x797C781F, 0xA9F1FFB9, 0xFD6CF2C2,
		0x8C6281B9, 0x77DB6DD2, 0xAC576A96, 0x60AB0296,
		0xB55620FF, 0x6CFD2037, 0xB707BBCB, 0x02789B01,
		0x6EEF9CEA, 0x87DD481E, 0x0DC599C8, 0x9104C5FC,
		0x75CB8F76, 0x30369AFA, 0xED16FD31, 0xDA015930,
		0xD4A41284, 0x7DB98412, 0x627E8928, 0xCBF608B7,
		0x9A9FB089, 0x76825D3F, 0x0845EE4C, 0xD92F1042,
		0xCBDF0882, 0x9AF59755, 0x28B73200, 0x8025A49B,
		0x2B01D09C, 0xA8CD0A16, 0xD2CD1B11, 0x64939037,
		0xC2F98FEC, 0x159201D2, 0xECC661B1, 0x170B4F1B,
		0x19BF032C, 0xEE29B3C0, 0x9BF1654C, 0x59F7DA75,
		0x5CFE019C, 0x7DCD46D3, 0xB746C25B, 0xF09CD05B,
		0x3ABA446C, 0x6D2FE2CE, 0xD6B6AE59, 0x4D6377C7,
		0x6DC38BE1, 0x341D51A1, 0x688977E1, 0x4B715E0D,
		0x7457D681, 0x76E5C604, 0x2F4D80FC, 0x0A5AEE76,
		0x90C8E218, 0x9F77BEA8, 0xCC27E407, 0xBC31DE01,
		0x117EFDEA, 0x272330FC, 0x7FA4DA51, 0x872278CB,
		0x1D5E43F3, 0x5CF1E302, 0xA84B44E5, 0x6E538BD6,
		0xC919DAC6, 0x16659ADE, 0x36CA8466, 0xBA925C10,
		0x3F1333DD, 0x256E10AC, 0x36974692, 0x6FC030BF,
		0x5A4C840E, 0x0D2BAE9E, 0xDF1439BD, 0xD221723E,
		0x86386FCF, 0xE7138FCA, 0x3320D43E, 0xAC8CE691,
		0x0967FEFE, 0x7D83DDDD, 0x90248B37, 0x7DDC4150,
		0xE9CDE421, 0x9A830BED, 0x51347ACA, 0x394F8119,
		0x1B9804A0, 0xF92F403C, 0xFB7367EF, 0xECCBDD56,
		0x6E364E94, 0x42AAB7CF, 0x47109984, 0xFD614E25,
		0xF55F8036, 0x2CCED931, 0x056E40D2, 0x063B29FF,
		0x19FE7ABC, 0x1CCDF89A, 0xCFA4BDCA, 0xB30570A5,
		0x878D360D, 0xA1AAF4E8, 0xAF4EC6CC, 0xF4B71B00,
		0xBF25CEBC, 0xFC5FE5F3, 0x76456A5C, 0x463F35D1,
		0x20F08235, 0xF5B1B760, 0x62DE2570, 0xA284BD9A,
		0xB035DCCA, 0x13FB0847, 0xF5EC7594, 0xB78C49DF,
		0xC7DB0A49, 0x987062F8, 0xFA787768, 0x480D3715,
		0x6BF8A21E, 0x2DE32B1D, 0x74448F7B, 0x84D5E3C7,
		0xC752A624, 0xF168F009, 0x8EE77414, 0xA51428BA,
		0x647FF918, 0x20527014, 0x307801F4, 0xCA74B45D,
		0x5741C83B, 0x07D3B2C9, 0x8A156D31, 0xE5FC5DBB,
		0xBFDAFE69, 0xECC43FC8, 0xBBB04CA2, 0x9BBFFE42,
		0x7E959319, 0xD1BE9097, 0xAEBAE69E, 0x40EA2B78,
		0x771E04C8, 0x4E96B2B2, 0x1B746D8F, 0x1B84BFC4
#if(DEFAULT_PAGE_MAIN_SIZE == 16384)
	,	0xDE9967C9, 0xCA7908BA, 0x2E7CC9B4, 0x5CC6062A,
		0x232C4775, 0x836C76D2, 0x1372A42A, 0x9CF4E765,
		0xC3134AA3, 0x2AC215E6, 0x97F739FE, 0xF7C92C61,
		0x0C31B99A, 0x2559F584, 0xBDF04502, 0x82FFCDBB,
		0x8027FAE2, 0x87BAD325, 0x2ACDF778, 0x42713BC8,
		0x2EDC65EC, 0x35B4B307, 0x09862B36, 0xE61523AA,
		0xEEDB3FF2, 0xF257BEF8, 0xCF174868, 0x2847E04B,
		0x45387C96, 0x3FE1BFEF, 0x4CC8CB18, 0xA077D48F,
		0x1B79D168, 0x62B9BE4B, 0x858CD32A, 0x634022FE,
		0x48ECE2DD, 0xF06E5C69, 0x531C9FD8, 0xFBCF70D3,
		0xA20F4F8E, 0x75964D82, 0xE564F655, 0x88494AE2,
		0xF244E702, 0x3D276DAB, 0xC058C693, 0xBE0A62E9,
		0x21CE29E3, 0x76AB5D0A, 0x082FC990, 0x871A7F7D,
		0x43BF4255, 0x68DB578B, 0x4BA53094, 0xC81D28DF,
		0x672572AB, 0xEA112161, 0xEC5ECA5F, 0x2098FB90,
		0x073FDBE6, 0x68BE92C9, 0xC0165D9D, 0x99682B85,
		0xAC8EB8E8, 0xA5DCFD47, 0xFF8320B3, 0x0098ABEE,
		0x3793B48B, 0x1E80D8CA, 0x86972109, 0x5BE738D1,
		0xC09FF1F0, 0xF070B974, 0xD811BB94, 0x48C5E2E8,
		0xF0047BB5, 0x0D29F0E7, 0x73AF3A04, 0x50218F50,
		0x16844F16, 0xAD5C7A11, 0xC46DE8D5, 0xB098CC75,
		0x03B4BCE5, 0x8453AD34, 0x7BCC36E3, 0x5CE2BAF8,
		0x5A7B6126, 0x864CAD0E, 0x322BC4B9, 0x084A0CD2,
		0x0CA91274, 0x12CA410F, 0xA3709DC8, 0x0468ECB2,
		0xDBC0C233, 0x472522D5, 0xDABD4E0C, 0x9A60805C,
		0x66198704, 0xC5B0C8B2, 0x04AFDBD1, 0x95BA19AE,
		0xBEFAB0A2, 0xE4D3F1EE, 0x624B3279, 0xEC2A089E,
		0xF5A0B0E3, 0x3C55030A, 0xC89B662C, 0xDBBBE26C,
		0x479B6B90, 0x38C2DF6D, 0x03C07E24, 0x516BE647,
		0x40A6EE0F, 0xFCC74E1D, 0x41D6DED7, 0x58BFED1B,
		0xA667A33C, 0xAE568FB1, 0xA241D480, 0x52F404EE,
		0x6824675E, 0x5B3EEAAF, 0x05E80E21, 0xBAA5B938,
		0xB474304D, 0xC851EDA8, 0xECFC387E, 0xE5514D04,
		0xAF954ACB, 0x9D7BE768, 0x77F0339E, 0x00864EF3,
		0xBC9E90C7, 0xAD8A4AF1, 0xD49C1532, 0x235885B4,
		0x56543DA1, 0x28187CC6, 0x3CD11380, 0xD8BEF552,
		0xF43155F3, 0x03BB5E7B, 0x51D5AF02, 0xA2D97F6E,
		0x6567B065, 0x76A4BF94, 0xDDA9CBA6, 0x5E0F36F0,
		0x7A3A48C8, 0x44048939, 0x1040563C, 0xA439DA96,
		0x155536B1, 0xA2BCBA2C, 0xEED4DD6C, 0x27D1BCCE,
		0x160201E5, 0x11C2EAD6, 0x69E7A224, 0x6404D947,
		0x20EC3951, 0xD2079095, 0x53D44A25, 0x6033A978,
		0x82C59474, 0x727DF8FD, 0x31909AC2, 0x599FA3D0,
		0xAE706D1A, 0x77ADF16A, 0xD5D4225C, 0xD9C12714,
		0x85CFF4C3, 0x3D1F6A1D, 0x9EB9C735, 0x8A20D660,
		0xC2205D92, 0xD0E5FE03, 0xA61361FD, 0x7B6EC4C2,
		0x992B0C6C, 0xF2D1F00B, 0x7389D8AF, 0x85CDAABA,
		0x91A469A4, 0x1CB93A5B, 0x1A9CF6B9, 0x886FA849,
		0x27A8C2E8, 0xBA074B19, 0x71BD86D9, 0x60FB7C85,
		0x19394DDF, 0x52B72307, 0x367B2FBD, 0x8D6BCF47,
		0x7FA68428, 0x2B997B72, 0x9F5EBE9D, 0xCC4DC3DB,
		0xE204B13E, 0x991EB73D, 0xD50DF022, 0x1CB6D8C5,
		0xCF1AF48F, 0x517AE1C4, 0x1E2DC875, 0x96D895AB,
		0x2A58E071, 0x0CDF8ECC, 0x6B4909C5, 0x1A1AB84A,
		0x34F1388E, 0x8A228819, 0x6E9B5E2B, 0x52E5036D,
		0x36AF4124, 0x31213119, 0x6E663087, 0xEEC5DAEF,
		0x795A9AB4, 0x7C1DDA53, 0x7A4CD470, 0x3D87C1F3,
		0xA92A73BE, 0x94A00EAA, 0x44B77C9B, 0x8B02C6D2,
		0x668C900D, 0x8B1E7DB6, 0x413AB7F8, 0xBA1412E3,
		0x838DA31A, 0x88E45A5D, 0xE20B53A0, 0x4C98B50B,
		0x0C18B9AF, 0x2533D258, 0xE3C52A3D, 0x0A9F876C,
		0x72093A3C, 0xE4A8D1B1, 0x62F57B3C, 0x0E5599FF,
		0x6C004E9B, 0x0B276249, 0x4D8D4091, 0x23D377A0,
		0x93F7ACE9, 0xDE8782D4, 0x41742CF6, 0x9D765B8F,
		0x0ECD3211, 0x5B93FA10, 0x15A7BA83, 0xCB1A6198,
		0x78344F71, 0x53685D19, 0x2EF73BA0, 0x99659762,
		0xD5B3B967, 0xFEC949A4, 0x56BA0AF7, 0x66088087,
		0x9B3BEEC8, 0x6EB00067, 0xFE342708, 0xEA9AD375,
		0x29FD5B17, 0xD6070582, 0x7A9AE490, 0x2D763C14
#endif
	},
	{	0x36310841, 0xF35E8078, 0xF7E6CEDF, 0xD997BBAC,
		0xDC6C9C29, 0x84556F9F, 0x8E203309, 0xFBC29C4A,
		0xEBBE016C, 0x589DB362, 0x0ADC80A5, 0x0C7652FF,
		0x32FDF479, 0x389BF135, 0x9F497B95, 0x670AE04B,
		0x0F1B6C1A, 0x4355E9D1, 0x5F9C8D99, 0xE96F3600,
		0x7F4A9D79, 0xF9BECBE7, 0xEC8AD4B8, 0x8C7E6AA3,
		0x40E1056A, 0xEB636FC0, 0xC4BD4AE0, 0x45097B35,
		0x616AB995, 0x26F7108E, 0xEBD9EA29, 0x6F1992BF,
		0x8FB71492, 0x31E0C4F1, 0xF5F0EED0, 0x901A6E2A,
		0xD6F1453C, 0x5AC7563A, 0xE8881FF6, 0x09ABC78F,
		0x8FA44D48, 0xE3D0E112, 0x1DCFE828, 0x4B285075,
		0xC8FEF330, 0x40A4E028, 0x60F002E9, 0x95E869BA,
		0xAE829176, 0x0EA76593, 0x152ADA62, 0xCBF9BA77,
		0x7FB5FDD2, 0xD9897E91, 0x77619845, 0x377FFD84,
		0xFC2B2732, 0xA37D212F, 0x5D75CD3D, 0x80D556F0,
		0xEE3C0891, 0x9C2D6565, 0x36E8DA1F, 0x36097F89,
		0xBD33CE93, 0x95F21075, 0x5CF89369, 0xB88D0C54,
		0x46588EEA, 0x07D8ECA5, 0x26E44954, 0x39E9CFCA,
		0x87269447, 0x54852ACD, 0x2FEF72FD, 0xEF9358C2,
		0x18627335, 0x4AB2EB09, 0x7BE18A04, 0x05FF9B77,
		0x014EF5C5, 0x0F75A74A, 0x549BEFF0, 0x84E27691,
		0x5CB9CAD9, 0x6A69670E, 0x120D566C, 0xCD2A4655,
		0xDDB77EE5, 0xE5AE7DF1, 0x9F2E90D0, 0x508EC196,
		0x8A70F82D, 0x7EC37FDF, 0x98919730, 0x41EEA91F,
		0x36F2A3D0, 0xC4737D96, 0x0B19A754, 0xC68044FD,
		0x90D9C5BB, 0xE1DCB8D2, 0xA6383FB1, 0xF79FE0A7,
		0x451E9E1D, 0xEA2D9A05, 0xCBC8EDAA, 0x119294C5,
		0xE588CF04, 0x7A4EDA57, 0x81B08D27, 0x7D14C4D3,
		0x429D52C7, 0xEC57BA14, 0x105E9321, 0x0F34FEFA,
		0x867F84AA, 0xD0B7AE17, 0x964B6029, 0x913A50BF,
		0xCE4AE457, 0xD52242C2, 0xD9BC95BE, 0x4031F721,
		0x0E7EB7CD, 0xD07D2593, 0x812CBA3B, 0x33D0560B,
		0x591D71D1, 0x4BB9FB8E, 0xFF074067, 0x003157DD,
		0x6E276917, 0x3C01B195, 0x0D2F4212, 0xB6CF70A3,
		0x813FE3E1, 0xE1E073E8, 0xB1227729, 0x908BC5D1,
		0xE108F66B, 0x1A52E1CF, 0xE65F7408, 0xA0421FA0,
		0x2C099E2C, 0x5BB8F422, 0x89DAD1AB, 0x613199EA,
		0x066979CB, 0x09A65B68, 0xF6996CC7, 0xB8C575F1,
		0xB4F6C24C, 0x0D985B1C, 0x64568973, 0x109418A5,
		0x185324E8, 0x2495821E, 0x47E03B91, 0x08D0D965,
		0xB7818566, 0x8E4A44AB, 0xB57B9C18, 0x35C001B8,
		0xCC320F08, 0x8B619165, 0x085FB7A3, 0x2B75325D,
		0x7DF56145, 0xC9A7E3DD, 0xC49664F2, 0xD954103D,
		0xEB4161C7, 0x78AA0614, 0x9137CC58, 0xB777C5D8,
		0x8E37D621, 0x7085BFDA, 0x0681FC48, 0xA2D6CD8E,
		0x804DDD1E, 0xF98F9C3A, 0x82ADBDAF, 0xB07FDB36,
		0x4DCE4778, 0x5DAC1F63, 0x4582A901, 0xA4E908DD,
		0xD048CEBC, 0xB67CD55F, 0x0AD11C42, 0x754B7370,
		0x69E8609A, 0x91A2DB51, 0xD9F970FC, 0xCBA29A08,
		0x5F2B9497, 0x3BF6CFD0, 0xEEE1663D, 0x000D9CE7,
		0x793D218F, 0x5B1594E3, 0xA9392A64, 0x46B00B69,
		0xACA87A43, 0x5030F88D, 0x78A32601, 0xB17DEBA4,
		0xE962AAE7, 0x0677BCF6, 0xA2AB5F04, 0x45B3FEDC,
		0xCACE61CA, 0xEC497F29, 0xBB53974D, 0xBC1E6CE1,
		0xF4749091, 0x88081372, 0x2080AC78, 0x4972B52D,
		0x2AAA6C63, 0x45797558, 0xDDA9BBD8, 0x4EA3799D,
		0x2C0402CB, 0x2285D5AD, 0xD2CF4548, 0xC808B38E,
		0x40D972A2, 0xA50E212B, 0xA6A9944A, 0xC06653F0,
		0x058B29E8, 0xE4FAF1FB, 0x62213585, 0xB23F47A1,
		0x5DE0DA34, 0xEE5BE3D4, 0xABA944B8, 0xB3834E28,
		0x0B9FE987, 0x7A3ED43A, 0x3D738F6A, 0x1540ADC0,
		0x8540BA25, 0xA1CBFD06, 0x4D26C2FB, 0xF6DC8985,
		0x335618D8, 0xE5A3E116, 0xE613B15F, 0x0B9B5575,
		0x2349D249, 0x387374B6, 0x3439ED73, 0x11DE5192,
		0x4E5185D1, 0x750E9632, 0xE27B0DB3, 0xC0F7F80B,
		0x32729ABF, 0xA46F460E, 0x6CF65E7B, 0x1BD69F8E,
		0xFE4D0950, 0x5633F6E4, 0x3FBC7D3B, 0x999A87B7,
		0xC508637C, 0x333C6F7A, 0xAB1AE144, 0x386DB18B,
		0x9F34E91F, 0xA2F4C389, 0x3C5A91EA, 0x2DB12B57,
		0x54B0C1E2, 0x18BF1D99, 0xD692128B, 0x34347194,
		0x68E3701D, 0x15441132, 0xDC37BC56, 0xA4CB06DA,
		0x6C5F8248, 0x62426232, 0xDCCC600F, 0xDD8BB5DF,
		0xF2B43569, 0xF83AB5A6, 0xF498A9E0, 0x7A0F83E7,
		0x5354E67D, 0x29411C55, 0x886FF837, 0x17048DA5,
		0xCC19211A, 0x173CFA6D, 0x82746FF1, 0x752824C7,
		0x071B4734, 0x11C9B4BA, 0xC516A641, 0x98316B16,
		0x1830735F, 0x4A66A5B0, 0xC78B547A, 0x143F0FD8,
		0xE4127478, 0xC951A363, 0xC4EBF678, 0x1CAA33FF,
		0xD8009C37, 0x164EC492, 0x9A1B8023, 0x46A7EE41,
		0x27EF59D3, 0xBD0F05A9, 0x82E858ED, 0x3BECB61F,
		0x1C9B6422, 0xB627F520, 0x2A4F7507, 0x9734C231,
		0xF0689EE2, 0xA6D0BA32, 0x5CEF7641, 0x33CA2FC4,
		0xAB6773CE, 0xFD939249, 0xAC7514EF, 0xCC10010F,
		0x3776DD91, 0xDC6100CE, 0xFD684E10, 0xD535A7EA,
		0x52FBB62E, 0xAD0E0A05, 0xF435C921, 0x5AEC7828
#if(DEFAULT_PAGE_MAIN_SIZE == 16384)
	,	0x74D574FE, 0x83801FDD, 0xD1F95BD2, 0x993EC763,
		0xC5A1BF4F, 0x4AA892C6, 0x899B881B, 0xB3D5F2B0,
		0x523CA14D, 0xC354F198, 0x0DCA5B76, 0x6482C7CA,
		0xACFEC6DB, 0x0993B047, 0xC1C903A3, 0x81C43FB8,
		0x98A0C0ED, 0x2FC9C008, 0x0AF31245, 0xC95C3F84,
		0xBDD6D7F7, 0x47BFA71C, 0x7139B653, 0x50FECFFB,
		0x36B3FA60, 0x169716CC, 0x5F4C7FD2, 0x0C72EE0D,
		0x6B8AF20A, 0x3D9B0AE9, 0xBE303B26, 0xF3940BFC,
		0xE08114CD, 0x7B7DBD18, 0x4B3B09AF, 0x1ACED6D3,
		0xA89BE6D0, 0xBBC23CB6, 0x8BE7DFB6, 0xB4E12764,
		0x86DF788C, 0x89697457, 0xEADF6649, 0x92C27953,
		0xD16C4CDB, 0xF7B07247, 0x8034F366, 0x6506B98B,
		0xB4ECBB83, 0xFFE25903, 0xD27CE0B4, 0x43E64C2D,
		0xD472723A, 0x7DC43698, 0xA7808ACA, 0xF897D567,
		0xD47B522F, 0x5D8E1164, 0xF995E5F5, 0x70D7BFB0,
		0x0655B2F1, 0x1EBC13F0, 0x918D49B1, 0x1CD31D87,
		0x4489B986, 0x200FC2BE, 0xD5860216, 0xD915498D,
		0x39A50A9D, 0x2CFFDE92, 0x5BC566A8, 0x4C24F269,
		0x5270641A, 0x688DBB4D, 0x028A1713, 0x0749475E,
		0x111DFA03, 0x797C783F, 0x89F1FFB9, 0xFD6CF2E2,
		0x8C42A199, 0x57FB4DF2, 0x8C774AB6, 0x60AB2296,
		0xB57600FF, 0x4CFD2037, 0x97279BEB, 0x2258BB01,
		0x4EEFBCCA, 0x87DD481E, 0x2DC599C8, 0xB104C5DC,
		0x75EB8F56, 0x3036BADA, 0xED36DD31, 0xDA015910,
		0xD4843284, 0x7DB9A412, 0x627EA908, 0xCBD62897,
		0xBA9F90A9, 0x56A25D1F, 0x0845CE6C, 0xD90F3042,
		0xCBDF0882, 0x9AD5B755, 0x08B73220, 0x8005A4BB,
		0x0B21D09C, 0x88ED0A16, 0xF2CD1B11, 0x64B39017,
		0xC2D9AFCC, 0x359201D2, 0xCCE641B1, 0x370B4F1B,
		0x199F230C, 0xCE29B3E0, 0xBBD1656C, 0x59D7FA55,
		0x5CDE219C, 0x5DED46D3, 0x9766C25B, 0xF0BCD05B,
		0x1ABA644C, 0x4D2FE2EE, 0xD696AE79, 0x6D4377E7,
		0x6DE38BC1, 0x343D5181, 0x48A957E1, 0x4B517E0D,
		0x5477D681, 0x76E5E604, 0x2F6D80DC, 0x0A5ACE76,
		0xB0C8C238, 0x9F57BEA8, 0xCC07E427, 0xBC31FE01,
		0x315EFDEA, 0x072330FC, 0x5FA4FA51, 0xA70278EB,
		0x1D5E43D3, 0x7CD1E322, 0x886B44C5, 0x4E738BD6,
		0xC919DAC6, 0x3645BADE, 0x16EA8446, 0x9AB25C10,
		0x3F3313FD, 0x056E308C, 0x36B74692, 0x4FE010BF,
		0x5A4C840E, 0x2D0BAEBE, 0xFF1419BD, 0xD201723E,
		0x86186FEF, 0xE7338FCA, 0x1320F41E, 0xACACC6B1,
		0x0947FEFE, 0x7DA3DDDD, 0x9004AB17, 0x7DFC4150,
		0xE9EDC421, 0x9A830BCD, 0x51147AEA, 0x396F8119,
		0x3B980480, 0xF92F601C, 0xDB7367EF, 0xCCEBDD56,
		0x4E366E94, 0x428AB7EF, 0x67109984, 0xFD616E05,
		0xF57F8016, 0x0CEED911, 0x254E60D2, 0x261B29FF,
		0x19DE7ABC, 0x1CCDD8BA, 0xEF84BDEA, 0x932550A5,
		0xA78D162D, 0x81AAF4E8, 0x8F6EC6CC, 0xF4B73B00,
		0xBF25EE9C, 0xDC7FC5F3, 0x56654A7C, 0x661F35F1,
		0x20F0A215, 0xF5B1B760, 0x42FE0570, 0x82A49DBA,
		0x9035FCCA, 0x13DB2847, 0xD5EC75B4, 0x97AC49DF,
		0xE7DB0A49, 0xB85062F8, 0xDA787768, 0x480D1735,
		0x4BF8A23E, 0x2DE32B3D, 0x54648F5B, 0xA4D5C3E7,
		0xC7528624, 0xD168F029, 0xAEC77434, 0x853408BA,
		0x447FF938, 0x20725034, 0x107821D4, 0xEA54B47D,
		0x5741C81B, 0x27D392E9, 0xAA154D31, 0xE5FC7D9B,
		0x9FFADE69, 0xECE41FE8, 0x9BB06C82, 0x9B9FFE62,
		0x5EB59319, 0xD19EB097, 0xAEBAE6BE, 0x40CA2B78,
		0x773E04C8, 0x4E9692B2, 0x1B546DAF, 0x1B849FE4,
		0xFE9947E9, 0xEA59289A, 0x2E7CE994, 0x7CC6060A,
		0x032C6755, 0xA34C76F2, 0x3352A42A, 0xBCD4E765,
		0xE3134A83, 0x2AE215C6, 0xB7D739FE, 0xD7E90C61,
		0x0C11B9BA, 0x0579D5A4, 0xBDF06502, 0xA2DFED9B,
		0xA007FAE2, 0xA79AF305, 0x0AEDD778, 0x62513BE8,
		0x0EFC45EC, 0x35B4B327, 0x29860B36, 0xE63503AA,
		0xEEFB1FF2, 0xF2779EF8, 0xCF174848, 0x0867C06B,
		0x65187CB6, 0x1FE1BFEF, 0x4CC8CB18, 0xA077F48F,
		0x1B59F148, 0x62B9BE6B, 0xA58CD30A, 0x436002FE,
		0x68CCE2FD, 0xD06E7C49, 0x531C9FD8, 0xDBEF50F3
#endif
	},
	{	0xA86183C5, 0x307F3A33, 0xAD252417, 0x6868E229,
		0xD0C7E03A, 0x2A882264, 0xB96E79AC, 0x49970CB5,
		0xD8BE0590, 0xC484C464, 0xB999C01E, 0xBB176BBF,
		0xE5696AD2, 0xF1746B4D, 0xE93153C1, 0xF41E07CF,
		0xA6A8CDFA, 0x528238AA, 0x11DEF16E, 0x2E081B4B,
		0x99324234, 0x2E78F5DA, 0x05E8DEE3, 0xEA50488F,
		0x0E368E68, 0x22936975, 0x8B2C4D82, 0x3162D62C,
		0x3060E6BE, 0x94CC4B61, 0x8F17A8F4, 0x287E1EB1,
		0xC924E8F0, 0x93A247C6, 0x89D7EDF0, 0x385566FF,
		0xB100396E, 0x2C9C8925, 0x35360146, 0x8C4FDD82,
		0x4EDFB2A7, 0x7B1E0A53, 0x05D1B0DB, 0x76D96D3E,
		0x3837C844, 0x6D4EEB40, 0x549EEA0E, 0x2F688562,
		0xE1D03DC5, 0x4DA17564, 0xB8DFEC82, 0x66955E89,
		0x57CEE69D, 0xFB272592, 0x59EA28DF, 0x9920021E,
		0x6EECBB23, 0xB9C2009D, 0xFBD09C20, 0xAB6A4FD5,
		0xA4F76D5C, 0x5B1C140A, 0xE96A9342, 0xB4D9F050,
		0xE8ABE8FD, 0x07013EBB, 0xA3F3B6A5, 0x337C8FC6,
		0x8B437F9E, 0x9451258D, 0x13371136, 0x67ABE561,
		0xA478439A, 0x87A8E331, 0x1A95B6EC, 0xC8058F95,
		0x59FD8DB7, 0x1227618E, 0x83930647, 0x03897E71,
		0x314181DB, 0x5E938110, 0x14E7248A, 0x93B87E09,
		0x7BADAFEF, 0x8E7F4F38, 0xE2726DA6, 0xA0FD9FF7,
		0x6C67F5C0, 0x2C2F2C99, 0xBE98FEA5, 0x18E4DD1A,
		0xD615E514, 0x7A3714D3, 0x7D60764C, 0xE72916F9,
		0xC103289B, 0xF6FA7B30, 0x9676125F, 0x349DADA7,
		0x5137CDA1, 0x7785786D, 0x17CFBF6D, 0x69C34EC8,
		0x0DBFF019, 0x13D2E8AE, 0xD5BFCC92, 0x2585F2A6,
		0xA3D898B7, 0xEF61E48E, 0x0168E7CC, 0xCA0C7317,
		0x69D97707, 0xFFC5B206, 0xA5F8C169, 0x86CD985A,
		0xA9E4E474, 0xFA896C31, 0x4F011595, 0xF12FABCE,
		0xA9F6A45E, 0xBA1D22C8, 0xF32BCBEB, 0xE0AF7F61,
		0x0CAA65E3, 0x3C7926E1, 0x231B9263, 0x38A73A0F,
		0x8813730D, 0x401E857D, 0xAB0D042C, 0xB32A921B,
		0x724B143B, 0x58FFBD25, 0xB68BCC51, 0x9848E5D2,
		0xA4E0C834, 0xD01B779A, 0x04152E26, 0x0E928EBC,
		0x223AF506, 0xF2F8F07E, 0x13E3FF73, 0xFBD8E5C5,
		0x19844333, 0xAEF79AE5, 0x19EE946D, 0xC057442D,
		0x6BEC00FF, 0x98FB406E, 0x2F4E37D7, 0x44B07702,
		0x9CDF7995, 0x0FBB903C, 0x5A8B3391, 0x63088BB9,
		0xEAD71FAC, 0x606C75B5, 0xDB6CBB62, 0xB502B220,
		0xA9096409, 0xFA734924, 0xC4FC5310, 0x97AD502F,
		0x753F2153, 0xAC45BA3E, 0x108A9DD8, 0xB31E6084,
		0x97BF1005, 0x35AB6FAA, 0x106F6440, 0x010A4977,
		0x1642A139, 0x11DB142C, 0xE59B3622, 0xC867212E,
		0x85B35F99, 0x6A2502A5, 0x99CD8263, 0x6E169E36,
		0x323F4618, 0x9D5267C1, 0x77A3CAD8, 0xB2AFF5AA,
		0xB8BD4239, 0xBADB8CA7, 0x2FCC85B6, 0xE179A1B6,
		0x3475C898, 0x9A5EC5DD, 0xAD2D5DF2, 0xDA86EECF,
		0xDAC71783, 0x687AA203, 0x9053AEC3, 0x96A2FC1A,
		0xA8EEAD03, 0xECCBCD08, 0x5EDA01B9, 0x14B49DEC,
		0x61918570, 0x3FAE7D51, 0x990EC94E, 0x7962FD02,
		0x62BCFBD5, 0x0E4660F9, 0xBE49F5A2, 0x4F04F0D7,
		0x3ABC86A7, 0xF8A3C744, 0x11D6888B, 0x9CE617AD,
		0x9332B58D, 0x6C8A75BD, 0x2CD5098C, 0x3565B820,
		0x7E6626FB, 0x0ADC6019, 0x6C6F8C25, 0x9EC1207F,
		0xB498091C, 0x5A165D7D, 0xFF28327B, 0xA502E47C,
		0x0D30DEDF, 0xCF661F95, 0x2640E93C, 0x59598D63,
		0x128EFDFD, 0xFA47BBBB, 0x2108572E, 0xFAF982A0,
		0xD3DB8942, 0x3507169B, 0xA228F4D5, 0x72DE0332,
		0x76310801, 0xF35EC038, 0xB7E6CEDF, 0x99D7BBAC,
		0x9C6CDC29, 0x84156FDF, 0xCE203309, 0xFBC2DC0A,
		0xEBFE012C, 0x18DDB322, 0x4A9CC0A5, 0x4C3652FF,
		0x32BDF479, 0x389BB175, 0xDF097BD5, 0x274AA04B,
		0x4F1B2C5A, 0x0355E9D1, 0x1FDC8D99, 0xE96F7600,
		0x7F4ADD39, 0xB9FE8BE7, 0xACCA94F8, 0xCC3E6AE3,
		0x40E1452A, 0xEB636FC0, 0x84FD0AE0, 0x05493B75,
		0x216AF995, 0x26B7508E, 0xABD9EA69, 0x2F5992BF,
		0xCFB71492, 0x71A0C4F1, 0xB5F0EED0, 0x901A2E6A,
		0x96F1457C, 0x5AC7567A, 0xA8C81FB6, 0x49AB87CF,
		0x8FA40D48, 0xA3D0E152, 0x5D8FE868, 0x0B681075,
		0x88FEF370, 0x40E4A068, 0x20F042A9, 0xD5A869FA,
		0xAE829136, 0x4EA725D3, 0x552A9A62, 0xCBF9FA37,
		0x3FF5BDD2, 0xD9C93ED1, 0x3761D805, 0x373FFDC4,
		0xBC6B2732, 0xA33D612F, 0x5D75CD7D, 0x809556F0,
		0xEE7C0891, 0x9C2D2565, 0x36A8DA5F, 0x36093FC9,
		0xFD338ED3, 0xD5B25035, 0x5CF8D329, 0xF88D0C14,
		0x0658CEAA, 0x4798ECE5, 0x66A44954, 0x79A9CFCA,
		0xC7269407, 0x54C52A8D, 0x6FAF72FD, 0xAFD318C2,
		0x18227375, 0x0AF2AB49, 0x7BE1CA04, 0x45BFDB37,
		0x410EF5C5, 0x4F35E70A, 0x14DBAFF0, 0xC4A276D1,
		0x1CF98AD9, 0x6A69674E, 0x520D166C, 0xCD6A0655,
		0xDDF73EE5, 0xE5EE3DF1, 0x9F2E9090, 0x10CE81D6,
		0xCA30F86D, 0x3EC37FDF, 0x98919730, 0x41EEE91F,
		0x36B2E390, 0xC4737DD6, 0x4B19A714, 0x86C004FD,
		0xD099C5FB, 0xA1DCF892, 0xA6383FB1, 0xB7DFA0E7
#if(DEFAULT_PAGE_MAIN_SIZE == 16384)
	,	0x055E9E1D, 0xAA6D9A05, 0xCBC8EDEA, 0x11929485,
		0xE5C88F44, 0x3A4EDA57, 0xC1B08D27, 0x7D5484D3,
		0x02DD12C7, 0xAC57FA14, 0x501ED321, 0x0F34BEFA,
		0x863FC4AA, 0x90F7AE17, 0x960B6069, 0xD13A10FF,
		0xCE4AE457, 0x956202C2, 0x99FC95BE, 0x4071B761,
		0x0E3EF78D, 0x907D6593, 0x812CBA3B, 0x7390564B,
		0x195D31D1, 0x4BF9BBCE, 0xFF470067, 0x003117DD,
		0x2E672957, 0x3C01B195, 0x0D2F0252, 0xF68F70E3,
		0xC13FA3E1, 0xA1E073E8, 0xF1223769, 0xD08B85D1,
		0xE148B66B, 0x1A12E1CF, 0xA65F7448, 0xA0025FA0,
		0x2C099E2C, 0x1BF8B462, 0xC99AD1EB, 0x617199AA,
		0x462979CB, 0x49A61B68, 0xF6D92CC7, 0xF88575F1,
		0xB4B6C24C, 0x4D981B5C, 0x2456C933, 0x509418A5,
		0x181364A8, 0x2495821E, 0x47E07B91, 0x4890D965,
		0xB7818526, 0x8E0A44EB, 0xB53BDC18, 0x358041B8,
		0xCC720F08, 0x8B21D125, 0x481FF7A3, 0x6B35721D,
		0x7DF56145, 0xC9E7A3DD, 0x84D624F2, 0xD954503D,
		0xAB4161C7, 0x78EA0614, 0xD1378C58, 0xB737C5D8,
		0xCE379661, 0x70C5BF9A, 0x0681BC48, 0xA296CDCE,
		0x800DDD5E, 0xB9CF9C3A, 0x82ADBDAF, 0xF03FDB76,
		0x4DCE4778, 0x1DEC1F23, 0x45C2A901, 0xA4A9489D,
		0xD048CEFC, 0xF63CD55F, 0x4A915C02, 0x354B7370,
		0x69E860DA, 0xD1A29B51, 0x99F970FC, 0x8BE29A08,
		0x5F6B9497, 0x3BB6CFD0, 0xEEE1667D, 0x000D9CA7,
		0x797D218F, 0x5B5594A3, 0xE9392A24, 0x46F00B29,
		0xACA83A43, 0x1070B8CD, 0x38E32601, 0xF13DEBE4,
		0xE962EAA7, 0x0637FCB6, 0xE2AB1F44, 0x45F3BEDC,
		0x8ACE61CA, 0xEC497F69, 0xFB13D70D, 0xBC1E2CE1,
		0xF474D091, 0xC8081332, 0x2080AC38, 0x4972F52D,
		0x6AAA2C63, 0x45797558, 0x9DE9BB98, 0x4EE339DD,
		0x2C04028B, 0x628595ED, 0x92CF4548, 0x8848B38E,
		0x00D972E2, 0xE50E212B, 0xE6A9940A, 0xC06653F0,
		0x458B29A8, 0xA4FAF1FB, 0x22613585, 0xB23F07E1,
		0x5DE0DA74, 0xAE5BE3D4, 0xABA904F8, 0xB3830E68,
		0x0B9FA9C7, 0x7A7E947A, 0x7D33CF2A, 0x1500ED80,
		0x8500FA25, 0xE18BFD46, 0x0D6682FB, 0xF6DCC985,
		0x33165898, 0xE5E3A156, 0xE653B11F, 0x4B9B1575,
		0x2309D249, 0x783374F6, 0x3439AD73, 0x519E51D2,
		0x0E51C591, 0x354E9632, 0xA27B4DB3, 0x80F7F84B,
		0x3232DABF, 0xE42F464E, 0x2CF65E7B, 0x5B96DF8E,
		0xFE4D4910, 0x1673B6E4, 0x3FBC3D7B, 0xD99A87B7,
		0xC548237C, 0x733C2F7A, 0xAB1AA144, 0x382DF18B,
		0x9F34A95F, 0xE2B4C3C9, 0x7C1AD1AA, 0x6DB12B17,
		0x14F081E2, 0x18BF1D99, 0x96D2128B, 0x343431D4,
		0x28E3705D, 0x55045132, 0xDC77BC16, 0xE48B469A,
		0x2C5FC208, 0x22426272, 0xDCCC604F, 0xDDCBB59F,
		0xB2F43529, 0xF87AB5A6, 0xF4D8A9A0, 0x7A4F83A7,
		0x5354E67D, 0x29015C15, 0x882FF877, 0x17048DA5,
		0xCC59211A, 0x573CBA6D, 0xC2346FF1, 0x35682487,
		0x071B0774, 0x5189F4BA, 0x8556A601, 0xD8312B56,
		0x1830335F, 0x4A66E5B0, 0xC7CB147A, 0x543F0F98,
		0xE4523478, 0xC951E323, 0xC4EBF678, 0x1CAA33BF,
		0x98409C37, 0x160EC4D2, 0xDA1B8023, 0x46E7AE41,
		0x27AF59D3, 0xFD0F05A9, 0x82A858ED, 0x3BACF61F,
		0x1C9B2462, 0xB627B560, 0x2A0F7547, 0xD7348271,
		0xB068DEA2, 0xE690FA32, 0x5CEF7641, 0x738A6F84,
		0xEB2773CE, 0xFDD39209, 0xAC3554AF, 0x8C50010F,
		0x7736DDD1, 0x9C61408E, 0xFD684E50, 0x9575A7AA,
		0x12FBF62E, 0xAD0E0A05, 0xB4758961, 0x5AEC7868,
		0x74D574FE, 0xC3801F9D, 0xD1F95BD2, 0xD93E8763,
		0xC5E1BF0F, 0x0AE89286, 0x899B881B, 0xF395F2F0,
		0x127CA10D, 0xC354F1D8, 0x4D8A5B76, 0x64C287CA,
		0xECBEC6DB, 0x0993B007, 0x81C943A3, 0xC1847FB8,
		0x98A080ED, 0x6F89C048, 0x0AB35205, 0xC95C7F84,
		0xBD96D7F7, 0x47FFA71C, 0x7179B613, 0x50FECFFB,
		0x76B3BA60, 0x5697168C, 0x1F4C7FD2, 0x0C32EE4D,
		0x6BCAB24A, 0x3D9B0AA9, 0xFE303B26, 0xF3D40BBC,
		0xA0C1148D, 0x3B7DFD18, 0x4B7B09AF, 0x5A8ED6D3,
		0xA89BA6D0, 0xBB827CB6, 0xCBA7DFF6, 0xB4A16724
#endif
	}
};

void  rdmzier(uint8_t *buf, int size, int page)
{
    int i, j;
    unsigned int *bi = (unsigned int *)buf;
    j = page%256;

    for (i = 0; i < size; i++) {
        bi[i]   = rdmz[j] ^ bi[i];
        j++;
        if (j >= BYTE_SEED)
            j = 0;
    }

#if 0
	int i, j;
	unsigned int *bi = (unsigned int *)buf, tmp;
	j = page%256;
	i = j + 1;

	for (i = 0; i < size; i++) {
			//tmp = bi[i];
		bi[i]	= rdmz[i] /*0xFFFFFFFF*/ ^ bi[i];
		/*if (tmp != (bi[i]^0xFFFFFFFF))
			printk("tmp=0x%x, bi[%d]=0x%x\n", tmp, i, bi[i]);*/
		//bi[i]	= /*rdmz[i]*/ 0xFFFFFFFF ^ bi[i];
	}
#endif
}

void rdmzier_oob(uint8_t *buf, uint8_t *src, int size, int page, int ofs)
{
	int i, j;
	unsigned int *bi = (unsigned int *)buf;
	unsigned int *bs = (unsigned int *)src;
	j = page%256;
	j = (j+ofs)%BYTE_SEED;

	for (i = 0; i < size; i++) {
		bi[i]	= rdmz[j] ^ bs[i];
		j++;
		if (j >= BYTE_SEED)
			j = 0;
	}
}

int init_randomizer(int pgsize, int spsize, int pg_per_bk)
{
	if (pgsize >= 0)
		rndmz.pgsize = pgsize;
	if (spsize >= 0)
		rndmz.spsize = spsize;
	if (pg_per_bk >= 0)
		rndmz.pg_per_bk = pg_per_bk;
	
	//printk("pssize = %d, spsize = %d, pg_per_bk = %d\n", pgsize, spsize, pg_per_bk);
	if (((rndmz.pgsize <= 0) || (rndmz.pgsize > MAX_PAGE_MAIN_SIZE)) ||
		((rndmz.spsize <= 0) || (rndmz.spsize > MAX_PAGE_SPARE_SIZE)) ||
		((rndmz.pg_per_bk <= 0) || (rndmz.pg_per_bk > MAX_PAGES_PER_BLOCK)))
		{
			return -1;
		}

	/* Page + Spare size should be multiple of ECC frame count */
	if ((rndmz.pgsize + rndmz.spsize) % ECC_FRAMES)
	{
		return -1;
	}

	/* Page count per block should be power of 2 */
	if(rndmz.pg_per_bk & (rndmz.pg_per_bk - 1))
	{
		return -1;
	}
	
	rndmz.fr_size = (rndmz.pgsize + rndmz.spsize) / ECC_FRAMES;
	
	init_done = 1;
	return 0;
}

static void randomize_copy(unsigned int start, unsigned int offset, 
							unsigned int size, const unsigned int *src,
							unsigned int *dst)
{
	int i, j;
	unsigned int fr_size = rndmz.fr_size;
	
	/* Randomize Data */
	for (i=0; i<ECC_FRAMES; i++)
	{
		const unsigned int *ptbl;
		int rndmz_size, loop64, loop4, loop1;
#ifdef CARE_MEMORY_ALIGNMENT
		int buf_misalign, tbl_misalign;
#endif
		if (offset >= fr_size) {
			offset -= fr_size;
			continue;
		}
		rndmz_size = ((fr_size - offset) < size) ? (fr_size - offset) : size;

#ifdef CARE_MEMORY_ALIGNMENT
		/* set destination buffer alignment */
		buf_misalign = (4 - (((unsigned int)dst) & 0x3)) & 0x3;
		if (buf_misalign)
		{
			unsigned char *src_b = (unsigned char *)src;
			unsigned char *dst_b = (unsigned char *)dst;
			const unsigned char *ptbl_b = (((const unsigned char *)
									&rand_table[i][0]) + start  + offset);
			
			for (j=0; j<buf_misalign; j++)
				*dst_b++ = *src_b++ ^ *ptbl_b++;

			src = (unsigned int *)src_b;
	        dst = (unsigned int *)dst_b;
			rndmz_size -= buf_misalign;
		}

		tbl_misalign = (start  + offset + buf_misalign) & 0x3;
		ptbl = &rand_table[i][(start  + offset + buf_misalign) >> 2];
#else
		ptbl  = (const unsigned int *)
			(((const unsigned char *)&rand_table[i][0]) + start  + offset);
#endif
		loop64 = rndmz_size >> 6;
		loop4 = (rndmz_size >> 2) & 0xF;
		loop1 = rndmz_size & 0x3;

#ifdef CARE_MEMORY_ALIGNMENT
		if (tbl_misalign) {
			const unsigned int *ptbl_next = ptbl + 1;
			unsigned int shift_a = tbl_misalign << 3;
			unsigned int shift_b = 32 - shift_a;

			RANDOMIZE_LOOP1(dst, (*src++ ^ ((*ptbl++ >> shift_a) | (*ptbl_next++ << shift_b))), loop64);
			for (j=0; j<loop4; j++)
				*dst++ = *src++ ^ ((*ptbl++ >> shift_a) | (*ptbl_next++ << shift_b));
		} else {
#endif
			RANDOMIZE_LOOP1(dst, (*src++ ^ *ptbl++), loop64);
			for (j=0; j<loop4; j++)
				*dst++ = *src++ ^ *ptbl++;
#ifdef CARE_MEMORY_ALIGNMENT
		}
#endif
		if (loop1) {
			unsigned char *src_b = (unsigned char *)src;
			unsigned char *dst_b = (unsigned char *)dst;
			const unsigned char *ptbl_b = (const unsigned char *)ptbl;
#ifdef CARE_MEMORY_ALIGNMENT
			ptbl_b += tbl_misalign;
#endif
			for (j=0; j<loop1; j++)
				*dst_b++ = *src_b++ ^ *ptbl_b++;

			src = (unsigned int *)src_b;
		    dst = (unsigned int *)dst_b;
		}

		offset = 0;
		size -= rndmz_size;
	}
}

//start --page_addr
//offset col_addr
//
static void randomize_overwrite(unsigned int start, unsigned int offset, 
							unsigned int size, unsigned int *buf)
{
	int i, j;
	unsigned int fr_size = rndmz.fr_size;
	
	/* Randomize Data */
	for (i=0; i<ECC_FRAMES; i++)
	{
		const unsigned int *ptbl;
		int rndmz_size;
		int loop64, loop4, loop1;
#ifdef CARE_MEMORY_ALIGNMENT
		int buf_misalign, tbl_misalign;
#endif
		if (offset >= fr_size) {
			offset -= fr_size;
			continue;
		}
		rndmz_size = ((fr_size - offset) < size) ? (fr_size - offset) : size;

#ifdef CARE_MEMORY_ALIGNMENT
		/* set destination buffer alignment */
		buf_misalign = (4 - (((unsigned int)buf) & 0x3)) & 0x3;
		if (buf_misalign)
		{
			unsigned char *buf_b = (unsigned char *)buf;
			const unsigned char *ptbl_b = (((const unsigned char *)
									&rand_table[i][0]) + start  + offset);
			
			for (j=0; j<buf_misalign; j++)
				*buf_b++ ^= *ptbl_b++;

			buf = (unsigned int *)buf_b;
			rndmz_size -= buf_misalign;
		}

		tbl_misalign = (start  + offset + buf_misalign) & 0x3;
		ptbl = &rand_table[i][(start  + offset + buf_misalign) >> 2];
#else
		ptbl  = (const unsigned int *)
			(((const unsigned char *)&rand_table[i][0]) + start  + offset);
#endif		
		loop64 = rndmz_size >> 6;
		loop4 = (rndmz_size >> 2) & 0xF;
		loop1 = rndmz_size & 0x3;

#ifdef CARE_MEMORY_ALIGNMENT
		if (tbl_misalign) {
			const unsigned int *ptbl_next = ptbl + 1;
			unsigned int shift_a = tbl_misalign << 3;
			unsigned int shift_b = 32 - shift_a;

			RANDOMIZE_LOOP2(buf, ((*ptbl++ >> shift_a) | (*ptbl_next++ << shift_b)), loop64);
			for (j=0; j<loop4; j++)
				*buf++ ^= ((*ptbl++ >> shift_a) | (*ptbl_next++ << shift_b));
		} else {
#endif
			RANDOMIZE_LOOP2(buf, (*ptbl++), loop64);
			for (j=0; j<loop4; j++)
				*buf++ ^= *ptbl++;
#ifdef CARE_MEMORY_ALIGNMENT
		}
#endif

		if (loop1) {
			unsigned char *buf_b = (unsigned char *)buf;
			const unsigned char *ptbl_b = (const unsigned char *)ptbl;
#ifdef CARE_MEMORY_ALIGNMENT
			ptbl_b += tbl_misalign;
#endif
			for (j=0; j<loop1; j++)
				*buf_b++ ^= *ptbl_b++;

			buf = (unsigned int *)buf_b;
		}

		offset = 0;
		size -= rndmz_size;
	}
}

int randomize_data(unsigned int page_addr, unsigned int col_addr,
				unsigned int size, const unsigned char *org, unsigned char *rnd)
{
	int is_spare = (col_addr >= rndmz.pgsize) ? 1 : 0;
	unsigned int start = page_addr & (rndmz.pg_per_bk - 1);

	if ((!init_done) || 
	//if ((!init_done) || (!org) || (!rnd) ||
		((col_addr + size) > (rndmz.pgsize + rndmz.spsize)))
	{
		return -1;
	}

#ifdef CARE_MEMORY_ALIGNMENT
	/* Move original data to randomized buffer if alignments are mismatched */
	if ((((unsigned int)org) & 0x3) != (((unsigned int)rnd) & 0x3))
	{
		memcpy(rnd, org, size);
		org = rnd;
	}
#endif

	if(org == rnd)
		randomize_overwrite(start, col_addr, size, (unsigned int*)org);
	else
		randomize_copy(start, col_addr, size, (unsigned int*)org, 
						(unsigned int*)rnd);

	return 0;
}
#define normalize_data(a,b,c,d) randomize_data(a,b,c,d,d)
#endif

#ifndef memzero
#define memzero(s, n)     memset ((s), 0, (n))
#endif
/*
* NAND_PAGE_SIZE = 2048 or 4096:
* support Harming ECC and BCH ECC
*
* NAND_PAGE_SIZE = 512:
* Only support Harming ECC according to the demand of filesystem
* so need open macro:
* #define NAND_HARMING_ECC
*
*/

/*#define NAND_DEBUG*/
unsigned int wmt_version;
#include <linux/mtd/partitions.h>
#define NUM_NAND_PARTITIONS ARRAY_SIZE(nand_partitions)
uint32_t par1_ofs, par2_ofs, par3_ofs, par4_ofs, eslc_write, prob_end, part_wr, whole_eslc;
struct mtd_partition nand_partitions[] = {
	{
		.name		= "logo",
		.offset		= MTDPART_OFS_APPEND,
		.size		= 0x1000000,
	},
	{
		.name		= "boot",
		.offset		= MTDPART_OFS_APPEND,
		.size		= 0x1000000,
	},
	{
		.name		= "recovery",
		.offset		= MTDPART_OFS_APPEND,
		.size		= 0x1000000,
	},
	{
		.name		= "misc",
		.offset		= MTDPART_OFS_APPEND,
		.size		= 0x1000000,
	},
	{
		.name		= "system",
		.offset		= MTDPART_OFS_APPEND,
		.size		= 0x20000000,
	},
	{
		.name		= "cache",
		.offset		= MTDPART_OFS_APPEND,
		.size		= 0x20000000,
	},
	{
		.name		= "data",
		.offset		= MTDPART_OFS_APPEND,
		.size		= 0x20000000,
	},
	{
		.name		= "LocalDisk",
		.offset		= MTDPART_OFS_APPEND,
		.size		= MTDPART_SIZ_FULL,
	},
};
EXPORT_SYMBOL(nand_partitions);


#ifdef CONFIG_MTD_NAND_WMT_HWECC

	static int MAX_CHIP = CONFIG_MTD_NAND_CHIP_NUM;
	static int hardware_ecc = 1;
#else
	#define MAX_CHIP 1
	static int hardware_ecc = 0;
#endif

static unsigned char parity[MAX_PARITY_SIZE];
static unsigned int bch_err_pos[MAX_ECC_BIT_ERROR];
static unsigned int bch_err_pos[MAX_ECC_BIT_ERROR];

unsigned char eslc_map_table[128] = {
				0x0, 0x1,
				0x2, 0x3,
				0x6, 0x7,
				0xa, 0xb,
				0xe, 0xf,
				0x12, 0x13,
				0x16, 0x17,
				0x1a, 0x1b,
				0x1e, 0x1f,
				0x22, 0x23,
				0x26, 0x27,
				0x2a, 0x2b,
				0x2e, 0x2f,
				0x32, 0x33,
				0x36, 0x37,
				0x3a, 0x3b,
				0x3e, 0x3f,
				0x42, 0x43,
				0x46, 0x47,
				0x4a, 0x4b,
				0x4e, 0x4f,
				0x52, 0x53,
				0x56, 0x57,
				0x5a, 0x5b,
				0x5e, 0x5f,
				0x62, 0x63,
				0x66, 0x67,
				0x6a, 0x6b,
				0x6e, 0x6f,
				0x72, 0x73,
				0x76, 0x77,
				0x7a, 0x7b,
				0x7e, 0x7f,
				0x82, 0x83,
				0x86, 0x87,
				0x8a, 0x8b,
				0x8e, 0x8f,
				0x92, 0x93,
				0x96, 0x97,
				0x9a, 0x9b,
				0x9e, 0x9f,
				0xa2, 0xa3,
				0xa6, 0xa7,
				0xaa, 0xab,
				0xae, 0xaf,
				0xb2, 0xb3,
				0xb6, 0xb7,
				0xba, 0xbb,
				0xbe, 0xbf,
				0xc2, 0xc3,
				0xc6, 0xc7,
				0xca, 0xcb,
				0xce, 0xcf,
				0xd2, 0xd3,
				0xd6, 0xd7,
				0xda, 0xdb,
				0xde, 0xdf,
				0xe2, 0xe3,
				0xe6, 0xe7,
				0xea, 0xeb,
				0xee, 0xef,
				0xf2, 0xf3,
				0xf6, 0xf7,
				0xfa, 0xfb
};

/*
 * hardware specific Out Of Band information
*/

/*
* new oob placement block for use with hardware ecc generation
*/

static struct nand_ecclayout wmt_oobinfo_2048 = {
/* nand flash new structure and BCH ECC oob info */
	.eccbytes = 7,
	.eccpos = { 24, 25, 26, 27, 28, 29, 30},
	.oobavail = 24,
	.oobfree = {{0, 24} }
};


static struct nand_ecclayout wmt_12bit_oobinfo_4096 = {
/* nand flash old structure and Harming ECC oob info */
	.eccbytes = 20,
	.eccpos = { 24, 25, 26, 27, 28, 29, 30,
							31, 32, 33, 34, 35, 36, 37,
							38, 39, 40, 41, 42, 43},
	.oobavail = 24,
	.oobfree = {{0, 24} }
};
/*
static struct nand_ecclayout wmt_8bit_oobinfo_4096 = {
// nand flash old structure and Harming ECC oob info
	.eccbytes = 13,
	.eccpos = { 24, 25, 26, 27, 28, 29, 30,
							31, 32, 33, 34, 35, 36},
	.oobavail = 24,
	.oobfree = {{0, 24} }
};*/
static struct nand_ecclayout wmt_oobinfo_8192 = {
/* nand flash new structure and Harming ECC oob info */
	.eccbytes = 42,
	.eccpos = { 24, 25, 26, 27, 28, 29, 30,
							31, 32, 33, 34, 35, 36, 37,
							38, 39, 40, 41, 42, 43, 44,
							45, 46, 47, 48, 49, 50, 51,
							52, 53, 54, 55, 56, 57, 58,
							59, 60, 61, 62, 63, 64, 65},
	.oobavail = 24,
	.oobfree = {{0, 24} }
};

static struct nand_ecclayout wmt_oobinfo_16k = {
/* nand flash new structure and Harming ECC oob info */
	.eccbytes = 70,
	.eccpos = { 24, 25, 26, 27, 28, 29, 30,
							31, 32, 33, 34, 35, 36, 37,
							38, 39, 40, 41, 42, 43, 44,
							45, 46, 47, 48, 49, 50, 51,
							52, 53, 54, 55, 56, 57, 58,
							59, 60, 61, 62, 63, 64, 65,
							66, 67, 68, 69, 70, 71, 72,
							73, 74, 75, 76, 77, 78, 79,
							80, 81, 82, 83, 84, 85, 86,
							87, 88, 89, 90, 91, 92, 93},
	.oobavail = 24,
	.oobfree = {{0, 24} }
};
unsigned char *buffer_ramdomizer = NULL;
static struct nand_ecclayout wmt_oobinfo_4096 = {
/* nand flash old structure and Harming ECC oob info */
	.eccbytes = 7,
	.eccpos = { 24, 25, 26, 27, 28, 29, 30},
	.oobavail = 24,
	.oobfree = {{0, 24} }
};


	static struct nand_ecclayout wmt_oobinfo_512 = {
   .eccbytes = 8,
   .eccpos = { 4, 5, 6, 8, 9, 10, 12, 13},
   .oobfree = {{0, 4},{7, 1},{11,1},{14,2}}
	};

/* Ick. The BBT code really ought to be able to work this bit out
	 for itself from the above, at least for the 2KiB case
*/
#if 1
	static uint8_t wmt_bbt_pattern_2048[] = { 'B', 'b', 't', '0' };
	static uint8_t wmt_mirror_pattern_2048[] = { '1', 't', 'b', 'B' };
#endif
/*static uint8_t wmt_bbt_pattern_2048[] = { 0xFF, 0xFF };*/
/*static uint8_t wmt_mirror_pattern_2048[] = { 0xFF, 0xFF };*/


/*static uint8_t wmt_bbt_pattern_512[] = { 0xBB };*/
/*static uint8_t wmt_mirror_pattern_512[] = { 0xBC };*/
static uint8_t wmt_rdmz[] = { 'z', 'm', 'd', 'r' };
static uint8_t retry_table[] = {'r','e','t','r','y','t','a','b','l','e'};

static struct nand_bbt_descr wmt_rdtry_descr = {
	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
	.offs =	0,
	.len = 10,
	.veroffs = 0,
	.maxblocks = 4,
	.pattern = retry_table,
};

static struct nand_bbt_descr wmt_bbt_main_descr_2048 = {
	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
	.offs =	4,
	.len = 4,
	.veroffs = 0,
	.maxblocks = 4,
	.pattern = wmt_bbt_pattern_2048,
};

static struct nand_bbt_descr wmt_bbt_mirror_descr_2048 = {
	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
	.offs =	4,
	.len = 4,
	.veroffs = 0,
	.maxblocks = 4,
	.pattern = wmt_mirror_pattern_2048,
};

static struct nand_bbt_descr wmt_bbt_main_descr_512 = {
	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
	.offs =	0,
	.len = 4,
	.veroffs = 14,
	.maxblocks = 4,
	.pattern = wmt_bbt_pattern_2048,
};

static struct nand_bbt_descr wmt_bbt_mirror_descr_512 = {
	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
	.offs =	0,
	.len = 4,
	.veroffs = 14,
	.maxblocks = 4,
	.pattern = wmt_mirror_pattern_2048,
};


/* controller and mtd information */

static void print_nand_register(struct mtd_info *mtd);
void print_nand_buffer(char *value, unsigned int length);
#ifdef NAND_DEBUG
static void print_nand_buffer_int(unsigned int *value, unsigned int length);
#endif

struct wmt_nand_set {
	int	nr_chips;
	int	nr_partitions;
	char *name;
	int *nr_map;
	struct mtd_partition *partitions;
};

#if 0
	struct wmt_platform_nand {
		/* timing information for controller, all times in nanoseconds */

		int	tacls;	/* time for active CLE/ALE to nWE/nOE */
		int	twrph0;	/* active time for nWE/nOE */
		int	twrph1;	/* time for release CLE/ALE from nWE/nOE inactive */

		int nr_sets;
		struct wmt_nand_set *sets;
		void (*select_chip)(struct s3c2410_nand_set *, int chip);
	}
#endif

struct wmt_nand_info;

struct wmt_nand_mtd {
	struct mtd_info	mtd;
	struct nand_chip chip;
	/*struct wmt_nand_set* set;*/
	struct wmt_nand_info *info;
	int	scan_res;
};

/* overview of the wmt nand state */

struct wmt_nand_info {
	/* mtd info */
	struct nand_hw_control controller;
	struct wmt_nand_mtd *mtds;
	struct wmt_platform_nand *platform;

	/* device info */
	struct device *device;
	struct resource *area;
	void __iomem *reg;
	int cpu_type;
	int datalen;
	int nr_data;
	int data_pos;
	int page_addr;
	dma_addr_t dmaaddr;
	dma_addr_t last_bank_dmaaddr;
	int dma_finish;
	int phase;
	void *done_data;	/* completion	data */
	unsigned int isr_cmd;
	unsigned int cur_page;
	unsigned int last_bank_col;
	unsigned int oob_col;
	//void (*done)(void *data);/*	completion function	*/
	unsigned char *dmabuf;
	int ECC_bytes;
	int ECC_mode;
	int oob_ECC_bytes;
	int oob_ECC_mode;
	int oob_ecc_error;
	int data_ecc_uncor_err; /*  use read retry for data area has uncorrectable error*/
};

/* conversion functions */

static struct wmt_nand_mtd *wmt_nand_mtd_toours(struct mtd_info *mtd)
{
	return container_of(mtd, struct wmt_nand_mtd, mtd);
}

static struct wmt_nand_info *wmt_nand_mtd_toinfo(struct mtd_info *mtd)
{
	return wmt_nand_mtd_toours(mtd)->info;
}

/*
static struct wmt_nand_info *to_nand_info(struct platform_device *dev)
{
	return platform_get_drvdata(dev);
}
*/
/*
static struct platform_device *to_platform(struct device *dev)
{
	return container_of(dev, struct platform_device, dev);
}
*/
#if 0
static struct wmt_platform_nand *to_nand_plat(struct platform_device *dev)
{
	return dev->dev.platform_data;
}
#endif

/*
 * type : HW or SW ECc
 *
*/
static void nfc_ecc_set(struct wmt_nand_info *info, int type)
{
/* struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);*/

	if (type == hardware_ecc)
		writeb(readb(info->reg + WMT_NFC_MISC_CTRL) & 0xfb, info->reg + WMT_NFC_MISC_CTRL);
	else
		writeb(readb(info->reg + WMT_NFC_MISC_CTRL) | 0x04, info->reg + WMT_NFC_MISC_CTRL);
}

void copy_filename (char *dst, char *src, int size)
{
	if (*src && (*src == '"')) {
		++src;
		--size;
	}

	while ((--size > 0) && *src && (*src != '"')) {
		*dst++ = *src++;
	}
	*dst = '\0';
}

int shift_bit(uint64_t value)
{
	int i = 0;
	while (!(value & 1)) {
		value >>= 1;
		i++;
		if (i == 63)
			break;
	}
	/* return the number count of "zero" bit */
	return i;
}
EXPORT_SYMBOL(shift_bit);

int set_ECC_mode(struct mtd_info *mtd)
{
	unsigned int ECCbit = mtd->dwECCBitNum;
	unsigned int ECC_mode;
	switch (ECCbit) {
		case 1:
			ECC_mode = ECC1bit;
			break;
		case 4:
			ECC_mode = ECC4bit;
			break;
		case 8:
			ECC_mode = ECC8bit;
			break;
		case 12:
			ECC_mode = ECC12bit;
			break;
		case 16:
			ECC_mode = ECC16bit;
			break;
		case 24:
			ECC_mode = ECC24bitPer1K;
			break;
		case 40:
			ECC_mode = ECC24bitPer1K;
			break;
		default:
			printk("ecc mode input not support ECCbit=%d\n", ECCbit);
			return -1;
	}
	//set_ecc_engine(info, ECC_mode);  /* BCH ECC new structure */
	return ECC_mode;
}
void calculate_ECC_info(struct mtd_info *mtd, struct ECC_size_info *ECC_size)
{
	switch (ECC_size->ecc_engine)	{
		case ECC1bit:
		ECC_size->oob_ecc_bits_count = ECC_size->ecc_bits_count = ECC4bit_bit_count;
		ECC_size->oob_max_bit_error = ECC_size->max_bit_error = 4;
		ECC_size->banks = mtd->writesize/512;
		ECC_size->bank_size = 512;
		ECC_size->bank_offset = mtd->writesize/ECC_size->banks + ECC4bit_byte_count;
		ECC_size->oob_ECC_bytes = ECC_size->ECC_bytes = ECC4bit_byte_count;
		ECC_size->oob_ECC_mode = ECC1bit;
		ECC_size->unprotect = ECC4bit_unprotect;
		break;
		case ECC4bit:
		ECC_size->oob_ecc_bits_count = ECC_size->ecc_bits_count = ECC8bit_bit_count;
		ECC_size->oob_max_bit_error = ECC_size->max_bit_error = 8;
		ECC_size->banks = mtd->writesize/512;
		ECC_size->bank_size = 512;
		ECC_size->bank_offset = mtd->writesize/ECC_size->banks + ECC8bit_byte_count;
		ECC_size->oob_ECC_bytes = ECC_size->ECC_bytes = ECC8bit_byte_count;
		ECC_size->oob_ECC_mode = ECC4bit;
		ECC_size->unprotect = ECC8bit_unprotect;
		break;
		case ECC8bit:
		ECC_size->oob_ecc_bits_count = ECC_size->ecc_bits_count = ECC12bit_bit_count;
		ECC_size->oob_max_bit_error = ECC_size->max_bit_error = 12;
		ECC_size->banks = mtd->writesize/512;
		ECC_size->bank_size = 512;
		ECC_size->bank_offset = mtd->writesize/ECC_size->banks + ECC12bit_byte_count;
		ECC_size->oob_ECC_bytes = ECC_size->ECC_bytes = ECC12bit_byte_count;
		ECC_size->oob_ECC_mode = ECC8bit;
		ECC_size->unprotect = ECC12bit_unprotect;
		break;
		case ECC12bit:
		ECC_size->oob_ecc_bits_count = ECC_size->ecc_bits_count = ECC12bit_bit_count;
		ECC_size->oob_max_bit_error = ECC_size->max_bit_error = 12;
		ECC_size->banks = mtd->writesize/512;
		ECC_size->bank_size = 512;
		ECC_size->bank_offset = mtd->writesize/ECC_size->banks + ECC12bit_byte_count;
		ECC_size->oob_ECC_bytes = ECC_size->ECC_bytes = ECC12bit_byte_count;
		ECC_size->oob_ECC_mode = ECC12bit;
		ECC_size->unprotect = ECC12bit_unprotect;
		break;
		case ECC16bit:
		ECC_size->oob_ecc_bits_count = ECC_size->ecc_bits_count = ECC16bit_bit_count;
		ECC_size->oob_max_bit_error = ECC_size->max_bit_error = 16;
		ECC_size->banks = mtd->writesize/512;
		ECC_size->bank_size = 512;
		ECC_size->bank_offset = mtd->writesize/ECC_size->banks + ECC16bit_byte_count;
		ECC_size->oob_ECC_bytes = ECC_size->ECC_bytes = ECC16bit_byte_count;
		ECC_size->oob_ECC_mode = ECC16bit;
		ECC_size->unprotect = ECC16bit_unprotect;
		break;
		case ECC24bitPer1K:
		ECC_size->oob_ecc_bits_count = ECC_size->ecc_bits_count = ECC24bitPer1K_bit_count;
		ECC_size->oob_max_bit_error = ECC_size->max_bit_error = 24;
		ECC_size->banks = mtd->writesize/1024;
		ECC_size->bank_size = 1024;
		ECC_size->bank_offset = mtd->writesize/ECC_size->banks + ECC24bitPer1K_byte_count;
		ECC_size->oob_ECC_bytes = ECC_size->ECC_bytes = ECC24bitPer1K_byte_count;
		ECC_size->oob_ECC_mode = ECC24bitPer1K;
		ECC_size->unprotect = ECC24bitPer1K_unprotect;
		break;
		case ECC40bitPer1K:
		ECC_size->ecc_bits_count = ECC40bitPer1K_bit_count;
		ECC_size->oob_ecc_bits_count = ECC24bitPer1K_bit_count;
		ECC_size->max_bit_error = 40;
		ECC_size->oob_max_bit_error = 24;
		ECC_size->banks = mtd->writesize/1024;
		ECC_size->bank_size = 1024;
		ECC_size->bank_offset = mtd->writesize/ECC_size->banks + ECC40bitPer1K_byte_count;
		ECC_size->ECC_bytes = ECC40bitPer1K_byte_count;
		ECC_size->oob_ECC_bytes = ECC24bitPer1K_byte_count;
		ECC_size->oob_ECC_mode = ECC24bitPer1K;
		ECC_size->unprotect = ECC40bitPer1K_unprotect;
		break;
		case ECC44bitPer1K:
		ECC_size->oob_ecc_bits_count = ECC_size->ecc_bits_count = ECC44bitPer1K_bit_count;
		ECC_size->oob_max_bit_error = ECC_size->max_bit_error = 44;
		ECC_size->banks = mtd->writesize/1024;
		ECC_size->bank_size = 1024;
		ECC_size->bank_offset = mtd->writesize/ECC_size->banks + ECC44bitPer1K_byte_count;
		ECC_size->oob_ECC_bytes = ECC_size->ECC_bytes = ECC44bitPer1K_byte_count;
		ECC_size->oob_ECC_mode = ECC44bitPer1K;
		ECC_size->unprotect = ECC44bitPer1K_unprotect;
		break;
		/*case 8:
		ECC_size->oob_ecc_bits_count = ECC_size->ecc_bits_count = ECC44bit_bit_count;
		ECC_size->max_bit_error = 44;
		ECC_size->banks = mtd->writesize/512;
		ECC_size->bank_offset = mtd->writesize/ECC_size->banks + ECC44bit_byte_count;
		ECC_size->oob_ECC_bytes = ECC_size->ECC_bytes = ECC44bit_byte_count;
		ECC_size->unprotect = ECC44bitPer1K_unprotect;
		break;*/
		default:
		printk("%d-bit ECC engine is not support:\r\n", ECC_size->ecc_engine);
		break;;
	}
	return;
}

int get_partition_name(const char *src, char** endpp, char* buffer)
{
	int i = 0;
	if(NULL == src || NULL == buffer)
	{
		return -1;
	}

	while(*src != ':')
	{
		*buffer++ = *src++;	
		i++;
	}
	if(*endpp)
		*endpp = (char *)src;
	buffer[i] = '\0';
	return i;
}

int search_mtd_table(char *string, char *ret)
{
	int i, err = 0;
	for (i = 0; i < NUM_NAND_PARTITIONS; i++) {
	//	printk(KERN_DEBUG "MTD dev%d size: %8.8llx \"%s\"\n",
	//	i, nand_partitions[i].size, nand_partitions[i].name);
		if (strcmp(string, nand_partitions[i].name) == 0) {
			*ret = i;
			break;
		}
	}
	return err;
}

/*
 * Get the flash and manufacturer id and lookup if the type is supported
 */
static struct WMT_nand_flash_dev *get_flash_type(struct mtd_info *mtd,
						  struct nand_chip *chip,
						  int busw, unsigned int *maf_id, int CE, unsigned int *spec_clk, unsigned int *spec_tadl)
{
	struct WMT_nand_flash_dev *type = NULL, type_env;
	int i, dev_id, maf_idx, ret = 0;
	unsigned int id = 0, id_5th = 0;
	char varval[200], *s = NULL, *tmp, varname[] = "wmt.io.nand";
	unsigned int varlen = 200, value, tmp_id;
	unsigned char index = 16;
	uint64_t  part_size = 0;
	char partition_name[32];
	unsigned int feature_id, fid = 0;

	/* Select the device */
	chip->select_chip(mtd, CE);

	/*  reset test: edwardwan add for debug 20071229  start*/
	chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
	/*  reset test: edwardwan add for debug 20071229  end*/

	/* Send the command for reading device ID */
	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);

	/* Read manufacturer and device IDs */
	*maf_id = chip->read_byte(mtd);
	for (i = 0; i < 3; i++) {
		dev_id = chip->read_byte(mtd);
		id += ((unsigned char)dev_id) <<((2-i)*8);
	}
	for (i = 0; i < 4; i++) {
		dev_id = chip->read_byte(mtd);
		id_5th += ((unsigned char)dev_id) <<((3-i)*8);
	}
	printk("nand chip device id = 0x%x 0x%x\n", id, id_5th);
	#ifdef NAND_DEBUG
	printk("nand chip device maf_id is %x, and dev_id is %x\n",*maf_id,dev_id);
	#endif
	tmp_id = (unsigned int)id + ((*maf_id)<<24);
	/* Lookup the flash id */
	/*for (i = 0; nand_flash_ids[i].name != NULL; i++) {
		if (dev_id == nand_flash_ids[i].id) {
			type =  &nand_flash_ids[i];*/
	for (i = 0; WMT_nand_flash_ids[i].dwFlashID != 0; i++) {
		if (((unsigned int)id + ((*maf_id)<<24)) == WMT_nand_flash_ids[i].dwFlashID) {
			if (WMT_nand_flash_ids[i].dwFlashID == 0x98D79432)
				if (id_5th != WMT_nand_flash_ids[i].dwFlashID2)
					continue;
			type =  &WMT_nand_flash_ids[i];
			/*printk("find nand chip device id i=%d\n", i);*/
			break;
		}
	}
	value = *((volatile unsigned int *)(GPIO_BASE_ADDR + 0x100));
	if (!((value&6) == 2))
		ret = wmt_getsyspara(varname, varval, &varlen);
	if (!ret && !((value&6) == 2)) {
		s = varval;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwFlashID = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwBlockCount = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwPageSize = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwSpareSize = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwBlockSize = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwAddressCycle = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwBI0Position = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwBI1Position = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwBIOffset = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwDataWidth = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwPageProgramLimit = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwSeqRowReadSupport = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwSeqPageProgram = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwNandType = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwRWTimming = value; s = tmp+1;
		copy_filename(type_env.ProductName, s, MAX_PRODUCT_NAME_LENGTH);

		if (type_env.dwBlockCount < 1024 || type_env.dwBlockCount > 16384) {
			printk(KERN_INFO "dwBlockCount = 0x%x is abnormal\n", type_env.dwBlockCount);
			goto list;
		}
		if (type_env.dwPageSize < 512  || type_env.dwPageSize > 16384) {
			printk(KERN_INFO "dwPageSize = 0x%x is abnormal\n", type_env.dwPageSize);
			goto list;
		}
		if (type_env.dwPageSize > 512)
			type_env.options = NAND_SAMSUNG_LP_OPTIONS | NAND_NO_READRDY | NAND_NO_AUTOINCR;
		if (type_env.dwBlockSize < (1024*64)  || type_env.dwBlockSize > (16384*256)) {
			printk(KERN_INFO "dwBlockSize = 0x%x is abnormal\n", type_env.dwBlockSize);
			goto list;
		}
		if (type_env.dwAddressCycle < 3  || type_env.dwAddressCycle > 5) {
			printk(KERN_INFO "dwAddressCycle = 0x%x is abnoraml\n", type_env.dwAddressCycle);
			goto list;
		}
		if (type_env.dwBI0Position != 0  &&
		type_env.dwBI0Position > ((type_env.dwBlockSize/type_env.dwPageSize)-1)) {
			printk(KERN_INFO "dwBI0Position = 0x%x is abnoraml\n", type_env.dwBI0Position);
			goto list;
		}
		if (type_env.dwBI1Position != 0  &&
		type_env.dwBI1Position > ((type_env.dwBlockSize/type_env.dwPageSize)-1)) {
			printk(KERN_INFO "dwBI1Position = 0x%x is abnoraml\n", type_env.dwBI1Position);
			goto list;
		}
		if (type_env.dwBIOffset != 0 && type_env.dwBIOffset != 5) {
			printk(KERN_INFO "dwBIOffset = 0x%x is abnoraml\n", type_env.dwBIOffset);
			goto list;
		}
		if (type_env.dwDataWidth != 0/* && type_env.dwDataWidth != 1*/) {
			printk(KERN_INFO "dwDataWidth = 0x%x is abnoraml\n", type_env.dwDataWidth);
			goto list;
		}
		/*printk(KERN_INFO "dwFlashID = 0x%x\n", type_env.dwFlashID);
		printk(KERN_INFO "dwBlockCount = 0x%x\n", type_env.dwBlockCount);
		printk(KERN_INFO "dwPageSize = 0x%x\n", type_env.dwPageSize);
		printk(KERN_INFO "dwSpareSize = 0x%x\n", type_env.dwSpareSize);
		printk(KERN_INFO "dwBlockSize = 0x%x\n", type_env.dwBlockSize);
		printk(KERN_INFO "dwAddressCycle = 0x%x\n", type_env.dwAddressCycle);
		printk(KERN_INFO "dwBI0Position = 0x%x\n", type_env.dwBI0Position);
		printk(KERN_INFO "dwBI1Position = 0x%x\n", type_env.dwBI1Position);
		printk(KERN_INFO "dwBIOffset = 0x%x\n", type_env.dwBIOffset);
		printk(KERN_INFO "dwDataWidth = 0x%x\n", type_env.dwDataWidth);
		printk(KERN_INFO "dwPageProgramLimit = 0x%x\n", type_env.dwPageProgramLimit);
		printk(KERN_INFO "dwSeqRowReadSupport = 0x%x\n", type_env.dwSeqRowReadSupport);
		printk(KERN_INFO "dwSeqPageProgram = 0x%x\n", type_env.dwSeqPageProgram);
		printk(KERN_INFO "dwNandType = 0x%x\n", type_env.dwNandType);
		printk(KERN_INFO "dwECCBitNum = 0x%x\n", type_env.dwECCBitNum);
		printk(KERN_INFO "dwRWTimming = 0x%x\n", type_env.dwRWTimming);
		printk(KERN_INFO "cProductName = %s\n", type_env.ProductName);*/
		if (((unsigned int)id + ((*maf_id)<<24)) == type_env.dwFlashID) {
			if (type)
				printk(KERN_INFO "flash id has been established in flash id list\n");
			type = &type_env;
		}
	}
list:

	if (!type) {
		/*printk("before ERR_PTR(-ENODEV)\n");*/
		return ERR_PTR(-ENODEV);
	}
	if (!mtd->name)
		/*mtd->name = type->name;*/
		/*mtd->name = type->ProductName;*/
		mtd->name = "WMT.nand";

	if (whole_eslc == 1 && type->dwBlockSize == 0x200000) {
		type->dwBlockSize >>= 1;
		type->dwBI1Position >>= 1;
	}

	/*chip->chipsize = type->chipsize << 20;*/
	chip->chipsize = (uint64_t)type->dwBlockCount * (uint64_t)type->dwBlockSize;

	/* get all information from table */
	chip->cellinfo = type->dwNandType << 2;
	mtd->writesize = type->dwPageSize;
	mtd->oobsize = type->dwSpareSize;
	mtd->erasesize = type->dwBlockSize;
	mtd->dwECCBitNum = type->dwECCBitNum;
	mtd->dwRetry = type->dwRetry;
    mtd->is_randomizer = type->is_randomizer;
	mtd->id = type->dwFlashID;
	mtd->id2 = type->dwFlashID2;
	mtd->blkcnt = type->dwBlockCount;
	mtd->pagecnt = mtd->erasesize/mtd->writesize;
	busw = type->dwDataWidth ? NAND_BUSWIDTH_16 : 0;
	if (mtd->writesize < 8192 && mtd->oobsize >= 218)
		ECC8BIT_ENGINE = 1;
	*spec_clk = type->dwRWTimming;
	*spec_tadl = type->dwTadl;

	// make partitions by uboot env
	memset(varval, 0, varlen);

	if((mtd->id>>24) == NAND_MFR_HYNIX && whole_eslc == 0 ) {
		nand_partitions[0].size = 0x2000000;
		nand_partitions[1].size = 0x2000000;
		nand_partitions[2].size = 0x2000000;
	}

	ret = wmt_getsyspara("wmt.nand.partition", varval, &varlen);
	printk("wmt.nand.partition: %s\n", varval);
	if((chip->chipsize >> 30) == 2) { // <= 2GB nand, sure that 2GB nand is workable.
		printk("data partition 512M\n");
	} else if(ret == 0) {
		s = varval;
		while(*s != '\0')
		{
			index = NUM_NAND_PARTITIONS;
			memset(partition_name, 0, 32);
			get_partition_name(s, &tmp, partition_name);
			search_mtd_table(partition_name, &index);
			s = tmp + 1;
			part_size = simple_strtoul(s, &tmp, 16);
			s = tmp + 1;

			//LocalDisk can't be resized by uboot env, its size is left whole nand.
			if((index >= 0) &&  (index < (NUM_NAND_PARTITIONS-1)) && (part_size < chip->chipsize)) { 
				nand_partitions[index].size = part_size;
			} else {
				printk("Invalid wmt.nand.partition uboot parameter, use default nand partitions\n");
				break;
			}
		}
	} else if((chip->chipsize >> 30) >= 4) { // >= 4GB nand
		long solid_size;
		int solid_block_count;
		int block_count;

		//data partition size:local disk partition size = 4:6
		solid_size = nand_partitions[0].size + 	nand_partitions[1].size + nand_partitions[2].size + nand_partitions[3].size + nand_partitions[4].size + nand_partitions[5].size;
		solid_block_count = solid_size / type->dwBlockSize;
		block_count = type->dwBlockCount - solid_block_count;
		nand_partitions[6].size = (block_count * 4 / 10) * type->dwBlockSize;
	}

	if(whole_eslc == 0 && (mtd->id>>24) == NAND_MFR_HYNIX) {
		par1_ofs = nand_partitions[0].size;
		par2_ofs = par1_ofs + nand_partitions[1].size;
		par3_ofs = par2_ofs + nand_partitions[2].size;
		par4_ofs = par3_ofs + nand_partitions[3].size;

		par1_ofs = par1_ofs/mtd->writesize;
		par2_ofs = par2_ofs/mtd->writesize;
		par3_ofs = par3_ofs/mtd->writesize;
		par4_ofs = par4_ofs/mtd->writesize;
	}

#if 0
	/* Newer devices have all the information in additional id bytes */
	if (!type->pagesize) {
		int extid;
		/*printk("calculate nand chip device type\n");*/
		/* The 3rd id byte holds MLC / multichip data */
		chip->cellinfo = chip->read_byte(mtd);
		/* The 4th id byte is the important one */
		extid = chip->read_byte(mtd);
		/* Calc pagesize */
		mtd->writesize = 1024 << (extid & 0x3);
		extid >>= 2;
		/* Calc oobsize */
		/* DannierChen add support 4096+218 page size */
		if((extid&0x03) == 2) {
			mtd->oobsize = 218;
			ECC8BIT_ENGINE = 1;
		} else
			mtd->oobsize = (8 << (extid & 0x01)) * (mtd->writesize >> 9);
		extid >>= 2;
		/* Calc blocksize. Blocksize is multiples of 64KiB */
		mtd->erasesize = (64 * 1024) << (extid & 0x03);
		extid >>= 2;
		/* Get buswidth information */
		busw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;

	} else {
		/*
		 * Old devices have chip data hardcoded in the device id table
		 */
		/*printk("find nand chip device id, and give device type\n");*/
		mtd->erasesize = type->erasesize;
		mtd->writesize = type->pagesize;
		mtd->oobsize = mtd->writesize / 32;
		busw = type->options & NAND_BUSWIDTH_16;
	}
#endif /* end of (#if 0) masked my Dannier*/

	/* Try to identify manufacturer */
	for (maf_idx = 0; nand_manuf_ids[maf_idx].id != 0x0; maf_idx++) {
		if (nand_manuf_ids[maf_idx].id == *maf_id)
			break;
	}

	/*
	 * Check, if buswidth is correct. Hardware drivers should set
	 * chip correct !
	 */
	if (busw != (chip->options & NAND_BUSWIDTH_16)) {
		printk(KERN_INFO "NAND device: Manufacturer ID:"
				" 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id,
				/*dev_id, nand_manuf_ids[maf_idx].name, mtd->name);*/
				id, nand_manuf_ids[maf_idx].name, mtd->name);
		printk(KERN_WARNING "NAND bus width %d instead %d bit\n",
				(chip->options & NAND_BUSWIDTH_16) ? 16 : 8,
				busw ? 16 : 8);
		return ERR_PTR(-EINVAL);
	}

	/* Calculate the address shift from the page size */
	chip->page_shift = ffs(mtd->writesize) - 1;
	/* Convert chipsize to number of pages per chip -1. */
	chip->pagemask = (chip->chipsize >> chip->page_shift) - 1;

	chip->bbt_erase_shift = chip->phys_erase_shift =
		ffs(mtd->erasesize) - 1;
	chip->chip_shift = shift_bit(chip->chipsize);

	/* Set the bad block position */
	chip->badblockpos = mtd->writesize > 512 ?
		NAND_LARGE_BADBLOCK_POS : NAND_SMALL_BADBLOCK_POS;

	/* Get chip options, preserve non chip based options */
	chip->options &= ~NAND_CHIPOPTIONS_MSK;
	chip->options |= type->options & NAND_CHIPOPTIONS_MSK;

	/*
	 * Set chip as a default. Board drivers can override it, if necessary
	 */
	chip->options |= NAND_NO_AUTOINCR;

	/* Check if chip is a not a samsung device. Do not clear the
	 * options for chips which are not having an extended id.
	 */
	/*if (*maf_id != NAND_MFR_SAMSUNG && !type->pagesize)*//* Dannier:to support new table*/
	if (*maf_id != NAND_MFR_SAMSUNG && type->dwPageSize > 512)
		chip->options &= ~NAND_SAMSUNG_LP_OPTIONS;

	/* Check for AND chips with 4 page planes */
	/*if (chip->options & NAND_4PAGE_ARRAY)
		chip->erase_cmd = multi_erase_cmd;
	else
		chip->erase_cmd = single_erase_cmd;*/

	/* Do not replace user supplied command function ! */
	/*if (mtd->writesize > 512 && chip->cmdfunc == nand_command)
		chip->cmdfunc = nand_command_lp;*/

	printk(KERN_INFO "NAND device: Manufacturer ID:"
			" 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id, id,
			nand_manuf_ids[maf_idx].name, type->ProductName);

/*	*maf_id = tmp_id;
	if (tmp_id == 0x2C88044B || tmp_id == 0x2C68044A || tmp_id == 0x2C64444B) {
		if (tmp_id == 0x2C64444B)
			nand_set_feature(mtd, NAND_SET_FEATURE, 01, 03);
	}*/
	switch(tmp_id) 
	{
		case 0x2C88044B:
			nand_set_feature(mtd, NAND_SET_FEATURE, 01, 04); //set to mode 4
		break;
		
		case 0x2C68044A:
		//	nand_set_feature(mtd, NAND_SET_FEATURE, 01, 05); //set to mode 5
		break;

		case 0x2C64444B:
			nand_set_feature(mtd, NAND_SET_FEATURE, 01, 03); //set to mode 3
		break;
	}

	switch(tmp_id) 
	{
		case 0x2C88044B:
		case 0x2C68044A:
			*maf_id = tmp_id;
			chip->cmdfunc(mtd, NAND_GET_FEATURE, 0x01, -1);
			for (i = 0; i < 4; i++) {
				feature_id = chip->read_byte(mtd);
				fid += ((unsigned char)feature_id) <<((3-i)*8);
			}	
			printk("Micron Nand Flash Features is 0x%08X\n", fid);
		break;
	}

	return type;
}
static int wmt_calc_clock(struct mtd_info *mtd, unsigned int spec_clk, unsigned int spec_tadl, struct NFC_RW_T *nfc_rw)
{
	unsigned int i, div1=0, div2, clk1, clk2=0, comp, T_setup, T1=0, T2=0, clk, PLLB;
	unsigned int tREA, tREH, Thold, Thold2, Ttmp, tADL, tWP, divisor, tWH;
	
	/*print_nand_register(mtd);*/
	PLLB = *(volatile unsigned int *)PMPMB_ADDR;
	PLLB = (2*(((PLLB>>16)&0x7F)+1))/((((PLLB>>8)&0x1F)+1)*(1<<(PLLB&3)));
	printk(KERN_WARNING "PLLB=0x%x, spec_clk=0x%x\n", PLLB, spec_clk);
	tREA = (spec_clk>>24)&0xFF;
	tREH = (spec_clk>>16)&0xFF;
	tWP  = (spec_clk>>8)&0xFF;
	tWH = spec_clk&0xFF;
	tADL = spec_tadl;
	for (i = 1; i < 16; i++) {
		if (MAX_SPEED_MHZ >= (PLLB*SOURCE_CLOCK)/i) {
			div1 = i;
			break;
		}
	}

	clk1 = (1000 * div1)/(PLLB*SOURCE_CLOCK);
	//printk("clk1=%d, div1=%d, spec_clk=%d\n", clk1, div1, spec_clk);
	for (T1 = 1; T1 < 10; T1++) {
		if ((T1*clk1) >= (tREA + MAX_READ_DELAY))
			break;
	}
	i = 1;
	while (i*clk1 <= tREH) {
		i++;
	}
	Thold = i;
	printk("T1=%d, clk1=%d, div1=%d, Thold=%d, tREA=%d+delay(%d)\n", T1, clk1, div1, Thold, tREA, MAX_READ_DELAY);
	Ttmp = T_setup = T1;
	clk = clk1;
	divisor = div1;
	div2 = div1;
	while (Ttmp > 1 && clk != 0) {
		div2++;
		clk2 = (1000 * div2)/(PLLB*SOURCE_CLOCK);
		comp = 0;
		for (T2 = 1; T2 < Ttmp; T2++) {
			if ((T2*clk2) >= (tREA + MAX_READ_DELAY)) {
				Ttmp = T2;
				comp = 1;
				i = 1;
				while (i*clk2 <= tREH) {
					i++;
				}
				Thold2 = i;
				printk("T2=%d, clk2=%d, div2=%d, Thold2=%d, comp=1\n", T2, clk2, div2, Thold2);
				break;
			}
		}
		if (comp == 1) {
			clk1 = clk * (T_setup+Thold) * mtd->writesize;
			div1 = clk2 * (T2+Thold2) * mtd->writesize;
			printk("Tim1=%d , Tim2=%d\n", clk1, div1);
			if ((clk * (T_setup+Thold) * mtd->writesize) > (clk2 * (T2+Thold2) * mtd->writesize)) {
				T_setup = T2;
				clk = clk2;
				divisor = div2;
				Thold = Thold2;
			} else {
				printk("T2 is greater and not use\n");
			}
		}
	} /* end of while */
	nfc_rw->T_R_hold = Thold;
	nfc_rw->T_R_setup = T_setup;
	nfc_rw->divisor = divisor;

	i = 1;
	nfc_rw->T_W_setup = 0x1; /* set write setup/hold time */
	while (/*((i*2+2)*clk) <= (tADL-tWP) ||*/ (i*clk) <= (tWP+MAX_WRITE_DELAY)) {
		nfc_rw->T_W_setup += 1;
		i++;
	}
	nfc_rw->T_W_hold = 1;

	if ((nfc_rw->T_W_hold * 2) == 2)
		Thold = 4;
	else if ((nfc_rw->T_W_hold * 2) == 4)
		Thold = 6;
	i = 0;
	while (((i+Thold)*clk) < tADL && i < 15) {
		i++;
	}
	nfc_rw->T_TADL_delay = i;
	//printk("Tad i=%d\n", i);
	nfc_rw->T_RHC_THC =
	((nfc_rw->T_R_hold&0xFF) << 12) + 
	(((nfc_rw->T_R_setup&0xFF) + (nfc_rw->T_R_hold&0xFF)) << 8) +
	((nfc_rw->T_W_hold&0xF) << 4) + 
	((nfc_rw->T_W_setup + nfc_rw->T_W_hold)&0xF);

	if ((MAX_SPEED_MHZ < (PLLB*SOURCE_CLOCK)/(divisor)) || clk == 0 || T_setup == 0 || clk > 45)
		return 1;

	return 0;
}

static int wmt_nfc_init(struct wmt_nand_info *info, struct mtd_info *mtd)
{
	int busw, nand_maf_id, page_per_block, CE = 0, nand_maf_id1 = 0;
	unsigned int spec_clk, divisor, status = 0, spec_clk1, spec_tadl, spec_tadl1;
	struct nand_chip *chip = mtd->priv;
	struct WMT_nand_flash_dev *type;
	struct NFC_RW_T nfc_rw;


	/* Get buswidth to select the correct functions */
	busw = chip->options & NAND_BUSWIDTH_16;

	/*  struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);*/
	/* enable chip select */
	/* new structure  */

	/* old structure */
	/* writeb(PAGE_2K|WIDTH_8|WP_DISABLE|DIRECT_MAP|OLDDATA_EN,
	info->reg + WMT_NFC_NAND_TYPE_SEL);*/
	/* writeb((PAGE_2K|WIDTH_8|WP_DISABLE|DIRECT_MAP)&(~OLDDATA_EN),
	info->reg + WMT_NFC_NAND_TYPE_SEL);*/

	writeb((PAGE_2K|WIDTH_8|WP_DISABLE|DIRECT_MAP|CHECK_ALLFF)&(~OLDDATA_EN),
	info->reg + WMT_NFC_NAND_TYPE_SEL);
	
	writel(readl(info->reg + WMT_NFC_READ_CYCLE_PULE_CTRL) & 0xffff0000,
	info->reg + WMT_NFC_READ_CYCLE_PULE_CTRL);
	writel(readl(info->reg + WMT_NFC_READ_CYCLE_PULE_CTRL) | NFC_RWTimming,
	info->reg + WMT_NFC_READ_CYCLE_PULE_CTRL);
	
	writel(B2R,	info->reg + WMT_NFC_HOST_STAT_CHANGE);
	writel(0x0,	info->reg + WMT_NFC_CALC_CTRL);
	
	/* DannierChen add to identify the page size and block size */
	type = get_flash_type(mtd, chip, busw, &nand_maf_id, CE, &spec_clk, &spec_tadl);
	if (IS_ERR(type)) {
		printk(KERN_WARNING "No NAND device found!!!\n");
		chip->select_chip(mtd, -1);
		return -1;
	}

	page_per_block = chip->phys_erase_shift - chip->page_shift;
	/*printk(KERN_INFO "page per block = 2^%x \n", page_per_block);*/
	switch (page_per_block) {
	case 4:
		writel(0x1F, info->reg + WMT_NFC_PAGESIZE_DIVIDER_SEL); /*32 page per block*/
	break;
	case 5:/*32 page per block*/
		writel((1 << 5) | 0x1F, info->reg + WMT_NFC_PAGESIZE_DIVIDER_SEL);
	break;
	case 6:/*64 page per block*/
		writel((2 << 5) | 0x1F, info->reg + WMT_NFC_PAGESIZE_DIVIDER_SEL);
	break;
	case 7:/*128 page per block*/
		writel((3 << 5) | 0x1F, info->reg + WMT_NFC_PAGESIZE_DIVIDER_SEL);
	break;
	case 8:/*256 page per block*/
		writel((4 << 5) | 0x1F, info->reg + WMT_NFC_PAGESIZE_DIVIDER_SEL);
	break;
	case 9:/*512 page per block*/
		writel((5 << 5) | 0x1F, info->reg + WMT_NFC_PAGESIZE_DIVIDER_SEL);
	break;
	default:
		printk(KERN_ERR "page per block not support\n");
	break;
	}

	#ifdef NAND_DEBUG
	printk(KERN_ERR "mtd->writesize = %x \n", mtd->writesize);
	#endif
	if (mtd->writesize == 2048) {
		writeb((PAGE_2K|WIDTH_8|WP_DISABLE|DIRECT_MAP|CHECK_ALLFF)&(~OLDDATA_EN),
		info->reg + WMT_NFC_NAND_TYPE_SEL);
	} else if (mtd->writesize == 4096) {
		writeb((PAGE_4K|WIDTH_8|WP_DISABLE|DIRECT_MAP|CHECK_ALLFF)&(~OLDDATA_EN),
		info->reg + WMT_NFC_NAND_TYPE_SEL);
	} else if (mtd->writesize == 8192) {
		writeb((PAGE_8K|WIDTH_8|WP_DISABLE|DIRECT_MAP|CHECK_ALLFF)&(~OLDDATA_EN),
		info->reg + WMT_NFC_NAND_TYPE_SEL);
	} else if (mtd->writesize == 16384) {
		writew((PAGE_16K|WIDTH_8|WP_DISABLE|DIRECT_MAP|CHECK_ALLFF)&(~OLDDATA_EN),
		info->reg + WMT_NFC_NAND_TYPE_SEL);
	} else {
		writeb((PAGE_512|WIDTH_8|WP_DISABLE|DIRECT_MAP)&(~OLDDATA_EN),
		info->reg + WMT_NFC_NAND_TYPE_SEL); /*new structure*/
	}
	chip->select_chip(mtd, -1);
	status = wmt_calc_clock(mtd, spec_clk, spec_tadl, &nfc_rw);
	if (status) {
		printk("timming setting fail");
		return 1;
	}
	NFC_RWTimming = nfc_rw.T_RHC_THC;
	divisor = nfc_rw.divisor;
	//NFC_RWTimming = ((Thold&0xFF) << 12) + ((T + (Thold&0xFF)) << 8) +
	/* nand write timing 1T2T has bug, will cause write fail only can set 2T4T */
	//(2 << 4) + 4;/*(((Thold>>8)&0xFF) << 4) + 2*((Thold>>8)&0xFF);*/

	switch(nand_maf_id)
	{
		case 0x2C88044B:
		case 0x2C68044A:
		case 0x2C64444B:
			NFC_RWTimming = 0x2424;
			divisor = 9;
		break;
	}

	*(volatile unsigned long *)PMNAND_ADDR = (divisor&NFC_ClockMask);
	while ((*(volatile unsigned long *)(PMCS_ADDR+0x18))&0x7F0038)
	;
	divisor = *(volatile unsigned long *)PMNAND_ADDR;
	printk(KERN_WARNING "nand tadl=%dT, divisor set 0x%x, NFC_timing=0x%x\n",
	nfc_rw.T_TADL_delay, divisor, NFC_RWTimming);
	writeb((readb(info->reg + WMT_NFC_CALC_CTRL) & 0xF) |	nfc_rw.T_TADL_delay<<4,
	info->reg + WMT_NFC_CALC_CTRL);
	writel((readl(info->reg + WMT_NFC_READ_CYCLE_PULE_CTRL) & 0xffff0000) | NFC_RWTimming,
	info->reg + WMT_NFC_READ_CYCLE_PULE_CTRL);
	
	return 0;
}

#if 0
static void disable_redunt_out_bch_ctrl(struct wmt_nand_info *info, int flag)
{
	if (flag == 1)
		writeb(readb(info->reg + WMT_NFC_CALC_CTRL)|0x02, info->reg + WMT_NFC_CALC_CTRL);
	else
		writeb(readb(info->reg + WMT_NFC_CALC_CTRL)&0xfd, info->reg + WMT_NFC_CALC_CTRL);
}
static void redunt_read_hm_ecc_ctrl(struct wmt_nand_info *info, int flag)
{
	if (flag == 1)
		writeb(readb(info->reg + WMT_NFC_SMC_ENABLE) | 0x02, info->reg + WMT_NFC_SMC_ENABLE);
	else
		writeb(readb(info->reg + WMT_NFC_SMC_ENABLE) & 0xfd, info->reg + WMT_NFC_SMC_ENABLE);
}
#endif

static void set_ecc_engine(struct wmt_nand_info *info, int type)
{
	/*struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);*/
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) & 0xfffffff8, info->reg + WMT_NFC_ECC_BCH_CTRL);
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | type, info->reg + WMT_NFC_ECC_BCH_CTRL);

	/* enable BCH ecc interrupt and new structure */
	if (type == ECC16bit || type == ECC24bitPer1K || type == ECC40bitPer1K) { /*to support read page twice*/
	/*if (type == ECC16bit) {*/
		/*printk(KERN_ERR "set_ecc_engine for bch 16 bit\n");*/
		writew(eccBCH_inetrrupt_enable, info->reg + WMT_NFC_ECC_BCH_INT_MASK);
		writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
		info->reg + WMT_NFC_ECC_BCH_CTRL);
		writel(readl(info->reg + WMT_NFC_NAND_TYPE_SEL) & (~OLDDATA_EN),
		info->reg + WMT_NFC_NAND_TYPE_SEL);
	} else if (type == ECC12bit) {
		/*printk(KERN_ERR "set_ecc_engine for bch 12 bit\n");*/
		writew(eccBCH_inetrrupt_enable, info->reg + WMT_NFC_ECC_BCH_INT_MASK);
		writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
		info->reg + WMT_NFC_ECC_BCH_CTRL);
		writel(readl(info->reg + WMT_NFC_NAND_TYPE_SEL) & (~OLDDATA_EN),
		info->reg + WMT_NFC_NAND_TYPE_SEL);
	} else if (type == ECC8bit) {
		/*printk(KERN_ERR "set_ecc_engine for bch 8 bit\n");*/
		writew(eccBCH_inetrrupt_enable, info->reg + WMT_NFC_ECC_BCH_INT_MASK);
		writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
		info->reg + WMT_NFC_ECC_BCH_CTRL);
		writel(readl(info->reg + WMT_NFC_NAND_TYPE_SEL) & (~OLDDATA_EN),
		info->reg + WMT_NFC_NAND_TYPE_SEL);
	} else if (type == ECC4bit) {
		/*printk(KERN_ERR "set_ecc_engine for bch 4 bit\n");*/
		writew(eccBCH_inetrrupt_enable, info->reg + WMT_NFC_ECC_BCH_INT_MASK);
		writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
		info->reg + WMT_NFC_ECC_BCH_CTRL);
		writel(readl(info->reg + WMT_NFC_NAND_TYPE_SEL) & (~OLDDATA_EN),
		info->reg + WMT_NFC_NAND_TYPE_SEL);
	}	else { /*disable 4bit ecc interrupt and old structure*/
		writew(eccBCH_inetrrupt_disable, info->reg + WMT_NFC_ECC_BCH_INT_MASK);
		writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
		info->reg + WMT_NFC_ECC_BCH_CTRL);
		#ifdef NAND_DEBUG
		printk(KERN_ERR "set_ecc_engine for harmming\n");
		#endif
		writel(readl(info->reg + WMT_NFC_NAND_TYPE_SEL) & (~OLDDATA_EN),
		info->reg + WMT_NFC_NAND_TYPE_SEL);
	}
}


static int wmt_nand_ready(struct mtd_info *mtd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	//unsigned int b2r_stat;
	int i = 0;

	while (1)	{
		if (readb(info->reg + WMT_NFC_HOST_STAT_CHANGE) & B2R)
			break;
		if ((++i>>20)) {
			printk(KERN_ERR "nand flash is not ready\n");
			/*print_nand_register(mtd);*/
			/*    while (1);*/
			return -1;
		}
	}
	//b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
	writeb(B2R, info->reg + WMT_NFC_HOST_STAT_CHANGE);
	if (readb(info->reg + WMT_NFC_HOST_STAT_CHANGE) & B2R)	{
		printk(KERN_ERR "NFC err : B2R status not clean\n");
		return -2;
	}
	return 0;
}


static int wmt_nfc_transfer_ready(struct mtd_info *mtd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	int i = 0;

	while (1)	{
		if (!(readb(info->reg + WMT_NFC_MISC_STAT_PORT) & NFC_BUSY))
			break;

		if (++i>>20)
			return -3;
	}
	return 0;
}
/* Vincent  2008.11.3*/
static int wmt_wait_chip_ready(struct mtd_info *mtd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	int i = 0;

	while (1) {
		if ((readb(info->reg + WMT_NFC_MISC_STAT_PORT) & FLASH_RDY))
			break;
		if (++i>>20)
			return -3;
	}
	return 0;
}
static int wmt_wait_cmd_ready(struct mtd_info *mtd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	int i = 0;

	while (1)	{
		if (!(readb(info->reg + WMT_NFC_MISC_STAT_PORT) & NFC_CMD_RDY))
			break;
		if (++i>>20)
			return -3;
	}
	return 0;
}

/* #if (NAND_PAGE_SIZE == 512) Vincent 2008.11.4
static int wmt_wait_dma_ready(struct mtd_info *mtd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	int i = 0;

	while (1) {
		if (!(readb(info->reg + NFC_IDLE) & 0x02))
			break;
		if (++i>>20) {
			printk(KERN_ERR"\r DMA NOT Ready!\n");
			print_nand_register(mtd);
			return -3;
		}
	}
	return 0;
}
#endif  Vincent 2008.11.4*/

static void wmt_wait_nfc_ready(struct wmt_nand_info *info)
{
	unsigned int bank_stat1, i = 0;
	while (1) {
		bank_stat1 = readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT1);/* Vincent 2008.11.14 */
		if (!(readb(info->reg + WMT_NFC_MISC_STAT_PORT) & NFC_BUSY))
			break;
		else if ((bank_stat1 & 0x101) == (ERR_CORRECT | BCH_ERR))
			break;

		if (i>>20)
			return;
		i++;
	}
}

static void bit_correct(uint8_t *c, uint8_t pos)
{
	c[0] = (((c[0] ^ (0x01<<pos)) & (0x01<<pos)) | (c[0] & (~(0x01<<pos))));
	#if 0
	temp = info->dmabuf[bch_err_idx[0] >> 3];
	temp >>= ((bch_err_idx[0] & 0x07) - 1);
	#endif
}

/*
 * flag = 0, need check BCH ECC
 * flag = 1, don't check ECC
 * flag = 2, need check Harming ECC
 *
*/
static int NFC_WAIT_IDLE(struct mtd_info *mtd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	int i = 0;

	while (1) {
		if (readb(info->reg + WMT_NFC_IDLE_STAT) & NFC_IDLE)
			break;
		if (i>>20) {
			writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
			info->reg + WMT_NFC_ECC_BCH_CTRL);
			printk("in nfc_wait_idle(): while 1 \n");
			/*print_nand_register(mtd);*/
			//while(i);
			return -1;
		}
		i++;
	}
	return 0;
	
}

static int wmt_nfc_wait_idle(struct mtd_info *mtd, unsigned int flag, int command,
int column, unsigned int page_addr)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	int i = 0;

	while (1) {
		if (readb(info->reg + WMT_NFC_IDLE_STAT) & NFC_IDLE)
			break;
		if (i>>20) {
			writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
			info->reg + WMT_NFC_ECC_BCH_CTRL);
			printk(KERN_NOTICE "in nfc_wait_idle(): while 1 \n");
			/*print_nand_register(mtd);*/
			//while(i);
			return -1;
		}
		i++;
	}
	/* continue read next bank and calc BCH ECC */
		writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
		info->reg + WMT_NFC_ECC_BCH_CTRL);

	return 0;
}

void bch_data_ecc_correct(struct mtd_info *mtd)
{
	int i;
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	struct nand_chip *this = mtd->priv;
	unsigned int bank_stat1, bank_stat2, bch_ecc_idx, bank, ecc_engine;
	unsigned int bank_size;
	struct ECC_size_info ECC_size;

	bank_stat1 = readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT1);
	if ((bank_stat1 & 0x101) == (ERR_CORRECT | BCH_ERR)) {
		/* BCH ECC err process */
		bank_stat2 = readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT2);
		bch_ecc_idx = bank_stat2 & BCH_ERR_CNT;
		bank = (bank_stat2 & 0xF00) >> 8;
		/* for data area */
		#ifdef NAND_DEBUG
		printk(KERN_NOTICE "in nfc_wait_idle(): Read data \n");
		#endif
		ecc_engine = info->ECC_mode;
		ECC_size.ecc_engine = ecc_engine;
		calculate_ECC_info(mtd, &ECC_size);
		/*if (this->cur_chip && (info->cur_page%4) == 0)
		if ((info->cur_page < 0x7FB00) && this->cur_chip->cur_try_times < 5 && this->cur_chip != 0 && info->isr_cmd == 0x0) {
			printk("----------------------------------set unc error by dannier info->cur_page0x%x\n", info->cur_page);
			bch_ecc_idx = BCH_ERR_CNT;
		}*/
		if (info->isr_cmd == 0x50 || (readb(info->reg + WMT_NFC_SMC_ENABLE) & 0x2)) {
			info->oob_ecc_error = 0x50;
			//printk("re ob u cur_page=%d\n",info->cur_page);
			writew(readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT1)|(ERR_CORRECT|BCH_ERR),
			info->reg + WMT_NFC_ECC_BCH_INT_STAT1);
			writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
			info->reg + WMT_NFC_ECC_BCH_CTRL);
			return;
		}
		if (bch_ecc_idx >= BCH_ERR_CNT) {
			writew(readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT1)|(ERR_CORRECT | BCH_ERR),
			info->reg + WMT_NFC_ECC_BCH_INT_STAT1);
			writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
			info->reg + WMT_NFC_ECC_BCH_CTRL);
			
			if (info->isr_cmd == 0x0 && mtd->dwRetry && this->cur_chip) {
				info->data_ecc_uncor_err = 1;
				if (info->cur_page >= ((mtd->blkcnt-8)*mtd->pagecnt) &&
				info->cur_page < ((mtd->blkcnt-4)*mtd->pagecnt)) {
					/* read retry table not allowed to use read retry */
					info->data_ecc_uncor_err = 2;
					printk(KERN_ERR "data area bank %d uncor err page=0x%x no retry\n", bank, info->cur_page);
				} 
				#ifdef RETRY_DEBUG
				else
					printk(KERN_ERR "data area bank %d uncor err page=0x%x use retry\n", bank, info->cur_page);
				#endif
				
				return;
			} else
				printk(KERN_ERR "data area uncor err page=0x%x no retry\n", info->cur_page);
			mtd->ecc_stats.failed++;
			return; /* uncorrected err */
		}
		bank_size = ECC_size.bank_size;
		/* mtd->ecc_stats.corrected += (bank_stat2 & BCH_ERR_CNT);*/
		/* BCH ECC correct */
		#ifdef NAND_DEBUG
		printk(KERN_NOTICE "data area %d bit corrected err on bank %d \n", bch_ecc_idx, bank);
		#endif
		for (i = 0; i < bch_ecc_idx; i++) {
			bch_err_pos[i] = (readw(info->reg +	WMT_NFC_ECC_BCH_ERR_POS1 + 2*i) & BCH_ERRPOS0);
			//printk(KERN_NOTICE "data area byte=%d corrected err on bank %d bs=%d, banks=%d\n", bch_err_pos[i]>>3, bank, bank_size,ECC_size.banks);
			if (bank >= (ECC_size.banks-1)) {
				if((bch_err_pos[i] >> 3) < bank_size) {
					//printk(KERN_NOTICE "b7 area value=%d ", info->dmabuf[bank_size* bank + (bch_err_pos[i] >> 3)]);
					bit_correct(&info->dmabuf[bank_size* bank + (bch_err_pos[i] >> 3)], bch_err_pos[i] & 0x07);
					//printk(KERN_NOTICE "b7 area value=%d \n", info->dmabuf[bank_size* bank + (bch_err_pos[i] >> 3)]);
				} else if ((bch_err_pos[i] >> 3) < (bank_size + 24)) {//oob area of last bank
					//printk(KERN_NOTICE "redundant area value=%d ", *((uint8_t *)(info->reg+ECC_FIFO_0)+(bch_err_pos[i] >> 3) - bank_size));
					bit_correct((uint8_t *)(info->reg+ECC_FIFO_0)+(bch_err_pos[i] >> 3) - bank_size, (bch_err_pos[i] & 0x07));
					//printk(KERN_NOTICE "redundant area value=%d \n", *((uint8_t *)(info->reg+ECC_FIFO_0)+(bch_err_pos[i] >> 3) - bank_size));
				}
			} else {
				if((bch_err_pos[i] >> 3) < bank_size) {
					//printk(KERN_NOTICE "area value=%d ", info->dmabuf[bank_size* bank + (bch_err_pos[i] >> 3)]);
					if (info->oob_ecc_error == 0x50 && bank == 0)
						bit_correct(&info->dmabuf[bank_size * (ECC_size.banks-1) + (bch_err_pos[i] >> 3)], bch_err_pos[i] & 0x07);
					else
						bit_correct(&info->dmabuf[bank_size* bank + (bch_err_pos[i] >> 3)], bch_err_pos[i] & 0x07);
					//printk(KERN_NOTICE "area value=%d \n", info->dmabuf[bank_size* bank + (bch_err_pos[i] >> 3)]);
				}
			}

			#ifdef NAND_DEBUG
			printk(KERN_NOTICE "in nfc_wait_idle(): data area %xth ecc error position is byte%d bit%d\n",
			i, bank_size * bank + (bch_err_pos[i] >> 3), (bch_err_pos[i] & 0x07));
			#endif
		}
	} /* end of if ((bank_stat1 & 0x101) */
	/* continue read next bank and calc BCH ECC */
	writew(readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT1)|(ERR_CORRECT | BCH_ERR),
	info->reg + WMT_NFC_ECC_BCH_INT_STAT1);
	writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
	info->reg + WMT_NFC_ECC_BCH_CTRL);
}

void bch_redunt_ecc_correct(struct mtd_info *mtd)
{
	int i;
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	struct nand_chip *this = mtd->priv;
	unsigned int bank_stat1, bank_stat2, bch_ecc_idx, bank, ecc_engine;
	unsigned int bank_size;
	struct ECC_size_info ECC_size;

	
	/* BCH ECC err process */
	bank_stat2 = readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT2);
	bch_ecc_idx = bank_stat2 & BCH_ERR_CNT;

	/* bank = (bank_stat2 & 0x700) >> 8; */
	bank_stat1 = readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT1);
	bch_ecc_idx = bank_stat2 & BCH_ERR_CNT;
	bank = (bank_stat2 & 0xF00) >> 8;
	if ((bank_stat1 & 0x101) == (ERR_CORRECT | BCH_ERR)) {
		/* mtd->ecc_stats.corrected += (bank_stat2 & BCH_ERR_CNT);*/
		/* BCH ECC correct */
		/* for reduntant area */
		ecc_engine = info->ECC_mode;
		ECC_size.ecc_engine = ecc_engine;
		calculate_ECC_info(mtd, &ECC_size);
		bank_size = ECC_size.bank_size;
		if (bch_ecc_idx >= BCH_ERR_CNT) {
			writew(readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT1)|(ERR_CORRECT | BCH_ERR),
			info->reg + WMT_NFC_ECC_BCH_INT_STAT1);
			writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
			info->reg + WMT_NFC_ECC_BCH_CTRL);
			if (info->isr_cmd == 0x50) {
				info->oob_ecc_error = 0x50;
				printk("red re oob uncor err cur_page=%d\n",info->cur_page);
				return;
			}
			if (info->isr_cmd == 0x0 && mtd->dwRetry && this->cur_chip) {
				info->data_ecc_uncor_err = 1;
				printk(KERN_ERR
				"last bank data area uncorrected err cur_page=%d use retry\n",info->cur_page);
				return;
			} else
				printk(KERN_ERR
				"last bank data area uncorrected err cur_page=%d no retry\n",info->cur_page);
			mtd->ecc_stats.failed++;
			//while(bank_stat1);
			return;
			/* return -4;*/  /* uncorrected err */
		}
		/* mtd->ecc_stats.corrected += (bank_stat2 & BCH_ERR_CNT);*/
		/* BCH ECC correct */
		#ifdef NAND_DEBUG
		printk(KERN_NOTICE "reduntant %d bit corrected error\n", bch_ecc_idx);
		#endif
		for (i = 0; i < bch_ecc_idx; i++) {
			bch_err_pos[i] = (readw(info->reg +	WMT_NFC_ECC_BCH_ERR_POS1 + 2*i) & BCH_ERRPOS0);
			//printk(KERN_NOTICE "data area byte=%d corrected err on bank %d bs=%d, banks=%d\n", bch_err_pos[i]>>3, bank, bank_size,ECC_size.banks);
			if((bch_err_pos[i] >> 3) < bank_size) {
				if (info->oob_ecc_error == 0x50 && bank == 0)
					bit_correct(&info->dmabuf[bank_size * (ECC_size.banks-1) + (bch_err_pos[i] >> 3)], bch_err_pos[i] & 0x07);
				else
					printk("read last bank error \n");
			} else if ((bch_err_pos[i] >> 3) < (bank_size + 24)) {//oob area of last bank
				//printk(KERN_NOTICE "redundant area value=%d ", *((uint8_t *)(info->reg+ECC_FIFO_0)+(bch_err_pos[i] >> 3) - bank_size));
				bit_correct((uint8_t *)(info->reg+ECC_FIFO_0)+(bch_err_pos[i] >> 3) - bank_size, (bch_err_pos[i] & 0x07));
				//printk(KERN_NOTICE "redundant area value=%d \n", *((uint8_t *)(info->reg+ECC_FIFO_0)+(bch_err_pos[i] >> 3) - bank_size));
			}

			#ifdef NAND_DEBUG
			printk(KERN_NOTICE "in nfc_wait_idle(): data area %xth ecc error position is byte%d bit%d\n",
			i, bank_size * bank + (bch_err_pos[i] >> 3), (bch_err_pos[i] & 0x07));
			#endif
		}
	}
	/* continue read next bank and calc BCH ECC */
	writew(readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT1)|(ERR_CORRECT | BCH_ERR),
	info->reg + WMT_NFC_ECC_BCH_INT_STAT1);
	writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
	info->reg + WMT_NFC_ECC_BCH_CTRL);
}

/*
*   [Routine Description]
*	read status
*   [Arguments]
*	cmd : nand read status command
*   [Return]
*	the result of command
*/
static int wmt_read_nand_status(struct mtd_info *mtd, unsigned char cmd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	int cfg = 0, status = -1;
	unsigned int b2r_stat;

	writeb(cmd, info->reg + WMT_NFC_COMPORT0);
	cfg = DPAHSE_DISABLE|NFC2NAND|(1<<1);

	b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
	writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);

	writew(cfg|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);
	status = wmt_wait_cmd_ready(mtd);
	if (status) {
		printk(KERN_ERR "NFC command transfer1 is not ready\n");
		writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
		info->reg + WMT_NFC_ECC_BCH_CTRL);
		return status;
	}
	b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
	writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);

	cfg = SING_RW|NAND2NFC;
	writew(cfg|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);

	status = wmt_wait_cmd_ready(mtd);
	if (status) {
		printk(KERN_ERR "NFC command transfer2 is not ready\n");
		writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
		info->reg + WMT_NFC_ECC_BCH_CTRL);
		return status;
	}
	status = wmt_nfc_transfer_ready(mtd);
	/* status = wmt_nand_wait_idle(mtd);*/
	if (status) {
		printk(KERN_ERR "NFC IO transfer is not ready\n");
		writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
		info->reg + WMT_NFC_ECC_BCH_CTRL);
		/*print_nand_register(mtd);*/
		return status;
	}
		 /* return read status  */
	/*   return readb(info->reg + WMT_NFC_DATAPORT) & 0xff;*/
	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "read status is %x\n", readb(info->reg + WMT_NFC_DATAPORT) & 0xff);
	#endif
	info->datalen = 0;
	info->dmabuf[0] = readb(info->reg + WMT_NFC_DATAPORT) & 0xff;
	status = info->dmabuf[0];
	return status;
}


/* data_flag = 0:  set data ecc fifo */
static int wmt_nfc_dma_cfg(struct mtd_info *mtd, unsigned int len, unsigned int wr,
int data_flag, int Nbank)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	int status;
	unsigned long *ReadDesc, *WriteDesc;
	ReadDesc = (unsigned long *)(info->dmabuf + mtd->writesize + mtd->oobsize
	+ (16-(mtd->oobsize)%16) + 0x100);
	WriteDesc = (unsigned long *)(info->dmabuf + mtd->writesize + mtd->oobsize
	+ (16-(mtd->oobsize)%16) + 0x200);
	/*
	printk(KERN_ERR "info->dmabuf = 0x%x\r\n", (unsigned int) info->dmabuf);
	printk(KERN_ERR "info->dmaaddr = 0x%x\r\n", (unsigned int) info->dmaaddr);
	printk(KERN_ERR "ReadDesc addr = 0x%x\r\n", (unsigned int) ReadDesc);
	printk(KERN_ERR "WriteDesc addr = 0x%x\r\n", (unsigned int) WriteDesc);
	*/

	if (len == 0)	{
		printk(KERN_ERR "DMA transfer length = 0\r\n");
		return 1;
	}
	if (data_flag == 0) {
		/* data:  set data ecc fifo */
		if (mtd->writesize == 512) {
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_0));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_1));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_2));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_3));
		} else { /* pagesize = 2048 or 4096 */
			if (mtd->writesize == 2048)
				writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & 0xF7, info->reg + WMT_NFC_CALC_CTRL);
			else { /*if (NAND_PAGE_SIZE == 4096)*/
				writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & 0xF7, info->reg + WMT_NFC_CALC_CTRL);

				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_0));
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_1));
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_2));
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_3));
		
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_4));
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_5));
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_6));
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_7));
		
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_8));
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_9));
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_a));
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_b));
		
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_c));
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_d));
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_e));
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_f));
				writeb(readb(info->reg + WMT_NFC_CALC_CTRL) | 0x08, info->reg + WMT_NFC_CALC_CTRL);
			}
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_0));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_1));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_2));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_3));
	
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_4));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_5));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_6));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_7));
	
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_8));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_9));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_a));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_b));
	
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_c));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_d));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_e));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_f));
			writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & 0xF7, info->reg + WMT_NFC_CALC_CTRL);
		}
	} else if (data_flag == 1) {
		/* reduntant area:  set reduntant data ecc fifo  BCH ECC */
		writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & 0xF7, info->reg + WMT_NFC_CALC_CTRL);
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_0));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_1));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_2));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_3));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_4));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_5));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_6));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_7));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_8));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_9));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_a));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_b));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_c));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_d));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_e));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_f));
	} else if (data_flag == 2) {
		/* reduntant area:  set reduntant data ecc fifo  Harming ECC */
		writel(readl(info->reg + ECC_FIFO_c) | 0xffff0000, info->reg + ECC_FIFO_c);
	}
	writew(len - 1, info->reg + WMT_NFC_DMA_COUNTER);
	if (readl(info->reg + NFC_DMA_ISR) & NAND_PDMA_IER_INT_STS)
		writel(NAND_PDMA_IER_INT_STS, info->reg + NFC_DMA_ISR);

	if (readl(info->reg + NFC_DMA_ISR) & NAND_PDMA_IER_INT_STS) {
		printk(KERN_ERR "PDMA interrupt status can't be clear ");
		printk(KERN_ERR "NFC_DMA_ISR = 0x%8.8x \n", (unsigned int)readl(info->reg + NFC_DMA_ISR));
	}

	status = nand_init_pdma(mtd);
	if (status)
		printk(KERN_ERR "nand_init_pdma fail status = 0x%x", status);
	nand_alloc_desc_pool((wr) ? WriteDesc : ReadDesc);
	/*nand_init_short_desc((wr)?WriteDesc : ReadDesc, len, (unsigned long *)buf);*/
	if (info->oob_ecc_error == 0x50 && len != 1 && len != 3) {
		nand_init_long_desc((wr) ? WriteDesc : ReadDesc, len, (unsigned long *)info->last_bank_dmaaddr, 0, 1);
		if (len != 1024 && len != 512)
			printk("oob_ecc_error len!=1024, len=%d \n", len);
	} else
		nand_init_long_desc((wr) ? WriteDesc : ReadDesc, len, (unsigned long *)info->dmaaddr , 0, 1);
	/*printk(KERN_ERR "dma wr=%d, len=0x%x\n", wr, len);*/

	nand_config_pdma(mtd,
	(wr) ? (unsigned long *)(info->dmaaddr + mtd->writesize + mtd->oobsize + (16-(mtd->oobsize)%16) + 0x200)
	: (unsigned long *)(info->dmaaddr + mtd->writesize + mtd->oobsize + (16-(mtd->oobsize)%16) + 0x100), wr);

	return 0;
}

int nand_init_pdma(struct mtd_info *mtd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);

	writel(NAND_PDMA_GCR_SOFTRESET, info->reg + NFC_DMA_GCR);
	writel(NAND_PDMA_GCR_DMA_EN, info->reg + NFC_DMA_GCR);
	if (readl(info->reg + NFC_DMA_GCR) & NAND_PDMA_GCR_DMA_EN)
		return 0;
	else
		return 1;
}


int nand_free_pdma(struct mtd_info *mtd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	writel(0, info->reg + NFC_DMA_DESPR);
	writel(0, info->reg + NFC_DMA_GCR);
	return 0;
}


int nand_alloc_desc_pool(unsigned long *DescAddr)
{
	memset(DescAddr, 0x00, 0x100);
	return 0;
}

int nand_init_short_desc(unsigned long *DescAddr, unsigned int ReqCount, unsigned long *BufferAddr)
{
	struct _NAND_PDMA_DESC_S *CurDes_S;
	CurDes_S = (struct _NAND_PDMA_DESC_S *) DescAddr;
	CurDes_S->ReqCount = ReqCount;
	CurDes_S->i = 1;
	CurDes_S->end = 1;
	CurDes_S->format = 0;
	CurDes_S->DataBufferAddr = (unsigned long)BufferAddr;
	return 0;
}

int nand_init_long_desc(unsigned long *DescAddr, unsigned int ReqCount, unsigned long *BufferAddr,
unsigned long *BranchAddr, int End)
{
	struct _NAND_PDMA_DESC_L *CurDes_L;
	CurDes_L = (struct _NAND_PDMA_DESC_L *) DescAddr;
	CurDes_L->ReqCount = ReqCount;
	CurDes_L->i = 0;
	CurDes_L->format = 1;
	CurDes_L->DataBufferAddr = (unsigned long)BufferAddr;
	CurDes_L->BranchAddr = (unsigned long)BranchAddr;
	if (End) {
		CurDes_L->end = 1;
		CurDes_L->i = 1;
	}

	return 0;
}
/*
int nand_config_desc(unsigned long *DescAddr, unsigned long *BufferAddr, int Blk_Cnt)
{
	int i = 0 ;
	unsigned long *CurDes = DescAddr;

	nand_alloc_desc_pool(CurDes);


	for (i = 0 ; i < 3 ; i++) {
		nand_init_short_desc(CurDes, 0x80, BufferAddr);
		BufferAddr += (i * 0x80);
		CurDes += (i * sizeof(NAND_PDMA_DESC_S));
	}
	if (Blk_Cnt > 1) {
		nand_init_long_desc(CurDes, 0x80, BufferAddr, CurDes + sizeof(NAND_PDMA_DESC_L), 0);
		BufferAddr += (i * 0x80);
		CurDes += (i * sizeof(NAND_PDMA_DESC_L));

		nand_init_long_desc(CurDes, (Blk_Cnt - 1) * 512, BufferAddr,
		CurDes + sizeof(NAND_PDMA_DESC_L), 1);
	} else {
		nand_init_long_desc(CurDes, 0x80, BufferAddr, CurDes + sizeof(NAND_PDMA_DESC_L), 1);
	}

	return 0;
}
*/

int nand_config_pdma(struct mtd_info *mtd, unsigned long *DescAddr, unsigned int dir)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	if (info->isr_cmd != NAND_SET_FEATURE && info->isr_cmd != 0x37 && info->isr_cmd != 0x36)
		writel(NAND_PDMA_IER_INT_EN, info->reg + NFC_DMA_IER);
	writel((unsigned long)DescAddr, info->reg + NFC_DMA_DESPR);
	if (dir == NAND_PDMA_READ)
		writel(readl(info->reg + NFC_DMA_CCR)|NAND_PDMA_CCR_peripheral_to_IF,
		info->reg + NFC_DMA_CCR);
	else
		writel(readl(info->reg + NFC_DMA_CCR)&(~NAND_PDMA_CCR_IF_to_peripheral),
		info->reg + NFC_DMA_CCR);

	/*mask_interrupt(IRQ_NFC_DMA);*/
	writel(readl(info->reg + NFC_DMA_CCR)|NAND_PDMA_CCR_RUN, info->reg + NFC_DMA_CCR);
	/*printk(KERN_ERR "NFC_DMA_CCR = 0x%8.8x\r\n", readl(info->reg + NFC_DMA_CCR));*/
	/*print_nand_register(mtd);*/
	return 0;
}

int nand_pdma_handler(struct mtd_info *mtd)
{
	unsigned long status = 0;
	unsigned long count = 0;
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);

	count = 0x100000;
#if 0
	/*	 polling CSR TC status	*/
	if (!(readl(info->reg + NFC_DMA_CCR)|NAND_PDMA_CCR_peripheral_to_IF)) {
	do {
		count--;
		if (readl(info->reg + NFC_DMA_ISR) & NAND_PDMA_IER_INT_STS) {
			status = readl(info->reg + NFC_DMA_CCR) & NAND_PDMA_CCR_EvtCode;
			writel(readl(info->reg + NFC_DMA_ISR)&NAND_PDMA_IER_INT_STS, info->reg + NFC_DMA_ISR);
			printk(KERN_ERR "NFC_DMA_ISR = 0x%8.8x\r\n",
			(unsigned int)readl(info->reg + NFC_DMA_ISR));
			break;
		}
		if (count == 0) {
			printk(KERN_ERR "PDMA Time Out!\n");
			printk(KERN_ERR "NFC_DMA_CCR = 0x%8.8x\r\n",
			(unsigned int)readl(info->reg + NFC_DMA_CCR));
			/*print_nand_register(mtd);*/
			count = 0x100000;
			/*break;*/
		}
	} while (1);
} else
#endif
	status = readl(info->reg + NFC_DMA_CCR) & NAND_PDMA_CCR_EvtCode;
	writel(readl(info->reg + NFC_DMA_ISR)&NAND_PDMA_IER_INT_STS, info->reg + NFC_DMA_ISR);
	if (status == NAND_PDMA_CCR_Evt_ff_underrun)
		printk(KERN_ERR "PDMA Buffer under run!\n");

	if (status == NAND_PDMA_CCR_Evt_ff_overrun)
		printk(KERN_ERR "PDMA Buffer over run!\n");

	if (status == NAND_PDMA_CCR_Evt_desp_read)
		printk(KERN_ERR "PDMA read Descriptor error!\n");

	if (status == NAND_PDMA_CCR_Evt_data_rw)
		printk(KERN_ERR "PDMA read/write memory descriptor error!\n");

	if (status == NAND_PDMA_CCR_Evt_early_end)
		printk(KERN_ERR "PDMA read early end!\n");

	if (count == 0) {
		printk(KERN_ERR "PDMA TimeOut!\n");
		while (1)
			;
	}
	return 0;
}

int nand_get_feature(struct mtd_info *mtd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	unsigned int cfg = 0, i = 0;
	int status = -1;

	writeb(0xEE, info->reg + WMT_NFC_COMPORT0);
	writeb(0x01, info->reg + WMT_NFC_COMPORT1_2);
	cfg = DPAHSE_DISABLE|(0x02<<1);
	writew(cfg|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);

	status = wmt_wait_cmd_ready(mtd);

	if (status) {
		printk(KERN_ERR "in nand_get_feature(): wait cmd is not ready\n");
		writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
		info->reg + WMT_NFC_ECC_BCH_CTRL);
		return status;
	}
	cfg = NAND2NFC|SING_RW;
	for (i = 0; i < 4; i++) {
		writew(cfg|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);
		status = wmt_wait_cmd_ready(mtd);
		if (status)
				return status;
		status = wmt_nfc_transfer_ready(mtd);
		if (status) {
			printk(KERN_ERR "in nand_get_feature(): wait transfer cmd is not ready\n");
			return status;
		}
		info->dmabuf[i] = readb(info->reg + WMT_NFC_DATAPORT) & 0xff;

		#ifdef NAND_DEBUG
			printk(KERN_NOTICE "nand feature is %x\n", readb(info->reg + WMT_NFC_DATAPORT));
		#endif
	}
	info->datalen = 0;
	return 0;
}

int nand_set_feature(struct mtd_info *mtd, int cmd, int addrss, int value)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	unsigned int cfg = 0, len = 4;
	int status = -1;
	DECLARE_COMPLETION(complete);
	//unsigned char id[4] = {value, 0, 0, 0};
	info->dmabuf[0] = value;
	info->dmabuf[1] = 0;
	info->dmabuf[2] = 0;
	info->dmabuf[3] = 0;
	info->isr_cmd = cmd;
	info->done_data = &complete;
	//nfc->reg->NFCR23 |= USE_SW_ECC;
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | DIS_BCH_ECC, info->reg + WMT_NFC_ECC_BCH_CTRL);
	//printk("set feature cycle1\n");

	//nfc->reg->NFCR13 = 0x0F;
	writeb(0x0F, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
	//nfc->reg->NFCRb |= B2R; /* write to clear */
	writel(B2R,	info->reg + WMT_NFC_HOST_STAT_CHANGE);
	if (readb(info->reg + WMT_NFC_HOST_STAT_CHANGE) & B2R)
		printk("nand get feature B2R can't clear\n");
	//nfc->reg->NFCR13 = 0x07;
	writeb(0x07, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);

	//printk("set feature cycle2\n");
	
	wmt_nfc_dma_cfg(mtd, len, 1, 0, -1);
	//print_nand_register(nfc);

	writeb(cmd, info->reg + WMT_NFC_COMPORT0);
	writeb(addrss, info->reg + WMT_NFC_COMPORT1_2);
	cfg = (0x02<<1);
	//print_nand_register(mtd);
	//printk("set feature cycle trigg = 0x%x\n", cfg|NFC_TRIGGER|OLD_CMD);
	writew(cfg|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);
	//print_nand_register(mtd);
	//printk("set feature cycle3\n");
	wait_for_completion_timeout(&complete, NFC_TIMEOUT_TIME);
	status = NFC_WAIT_IDLE(mtd);
	if (status) {
		printk("get feature nand flash idle time out\n");
		return status;
	}

	writeb(0x80, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
	//printk("set feature cycle5\n");
	status = wmt_nfc_transfer_ready(mtd);
	/* status = wmt_nand_wait_idle(mtd);*/
	if (status) {
		printk(KERN_ERR "NFC IO transfer is not ready\n");
		/*print_nand_register(mtd);*/
		return status;
	}

	status = NFC_WAIT_IDLE(mtd);
	if (status) {
		printk("set feature nand flash idle time out\n");
		return status;
	}

	status = nand_pdma_handler(mtd);
	nand_free_pdma(mtd);
	if (status)
		printk(KERN_ERR "check write pdma handler status= %x \n", status);
	//nfc->reg->NFCR23 &= ~USE_SW_ECC;
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) & ~DIS_BCH_ECC, info->reg + WMT_NFC_ECC_BCH_CTRL);
	return status;
}

int get_parameter(struct mtd_info *mtd, uint8_t *buf, uint8_t *addr, int size)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	unsigned int cfg = 0, len = 1;
	int i, status = -1, regc = size;
	unsigned char *FIFO = (unsigned char *) (info->reg+ECC_FIFO_c);
	
	//nfc->reg->NFCR23 |= USE_SW_ECC;
	//writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | DIS_BCH_ECC, info->reg + WMT_NFC_ECC_BCH_CTRL);
	//nfc->reg->NFCR13 = 0x07;
	//writeb(0x07, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
	
	for (i = 0; i < regc;i++) {
		//DECLARE_COMPLETION(complete);
		info->isr_cmd = 0x37;
		//info->done_data = &complete;
		//printk("hynix retry get c1\n");
		//nfc->reg->NFCR13 = 0x0F;
		writeb(0x0F, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
		//nfc->reg->NFCRb |= B2R; /* write to clear */
		writel(B2R,	info->reg + WMT_NFC_HOST_STAT_CHANGE);
		if (readb(info->reg + WMT_NFC_HOST_STAT_CHANGE) & B2R)
			printk("B2R can't clear\n");
	
		//printk("hynix retry get c2\n");
		wmt_nfc_dma_cfg(mtd, len, 0, 0, -1);
		//print_nand_register(nfc);
		writeb(readb(info->reg + WMT_NFC_CALC_CTRL) | HIGH64FIFO,	info->reg + WMT_NFC_CALC_CTRL);
		if (i == 0) {
			FIFO[0] = 0x37;
			FIFO[1] = addr[0];
			//nfc->reg->NFCRc = 0x00020001;
			writel(0x00020001,	info->reg + WMT_NFC_SMC_DMA_COUNTER);
			cfg = (0x02<<1);
		} else {
			FIFO[0] = addr[i];
			// set address latch ALE(high) and CLE(lower)	
			//nfc->reg->NFCRc = 0x00010000;
			writel(0x00010000,	info->reg + WMT_NFC_SMC_DMA_COUNTER);
			cfg = (0x01<<1);
		}
		//print_nand_register(mtd);
		//printk("hynix get retry param trigg = 0x%x\n", NAND2NFC|cfg|NFC_TRIGGER);
		//nfc->reg->NFCR1 = NAND2NFC|cfg|NFC_TRIGGER;	 /* cfg & start*/
		writew(NAND2NFC|cfg|NFC_TRIGGER, info->reg + WMT_NFC_COMCTRL);
		//print_nand_register(mtd);
		//wait_for_completion_timeout(&complete, NFC_TIMEOUT_TIME);
		//j = 0;
		while (!readl(info->reg + NFC_DMA_ISR)&NAND_PDMA_IER_INT_STS);
		status = NFC_WAIT_IDLE(mtd);
		if (status) {
			printk("get feature nand flash idle time out\n");
			return status;
		}
		writeb(0x80, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
		//printk("set feature cycle5\n");
		status = wmt_nfc_transfer_ready(mtd);
		/* status = wmt_nand_wait_idle(mtd);*/
		if (status) {
			printk(KERN_ERR "NFC IO transfer is not ready\n");
			/*print_nand_register(mtd);*/
			return status;
		}

		status = NFC_WAIT_IDLE(mtd);
		if (status) {
			printk("set feature nand flash idle time out\n");
			return status;
		}

		status = nand_pdma_handler(mtd);
		nand_free_pdma(mtd);
		if (status)
			printk(KERN_ERR "check write pdma handler status= %x \n", status);
	//	printk("para info->dmabuf[0]= 0x%x\n", info->dmabuf[0]);
		buf[i] = info->dmabuf[0];
	}
	//nfc->reg->NFCR23 &= ~USE_SW_ECC;
	//writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) & ~DIS_BCH_ECC, info->reg + WMT_NFC_ECC_BCH_CTRL);
	writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & ~HIGH64FIFO,	info->reg + WMT_NFC_CALC_CTRL);
	return status;
}

int hynix_get_parameter(struct mtd_info *mtd, int mode)
{
	struct nand_chip *this = mtd->priv;
	struct nand_read_retry_param *cur_chip = this->cur_chip;
	unsigned char buf[16] = {0};
	unsigned char *offset = NULL;
	unsigned char *set_value = NULL;
	unsigned char *def_value = NULL;
	unsigned int reg_num;
	int i = 0, j = 0;
	int rc = -1;

	if (mode == ESLC_MODE) {
		reg_num = cur_chip->eslc_reg_num;
		offset = cur_chip->eslc_offset;
		def_value = cur_chip->eslc_def_value;
		set_value = cur_chip->eslc_set_value;
	} else if(mode == READ_RETRY_MODE) {
		reg_num = cur_chip->retry_reg_num;
		offset = cur_chip->retry_offset;
		def_value = cur_chip->retry_def_value;
	} else {
		printk("Not support this mode %d\n", mode);
		return rc;
	}

	rc = get_parameter(mtd, buf, offset, reg_num);
	if(rc != 0)
		return rc;

	if(mode == ESLC_MODE) {
		if((def_value[reg_num] != 0xff) && (def_value[reg_num + 1] != 0xff)) {
			for(i = 0; i < reg_num; i++) {
				def_value[i] = buf[i];
				set_value[i] += buf[i];
			}
			def_value[reg_num] = 0xff;
			def_value[reg_num + 1] = 0xff;
//			printk("ESLC: ");
//			print_nand_buffer(buf, reg_num);
		} //else {
//			printk("ESLC Current: ");
//			print_nand_buffer(buf, reg_num);
//		}
	} else if(mode == READ_RETRY_MODE) {
		if((def_value[reg_num] != 0xff) && (def_value[reg_num + 1] != 0xff)) {
			for(i = 0; i < reg_num; i++)
				def_value[i] = buf[i];
			def_value[reg_num] = 0xff;
			def_value[reg_num + 1] = 0xff;
//			printk("Retry : ");
//			print_nand_buffer(buf, reg_num);
		} else {
//			printk("Retry Current: ");
//			print_nand_buffer(buf, reg_num);
			//printk("\n");
            for(j = 0; j < cur_chip->total_try_times; j++) {
                for(i = 0; i < reg_num; i++) {
                    if(buf[i] != cur_chip->retry_value[j*reg_num+i])
                        break;
                }
                if(i == reg_num) {
                    cur_chip->cur_try_times = j;
                    printk("Get current try times %d from current register.\n", j);
                    break;
                } else
	                printk("No found! current try times %d from current register.\n", cur_chip->cur_try_times);

            }

		}
	}
	return rc;
}

int write_bytes_cmd(struct mtd_info *mtd, int cmd_cnt, int addr_cnt, int data_cnt, uint8_t *cmd, uint8_t *addr, uint8_t *data)
{
	int i, status = 0;
	unsigned int cmd_addr_cycle = 0, cfg = 0, cfg_bit8 = 0, counter = 10000;
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	unsigned char *FIFO = (unsigned char *) (info->reg+ECC_FIFO_c);


	writeb(0x0F, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);

	status = NFC_WAIT_IDLE(mtd);
	if (status) {
		printk("nand flash idle time out\n");
		return status;
	}

	if (data_cnt > 0) {
		info->isr_cmd = 0x36;
		memcpy(info->dmabuf, data, data_cnt);
		wmt_nfc_dma_cfg(mtd, data_cnt, 1, 0, -1);
	}
	writeb(readb(info->reg + WMT_NFC_CALC_CTRL) | HIGH64FIFO,	info->reg + WMT_NFC_CALC_CTRL);
	for (i = 0; i < cmd_cnt; i++) {
		FIFO[i] = cmd[i];
		cmd_addr_cycle |= (1<<i);
	}
	for (i = cmd_cnt; i < (addr_cnt+cmd_cnt); i++) {
		FIFO[i] = addr[i-cmd_cnt];
		cmd_addr_cycle |= (1<<(i+16));
	}
	writel(cmd_addr_cycle,	info->reg + WMT_NFC_SMC_DMA_COUNTER);
	#ifdef RETRY_DEBUG
	//printk("NFCRc=0x%x ", cmd_addr_cycle);
	printk("FIFO = ");
	for (i = 0; i < (addr_cnt+cmd_cnt); i++)
		printk("0x%x ", FIFO[i]);
	if (data_cnt > 0) {
		printk("data = ");
		for (i = 0; i < data_cnt; i++) {
			printk("0x%x ", data[i]);
		}
		printk("\n");
	} else
		printk("\n");
	#endif
/*	printk("FIFO = ");
	for (i = 0; i < (addr_cnt+cmd_cnt); i++)
		printk("0x%x ", FIFO[i]);
	if (data_cnt > 0) 
		printk("data = 0x%x\n", data[0]);*/
	//printk(" NFCRc=0x%x\n", cmd_addr_cycle);
	cfg = ((cmd_cnt + addr_cnt)&0x7)<<1;
	cfg_bit8 = (((cmd_cnt + addr_cnt)&0x18)>>3)<<8;

	if (data_cnt == 0)
		cfg |= DPAHSE_DISABLE;

	writew(cfg_bit8|cfg|NFC_TRIGGER, info->reg + WMT_NFC_COMCTRL);

//print_nand_register(mtd);
	status = wmt_nfc_transfer_ready(mtd);
	if (status) {
		writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & ~HIGH64FIFO,	info->reg + WMT_NFC_CALC_CTRL);
		printk(KERN_ERR "NFC IO transfer is not ready\n");
			/*print_nand_register(mtd);*/
		goto go_fail;
	}
	status = NFC_WAIT_IDLE(mtd);
	if (status) {
		printk("retry c1 wait idle time out\n");
		goto go_fail;
	}
	if (cmd_cnt > 0 && cmd)
		if (cmd[0] == NAND_CMD_RESET) {
			status = wmt_nand_ready(mtd);
			if (status) {
				printk(KERN_ERR "Reset err, nand device is not ready\n");
				writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
				info->reg + WMT_NFC_ECC_BCH_CTRL);
			}
		}
	if (data_cnt > 0)
		while (!readl(info->reg + NFC_DMA_ISR)&NAND_PDMA_IER_INT_STS) {
			if (counter <= 0) {
				break;
			}
			counter--;
		}
	if (data_cnt > 0) {
		status = nand_pdma_handler(mtd);
		nand_free_pdma(mtd);
		if (status) {
			printk(KERN_ERR "check write pdma handler status= %x \n", status);
			goto go_fail;
		}
	}

go_fail:
	writeb(0x80, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
	writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & ~HIGH64FIFO,	info->reg + WMT_NFC_CALC_CTRL);

	return status;
}


int set_parameter(struct mtd_info *mtd, unsigned char *buf, unsigned char *offset, int regn)
{
	int i, status = -1, regc = regn;
	unsigned char cmd[2] = {0x36, 0x16};

	status = write_bytes_cmd(mtd, 1, 1, 1, (uint8_t *)&cmd[0], offset, buf);
	if (status)
		printk("hynix_set read retry reg: phase 0 fail");
	for (i = 1; i < regc; i++) {
		status = write_bytes_cmd(mtd, 0, 1, 1, NULL, &offset[i], &buf[i]);
		if (status)
			printk("hynix_set read retry reg: phase %d fail", i);
	}
	status = write_bytes_cmd(mtd, 1, 0, 0, (uint8_t *)&cmd[1], NULL, NULL);
	if (status)
		printk("load_hynix_opt_reg: phase 3 fail");
	
	return status;
}

void dummy_read(struct mtd_info *mtd)
{
	int status = -1;
	uint8_t cmd[2] = {0x00, 0x30}, addr[5] = {0, 0, 0, 0, 0};

	status = write_bytes_cmd(mtd, 1, 5, 0, &cmd[0], addr, NULL);
	if (status)
		printk("dummy read cmd(00) + addr fail\n");
	status = write_bytes_cmd(mtd, 1, 0, 0, &cmd[1], NULL, NULL);
	if (status)
		printk("dummy read cmd(0x30) fail\n");

	/* check busy to ready status*/
	status = wmt_nand_ready(mtd);
	if (status) {
		printk(KERN_ERR "NFC check B2R time out\n");
	}
}

int hynix_set_parameter(struct mtd_info *mtd, int mode, int def_value)
{
	struct nand_chip *this = mtd->priv;
	struct nand_read_retry_param *cur_chip = this->cur_chip;
	unsigned char *offset = NULL;
	unsigned char *set_value = NULL;
	unsigned int reg_num;
	int rc = -1;


	if (mode == ESLC_MODE) {
		reg_num = cur_chip->eslc_reg_num;
		offset = cur_chip->eslc_offset;
		if (def_value == ECC_ERROR_VALUE) {
			set_value = cur_chip->eslc_set_value;
		} else {
			set_value = cur_chip->eslc_def_value;
		}
	} else {
		reg_num = cur_chip->retry_reg_num;
		offset = cur_chip->retry_offset;
		if (def_value == ECC_ERROR_VALUE) {
			cur_chip->cur_try_times++;
			if (cur_chip->cur_try_times >= cur_chip->total_try_times)
				cur_chip->cur_try_times = -1;
			if ((cur_chip->cur_try_times >= 0) && (cur_chip->cur_try_times < cur_chip->total_try_times))
				set_value = cur_chip->retry_value + cur_chip->cur_try_times* cur_chip->retry_reg_num;
			else 
				set_value = cur_chip->retry_def_value;

		} else {
			set_value = cur_chip->retry_def_value;
			cur_chip->cur_try_times = -1;
		}
	}

/*
	printk("hynix set value: cur_try_times=%d\n", cur_chip->cur_try_times);
	for(rc = 0; rc < reg_num; rc++)
		printk(" 0x%x:0x%x ", offset[rc], set_value[rc]);
	printk("reg_num = %d\n", reg_num);*/
	
	rc = set_parameter(mtd, set_value, offset, reg_num);
	if(rc) {
		printk("set_parameter fail.\n");
		return rc;
	}

	if(def_value == DEFAULT_VALUE && mode == ESLC_MODE) {
		dummy_read(mtd);
	}

	return rc;
}

int toshiba_pre_condition(struct mtd_info *mtd)
{
	int status = 0;
	unsigned char cmd1[2] = {0x5c, 0xc5};

	status = write_bytes_cmd(mtd, 2, 0, 0, cmd1, NULL, NULL);
	if(status)
		printk("toshiba pre condition cmd1 time out.\n");
	else
		printk("toshiba pre condition OK.\n");

	return status;
}

int toshiba_get_parameter(struct mtd_info *mtd, int mode)
{
	return 0;
}

int toshiba_set_parameter(struct mtd_info *mtd, int mode, int def_mode)
{
	int i, status = -1;
	struct nand_chip *this = mtd->priv;
	struct nand_read_retry_param *cur_chip = this->cur_chip;
	unsigned char cmd2[1] = {0x55};
	unsigned char cmd3[2] = {0x26, 0x5d};
	unsigned char *set_value = NULL;
	unsigned char *offset = NULL;

	if (cur_chip->cur_try_times >= cur_chip->total_try_times)
		cur_chip->cur_try_times = 0;
	set_value = cur_chip->retry_value + cur_chip->cur_try_times*cur_chip->retry_reg_num;
	offset = cur_chip->retry_offset;

	cur_chip->cur_try_times++;
	#ifdef RETRY_DEBUG
	printk("toshiba set cur_try_times=%d\n", cur_chip->cur_try_times);
	#endif
	for (i = 0; i < 4; i++) {
		status = write_bytes_cmd(mtd, 1, 1, 1, cmd2, &offset[i], &set_value[i]);
		if (status)
			printk("toshiba set read retry reg: phase %d fail", i);
	}

  status = write_bytes_cmd(mtd, 2, 0, 0, cmd3, NULL, NULL);
  if (status) {
		printk("pre condition cmd2 time out\n");
	}

	return status;
}

int samsung_get_parameter(struct mtd_info *mtd, int mode)
{
	return 0;
}

int samsung_set_parameter(struct mtd_info *mtd, int mode, int def_mode)
{
	struct nand_chip *this = mtd->priv;
	struct nand_read_retry_param *cur_chip = this->cur_chip;
	unsigned char *offset = NULL;
	unsigned char *set_value = NULL;
	unsigned int reg_num;
	int rc = -1, i;
	uint8_t cmd[1] = {0xA1};
	uint8_t data[3] = {0, 0, 0};

	reg_num = cur_chip->retry_reg_num;
	offset = cur_chip->retry_offset;
	if (def_mode == ECC_ERROR_VALUE) {
		set_value = cur_chip->retry_value + cur_chip->cur_try_times * reg_num;
		cur_chip->cur_try_times++;
	} else {
		set_value = cur_chip->retry_def_value;
		cur_chip->cur_try_times = 0;
	}

	#ifdef RETRY_DEBUG
	printk("samsung set value: cur_try_times=%d\n", cur_chip->cur_try_times);
	for(i = 0; i < reg_num; i++)
		printk(" 0x%x:0x%x ", offset[i], set_value[i]);
	printk("reg_num = %d\n", reg_num);
	#endif
	
	for (i = 0; i < reg_num; i++) {
		data[1] = offset[i];
		data[2] = set_value[i];
		rc = write_bytes_cmd(mtd, 1, 0, 3, cmd, NULL, data);
		if (rc)
			printk("samsung read retry reg: phase %d fail\n", i);
	}
	return rc;
}

int sandisk_get_parameter(struct mtd_info *mtd, int mode)
{
	return 0;
}

int sandisk_set_parameter(struct mtd_info *mtd, int total_try_times, int def_value)
{
	struct nand_chip *this = mtd->priv;
	struct nand_read_retry_param *cur_chip = this->cur_chip;
	unsigned char *offset = NULL;
	unsigned char *set_value = NULL;
	unsigned int reg_num, upper_page = 0;
	int i, rc = -1;
	uint8_t cmd[4] = {0x3B, 0xB9, 0x53, 0x54};
	
	if (total_try_times != (cur_chip->total_try_times&0xFF))
		upper_page = 1;

	reg_num = cur_chip->retry_reg_num;
	offset = cur_chip->retry_offset;
	if (def_value == ECC_ERROR_VALUE) {
		cur_chip->cur_try_times++;
		if (cur_chip->cur_try_times >= total_try_times)
			cur_chip->cur_try_times = -1;
		if ((cur_chip->cur_try_times >= 0) && (cur_chip->cur_try_times < total_try_times)) {
			if (upper_page)
				set_value = cur_chip->retry_value +
				(cur_chip->cur_try_times + (cur_chip->total_try_times&0xFF))* reg_num;
			else
				set_value = cur_chip->retry_value + cur_chip->cur_try_times * reg_num;
		} else 
			set_value = cur_chip->retry_def_value;

	} else {
		set_value = cur_chip->retry_def_value;
		cur_chip->cur_try_times = -1;
	}
#ifdef RETRY_DEBUG
	printk("sandisk set value: upper_page=%d, cur_try_times=%d\n", upper_page, cur_chip->cur_try_times);
	for(i = 0; i < reg_num; i++)
		printk(" 0x%x:0x%x ", offset[i], set_value[i]);
	printk("reg_num = %d\n", reg_num);
#endif
	rc = write_bytes_cmd(mtd, 2, 0, 0, cmd, NULL, NULL);
		if (rc)
			printk("sandisk read retry reg: set cmd fail\n");
	for (i = 0; i < reg_num; i++) {
		rc = write_bytes_cmd(mtd, 1, 1, 1, &cmd[2], &offset[i], &set_value[i]);
		if (rc)
			printk("sandisk set retry reg: phase %d fail\n", i);
	}

	return rc;
}

int sandisk_init_retry_register(struct mtd_info *mtd, struct nand_read_retry_param *cur_chip)
{
	int i,status = -1;
	unsigned char cmd[4] = {0x3B, 0xB9, 0x53, 0x54};
	unsigned char *offset = cur_chip->otp_offset;
	unsigned char *data = cur_chip->otp_data;
	unsigned int regc = cur_chip->otp_len;

	#ifdef RETRY_DEBUG
	printk("set sandisk init retry register offset addr: 0x%x, 0x%x\n", offset[0], offset[1]);
	#endif
	status = write_bytes_cmd(mtd, 2, 0, 0, cmd, NULL, NULL);
	if (status) {
		printk("send sandisk_init_retry_register cmd fail\n");
	}
	for (i = 0; i < regc; i++) {
		status = write_bytes_cmd(mtd, 1, 1, 1, &cmd[2], &offset[i], &data[i]);
		if (status)
			printk("sandisk_init_retry_register : phase %d fail", i);
	}

	return status;	
}

int micron_get_parameter(struct mtd_info *mtd, int mode)
{
	return 0;
}
//#define RETRY_DEBUG
int micron_set_parameter(struct mtd_info *mtd, int mode, int def_mode)
{
	struct nand_chip *this = mtd->priv;
	struct nand_read_retry_param *cur_chip = this->cur_chip;
	unsigned char *offset = NULL;
	unsigned char *set_value = NULL;
	unsigned int reg_num;
	int rc = -1, i;
	uint8_t cmd[1] = {NAND_SET_FEATURE};

	reg_num = cur_chip->retry_reg_num;
	offset = cur_chip->retry_offset;
	if (def_mode == ECC_ERROR_VALUE) {
		set_value = cur_chip->retry_value + cur_chip->cur_try_times * reg_num;
		cur_chip->cur_try_times++;
	} else {
		set_value = cur_chip->retry_def_value;
		cur_chip->cur_try_times = 0;
	}

	#ifdef RETRY_DEBUG
	printk("micron set value: cur_try_times=%d\n", cur_chip->cur_try_times);
	for(i = 0; i < reg_num; i++)
		printk(" 0x%x:0x%x ", offset[i], set_value[i]);
	printk("reg_num = %d\n", reg_num);
	#endif
	
	for (i = 0; i < reg_num; i++) {
		rc = write_bytes_cmd(mtd, 1, 1, 1, cmd, offset, set_value);
		if (rc)
			printk("micron read retry reg: phase %d fail\n", i);
	}
	return rc;
}

static int wmt_nand_read_raw_page(struct mtd_info *mtd, struct nand_chip *chip, int page);
int hynix_get_otp(struct mtd_info *mtd, struct nand_chip *chip)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	struct nand_read_retry_param *cur_chip = chip->cur_chip;
	int i, j, status = -1;
	//unsigned char data[2] = {0x00, 0x4D};
	unsigned char cmd[5] = {0x36, 0x16, 0x17, 0x04, 0x19};
	//unsigned char addr[2] = {0xAE , 0xB0};
	unsigned int page = 0x200;
	unsigned char *buff, reset = NAND_CMD_RESET, retry_end = NAND_CMD_HYNIX_RETRY_END;
	unsigned char *offset = cur_chip->otp_offset;
	unsigned char *data = cur_chip->otp_data;


	printk("get otp offset addr: 0x%x, 0x%x\n", offset[0], offset[1]);
	//chip->cmdfunc(mtd, NAND_CMD_RESET_NO_STATUS_READ, -1, -1);

	status = write_bytes_cmd(mtd, 1, 0, 0, (uint8_t *)&reset, NULL, NULL);
	if (status) {
		printk("load_hynix_opt_reg: reset fail");
	}
	status = write_bytes_cmd(mtd, 1, 1, 1, (uint8_t *)&cmd[0], (uint8_t *)&offset[0], (uint8_t *)&data[0]);
	if (status)
		printk("load_hynix_opt_reg: phase 1 fail");
	status = write_bytes_cmd(mtd, 0, 1, 1, NULL, (uint8_t *)&offset[1], (uint8_t *)&data[1]);
	if (status)
		printk("load_hynix_opt_reg: phase 2 fail");
	status = write_bytes_cmd(mtd, 4, 0, 0, (uint8_t *)&cmd[1], NULL, NULL);
	if (status)
		printk("load_hynix_opt_reg: phase 3 fail");
	//nfc_ecc_set(USE_SW_ECC, nfc);
	//status = HY_nand_read(0, page, buf, 1026, ecc_code, nfc, 0);
	//nfc_ecc_set(USE_SW_ECC, nfc);
	wmt_nand_read_raw_page(mtd, chip, page);
	/*if (status != 0) {
		printk("load_hynix_opt_reg: phase 3 fail status = %d\n", status);
		//return -1;
	}*/
	status = write_bytes_cmd(mtd, 1, 0, 0, (uint8_t *)&reset, NULL, NULL);
	if (status) {
		printk("load_hynix_opt_reg: reset fail");
	}
	status = write_bytes_cmd(mtd, 1, 0, 0, (uint8_t *)&retry_end, NULL, NULL);
	if (status) {
		printk("load_hynix_opt_reg: OTP end 0x38 fail");
	}
	print_nand_buffer((uint8_t *)info->dmabuf, 1040);
	buff = info->dmabuf;
	if (buff[0] > 8 || buff[1] > 8) {
		printk("retry_cmd buff is not big enough for size %d\n", buff[0]*buff[1]);
		return -1;
	}

	cur_chip->total_try_times = buff[0] - 1;
	cur_chip->retry_reg_num = buff[1];
	for (i = 0; i < buff[0]; i++) {
		for (j = 0; j < buff[1]; j++) {
			if (i == 0)
				cur_chip->retry_def_value[j] = buff[j+2];
			else
				cur_chip->retry_value[(i-1)*buff[1]+j] = buff[i*buff[1]+j+2];
			if ((buff[i*buff[1]+j+2] ^ buff[(buff[0]+i)*buff[1]+j+2]) != 0xFF)
				printk("inverse check fail %x %x\n", buff[i*buff[1]+j+2], buff[(buff[0]+i)*buff[1]+j+2]);
		}
		if (i == 0)
			print_nand_buffer(cur_chip->retry_def_value, buff[1]);
		else
			print_nand_buffer(&cur_chip->retry_value[(i-1)*buff[1]], buff[1]);
	}
	cur_chip->retry_def_value[buff[1]] = 0xff;
	cur_chip->retry_def_value[buff[1]+1] = 0xff;


	return 0;
}

int nand_get_para(struct mtd_info *mtd, struct nand_chip *chip)
{
	int ret = 0;
	struct nand_read_retry_param *cur_chip = chip->cur_chip;


	if (cur_chip->get_otp_table) {
		ret = cur_chip->get_otp_table(mtd, chip);
		if (ret) {
			printk("get otp para error\n");
			chip->cur_chip = NULL;
			return ret;
		} else
			printk("get otp retry para end\n");
	} else if (cur_chip->get_parameter) {
		ret = cur_chip->get_parameter(mtd, READ_RETRY_MODE);
		if (ret) {
			printk("get default retry para error\n");
			chip->cur_chip = NULL;
			return ret;
		} else
			printk("get default retry para end\n");
	}

	if (cur_chip->eslc_reg_num) {
		ret = cur_chip->get_parameter(mtd, ESLC_MODE);
		if (ret) {
			printk("get default eslc error\n");
			chip->cur_chip = NULL;
		} else
			printk("get eslc param end\n");
	}

//	print_nand_buffer((uint8_t *)cur_chip, sizeof(chip_table[0]));

	return ret;
}

static int wmt_nand_readID(struct mtd_info *mtd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	unsigned int cfg = 0, i = 0;
	int status = -1;

	writeb(NAND_CMD_READID, info->reg + WMT_NFC_COMPORT0);
	writeb(0x00, info->reg + WMT_NFC_COMPORT1_2);
	cfg = DPAHSE_DISABLE|(0x02<<1);
	writew(cfg|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);

	status = wmt_wait_cmd_ready(mtd);
	/*	status = wmt_nfc_ready(mtd);*/

	if (status) {
		printk(KERN_ERR "in wmt_nand_readID(): wait cmd is not ready\n");
		writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
		info->reg + WMT_NFC_ECC_BCH_CTRL);
		return status;
	}
	cfg = NAND2NFC|SING_RW;
	for (i = 0; i < 6; i++) {
		writew(cfg|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);
		status = wmt_wait_cmd_ready(mtd);
		/*	status = wmt_nfc_ready(mtd);*/
		if (status)
				return status;
		status = wmt_nfc_transfer_ready(mtd);
		/* status = wmt_nand_wait_idle(mtd);*/
		if (status) {
			printk(KERN_ERR "in wmt_nand_readID(): wait transfer cmd is not ready\n");
			return status;
		}
		info->dmabuf[i] = readb(info->reg + WMT_NFC_DATAPORT) & 0xff;

		#ifdef NAND_DEBUG
			printk(KERN_NOTICE "readID is %x\n", readb(info->reg + WMT_NFC_DATAPORT));
		#endif
	}
	info->datalen = 0;
	return 0;
}

/* check flash busy pin is ready => return 1 else return 0 */
static int wmt_device_ready(struct mtd_info *mtd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	return readb(info->reg + WMT_NFC_MISC_STAT_PORT) & 0x01;
}


static void wmt_nand_enable_hwecc(struct mtd_info *mtd, int mode)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	if (mode == hardware_ecc)
		writeb(readb(info->reg + WMT_NFC_MISC_CTRL) & 0xfb, info->reg + WMT_NFC_MISC_CTRL);
	else
		writeb(readb(info->reg + WMT_NFC_MISC_CTRL) | 0x04, info->reg + WMT_NFC_MISC_CTRL);
}

static void print_nand_register(struct mtd_info *mtd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	int j;
	
	for (j = 0; j < 0x130; j += 16)                                                 
			printk(KERN_NOTICE "NFCR%x ~ NFCR%x = 0x%8.8x 0x%8.8x 0x%8.8x 0x%8.8x\r\n",
			j/4, (j+12)/4,                                                             
			readl(info->reg + j + 0),                                                  
			readl(info->reg + j + 4),                                                  
			readl(info->reg + j + 8),                                                  
			readl(info->reg + j + 12));
}

void print_nand_buffer(char *value, unsigned int length)
{
	int j;
	for (j = 0; j < length; j += 16)
		printk(KERN_NOTICE "Row%3.3x:%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x"
		"-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x\n",
		j, value[j+0], value[j+1], value[j+2], value[j+3], value[j+4],
		value[j+5], value[j+6], value[j+7], value[j+8], value[j+9],
		value[j+10], value[j+11], value[j+12], value[j+13], value[j+14], value[j+15]);
}
void print_nand_buffer_int(unsigned int *value, unsigned int length)
{
	int j;
	for (j = 0; j < length; j += 8)
		printk(KERN_NOTICE"Row%3.3x:%8.2x-%8.2x-%8.2x-%8.2x-%8.2x-%8.2x-%8.2x-%8.2x\n",
		j, value[j+0], value[j+1], value[j+2], value[j+3], value[j+4], value[j+5], value[j+6], value[j+7]);
}

static void set_read_addr(struct mtd_info *mtd, unsigned int *address_cycle, int column, int page_addr)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	struct nand_chip *chip = mtd->priv;
	unsigned int addr_cycle = 0;
	
	if (column != -1) {
		writeb(column, info->reg + WMT_NFC_COMPORT1_2);
		addr_cycle++;
		if (mtd->writesize != 512) {
			writeb(column >> 8, (unsigned char *)(info->reg + WMT_NFC_COMPORT1_2) + 1);
			addr_cycle++;
		}
		if (page_addr != -1) {
			if (mtd->writesize != 512) {
				writeb(page_addr, info->reg + WMT_NFC_COMPORT3_4);
				page_addr >>= 8;
				writeb(page_addr, (unsigned char *)(info->reg + WMT_NFC_COMPORT3_4) + 1);
				addr_cycle += 2;
			} else {
				writeb(page_addr, (unsigned char *)(info->reg + WMT_NFC_COMPORT1_2) + 1);
				page_addr >>= 8;
				writeb(page_addr, info->reg + WMT_NFC_COMPORT3_4);
				addr_cycle += 2;
			}

			if (mtd->writesize == 2048) {
				/* One more address cycle for devices > 128MiB */
				if (chip->chipsize > (128 << 20)) {
					page_addr >>= 8;
					if (mtd->writesize != 512)
						writeb(page_addr, info->reg + WMT_NFC_COMPORT5_6);
					else
						writeb(page_addr,
						(unsigned char *)(info->reg + WMT_NFC_COMPORT3_4) + 1);
					addr_cycle++;
				}
			} else if (mtd->writesize == 4096) {
				/* One more address cycle for devices > 256MiB */
				if (chip->chipsize > (256 << 20)) {
					page_addr >>= 8;
					if (mtd->writesize != 512)
						writeb(page_addr, info->reg + WMT_NFC_COMPORT5_6);
					else
						writeb(page_addr,
						(unsigned char *)(info->reg + WMT_NFC_COMPORT3_4) + 1);
					addr_cycle++;
				}
			} else if (mtd->writesize == 8192) {
				/* One more address cycle for devices > 512MiB */
				if (chip->chipsize > (512 << 20)) {
					page_addr >>= 8;
					if (mtd->writesize != 512)
						writeb(page_addr, info->reg + WMT_NFC_COMPORT5_6);
					else
						writeb(page_addr,
						(unsigned char *)(info->reg + WMT_NFC_COMPORT3_4) + 1);
					addr_cycle++;
				}
			} else if (mtd->writesize == 16384) {
				/* One more address cycle for devices > 1024MiB */
				if (chip->chipsize > (1024 << 20)) {
					page_addr >>= 8;
					writeb(page_addr, info->reg + WMT_NFC_COMPORT5_6);
					addr_cycle++;
				}
			} else {/*page size 512*/
				/* One more address cycle for devices > 32MiB */
				if (chip->chipsize > (32 << 20)) {
					page_addr >>= 8;
					if (mtd->writesize != 512)
						writeb(page_addr, info->reg + WMT_NFC_COMPORT5_6);
					else
						writeb(page_addr,
						(unsigned char *)(info->reg + WMT_NFC_COMPORT3_4) + 1);
					addr_cycle++;
				}
			}
		}
	/* } else if (page_addr != -1) {*/
	} else if ((page_addr != -1) && (column == -1)) {
		writeb(page_addr & 0xff, info->reg + WMT_NFC_COMPORT1_2);
		page_addr >>= 8;
		writeb(page_addr & 0xff, (unsigned char *)(info->reg + WMT_NFC_COMPORT1_2) + 1);
		addr_cycle += 2;

		if (mtd->writesize == 2048) {
			/* One more address cycle for devices > 128MiB */
			if (chip->chipsize > (128 << 20)) {
				page_addr >>= 8;
				writeb(page_addr & 0xff,
				info->reg + WMT_NFC_COMPORT3_4);
				addr_cycle++;
			}
		} else if (mtd->writesize == 4096) {
			/* One more address cycle for devices > 256MiB */
			if (chip->chipsize > (256 << 20)) {
				page_addr >>= 8;
				writeb(page_addr & 0xff,
				info->reg + WMT_NFC_COMPORT3_4);
				addr_cycle++;
			}
		} else if (mtd->writesize == 8192) {
			/* One more address cycle for devices > 512MiB */
			if (chip->chipsize > (512 << 20)) {
				page_addr >>= 8;
				writeb(page_addr & 0xff,
				info->reg + WMT_NFC_COMPORT3_4);
				addr_cycle++;
			}
		} else if (mtd->writesize == 16384) {
			/* One more address cycle for devices > 1024MiB */
			if (chip->chipsize > (1024 << 20)) {
				page_addr >>= 8;
				writeb(page_addr & 0xff,
				info->reg + WMT_NFC_COMPORT3_4);
				addr_cycle++;
			}
		} else {/*page size = 512 bytes */
			/* One more address cycle for devices > 32MiB */
			if (chip->chipsize > (32 << 20)) {

				/* One more address cycle for devices > 128MiB */
				/* if (chip->chipsize > (128 << 20)) {*/
				page_addr >>= 8;
				/*  writeb(page_addr,
				info->reg + WMT_NFC_COMPORT3_4 + 1); */
				/* before, may be a little error */
				writeb(page_addr & 0xff,
				info->reg + WMT_NFC_COMPORT3_4);
				addr_cycle++;
			}
		}
	}
	*address_cycle = addr_cycle;
}

static int wmt_nand_page_read(struct mtd_info *mtd, unsigned command, int column, int page_addr)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	struct nand_chip *chip = mtd->priv;
	struct nand_read_retry_param *cur_chip = chip->cur_chip;
	unsigned int addr_cycle = 0, b2r_stat;
	int status = -1;
	unsigned int bank_stat, id = 0, pageInBlk = 0;
	int i, total_times = 1, total_try_times = 0;
	unsigned char reset = NAND_CMD_RESET, retry_enable =0xB6, retry_disable = 0xD6;
	DECLARE_COMPLETION(complete);

	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "read data cmd: 0x%x col:0x%x, page:0x%x\n",	command, column, page_addr);
	#endif
	/*info->phase = 0;
	if (readl(info->reg + WMT_NFC_ECC_BCH_CTRL) & DIS_BCH_ECC)
		info->phase = 2;*/

	if (cur_chip != NULL) {
		total_times = cur_chip->total_try_times + 1;
		id = (cur_chip->nand_id>>24)&0xFF;
		if (id == NAND_MFR_SANDISK) {
			pageInBlk = page_addr%mtd->pagecnt;
			if (((pageInBlk%2) == 1 || pageInBlk == 0) && pageInBlk != (mtd->pagecnt - 1))
				total_try_times = cur_chip->total_try_times&0xFF;//Lower page
			else
				total_try_times = (cur_chip->total_try_times>>8)&0xFF;//Upper page
		} else
			total_try_times = cur_chip->total_try_times&0xFF;
		//printk("read page--cur_times = %d, totoal_times = %d \n", cur_chip->cur_try_times, total_times);
	}

	for (i = 0; i < total_times; i++) {
		if (i > 0)
			info->isr_cmd = command;

		info->data_ecc_uncor_err = 0;
		info->dma_finish = 0;
		writeb(0x0F, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
		info->done_data = &complete;
		/* 1: read, 0:data, -1:  */
		if (info->phase == 2) {
			wmt_nfc_dma_cfg(mtd, mtd->writesize+mtd->oobsize-(mtd->oobsize%16), 0, -1, -1);
		} else {
			if (info->oob_ecc_error == 0x50)//read last bank when read oob ecc happen
				wmt_nfc_dma_cfg(mtd, chip->ecc.size, 0, -1, -1);
			else
				wmt_nfc_dma_cfg(mtd, mtd->writesize, 0, -1, -1);
		}
		/*print_nand_register(mtd);*/
	
		info->datalen = 0;
		/* write to clear B2R */
		b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
		writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);
		/* printk(KERN_NOTICE "RB is %d\n", b2r_stat & 0x02);*/
	
		set_read_addr(mtd, &addr_cycle, column, page_addr);
	
		bank_stat = readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT1);
		writew(bank_stat|0x101, info->reg + WMT_NFC_ECC_BCH_INT_STAT1);
	
		status = wmt_wait_chip_ready(mtd); /*Vincent 2008.11.3*/
		if (status)
			printk(KERN_ERR "The chip is not ready\n");
		writeb(NAND_CMD_READ0, info->reg + WMT_NFC_COMPORT0);
		if (addr_cycle == 4)
			writeb(NAND_CMD_READSTART, info->reg + WMT_NFC_COMPORT5_6);
		else if (addr_cycle == 5)
			writeb(NAND_CMD_READSTART, (unsigned char *)(info->reg + WMT_NFC_COMPORT5_6) + 1);
	
		writew(NAND2NFC|MUL_CMDS|((addr_cycle + 2)<<1)|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);
	
		
		//printk("read wait for completion\n");
		wait_for_completion_timeout(&complete, NFC_TIMEOUT_TIME);
		if (info->dma_finish != 1)
			printk("read page wait dma time out");
		status = nand_pdma_handler(mtd);
		//printk(KERN_ERR "check status pdma handler status= %x \n", status);
		nand_free_pdma(mtd);
		if (status)
			printk(KERN_ERR "dma transfer data time out: %x\n",
			readb(info->reg + WMT_NFC_MISC_STAT_PORT));
	
		wmt_nfc_transfer_ready(mtd);
		status = wmt_nand_ready(mtd);
		if (status)
			printk(KERN_NOTICE"B2R not clear status=0x%x\n", status);
		writeb(0x80, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);	

		status = wmt_nfc_wait_idle(mtd, 0, command, column, page_addr);
	
		if (status) {
			printk(KERN_NOTICE"read page wait idle status =%d\n", status);
			/*print_nand_register(mtd);*/
			/*while(1);*/
		}

		if(info->data_ecc_uncor_err == 1) {
			if((cur_chip != NULL)) {
				printk("Uncor Ecc Err %d_th, on page 0x%x fail., cur_try_time=%d\n", i, page_addr, cur_chip->cur_try_times);
				if (id == NAND_MFR_HYNIX) {
					//printk("set retry mode cur_try_times=%d\n", cur_chip->cur_try_times);
					cur_chip->set_parameter(mtd, READ_RETRY_MODE, ECC_ERROR_VALUE);
					cur_chip->retry = 1;
					
					if (i == total_try_times) {
						cur_chip->retry = 0;
						/* read retry many times still ecc uncorrectable error */
						printk("read page after retry still uncor err\n");
						mtd->ecc_stats.failed++;
						//while(cur_chip);
						return status;
					}
				} else if (id == NAND_MFR_TOSHIBA) {
					if (cur_chip->cur_try_times >= total_try_times) {
						/* send reset cmd after read retry finish(fail) for toshiba */
						write_bytes_cmd(mtd, 1, 0, 0, (uint8_t *)&reset, NULL, NULL);
						cur_chip->cur_try_times = 0;
						cur_chip->retry = 0;
						printk("read page after retry still uncor err\n");
						mtd->ecc_stats.failed++;
						//while(cur_chip);
						return status;
					}
					if (cur_chip->cur_try_times == 0 && cur_chip->retry != 1)
						toshiba_pre_condition(mtd);
					cur_chip->set_parameter(mtd, 0, 0);
					cur_chip->retry = 1;
				} else if (id == NAND_MFR_SAMSUNG || id == NAND_MFR_MICRON) {
					if (cur_chip->cur_try_times >= total_try_times) {
						/* send default cmd after read retry finish(fail) for samsung */
						cur_chip->set_parameter(mtd, READ_RETRY_MODE, DEFAULT_VALUE);
						cur_chip->cur_try_times = 0;
						cur_chip->retry = 0;
						printk("read page after retry still uncor err\n");
						mtd->ecc_stats.failed++;
						//while(cur_chip);
						return status;
					}
					cur_chip->set_parameter(mtd, READ_RETRY_MODE, ECC_ERROR_VALUE);
					cur_chip->retry = 1;
				} else if (id == NAND_MFR_SANDISK) {
					//printk("set retry mode cur_try_times=%d\n", cur_chip->cur_try_times);
					cur_chip->set_parameter(mtd, total_try_times, ECC_ERROR_VALUE);
					if (i == 0 && cur_chip->retry != 1)
						write_bytes_cmd(mtd, 1, 0, 0, &retry_enable, NULL, NULL);
					cur_chip->retry = 1;

					if (i == total_try_times) {
						write_bytes_cmd(mtd, 1, 0, 0, &retry_disable, NULL, NULL);
						cur_chip->retry = 0;
						/* read retry many times still ecc uncorrectable error */
						printk("read page after retry still uncor err\n");
						mtd->ecc_stats.failed++;
						//while(cur_chip);
						return status;
					}
				}
			} else {
				printk("read page uncor err but cur_chip = NULL!\n");
				break;
			}
		} else {
			if (cur_chip) {
				if (cur_chip->retry == 1)
					printk("read retry PASS cur_try_times=%d\n", cur_chip->cur_try_times);
				else
					break;
				/* send reset cmd after read retry finish(pass) for toshiba */
				if (id == NAND_MFR_TOSHIBA) {
					write_bytes_cmd(mtd, 1, 0, 0, (uint8_t *)&reset, NULL, NULL);
					printk("reset cmd to finish retry\n");
					cur_chip->cur_try_times = 0;
				} else if (id == NAND_MFR_SAMSUNG || id == NAND_MFR_MICRON) {
					cur_chip->set_parameter(mtd, READ_RETRY_MODE, DEFAULT_VALUE);
					cur_chip->cur_try_times = 0;
				} else if (id == NAND_MFR_SANDISK) {
					write_bytes_cmd(mtd, 1, 0, 0, &retry_disable, NULL, NULL);
					//set retry default value need before page program
					cur_chip->set_parameter(mtd, total_try_times, DEFAULT_VALUE);
					//should we reset cur_try_times to zero?
					cur_chip->cur_try_times = -1;
				} 
				cur_chip->retry = 0;
			}
			break;
		}
	} //end of retry for loop

	return 0;
}

static void wmt_nand_oob_read(struct mtd_info *mtd, unsigned command, int column, int page_addr)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	//struct nand_chip *chip = mtd->priv;
	unsigned int addr_cycle = 0, b2r_stat;
	int status = -1;
	unsigned int bank_stat;
	int mycolumn = column, mypage_addr = page_addr;
	DECLARE_COMPLETION(complete);

	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "wmt_nand_oob_read: readoob col=0x%x, page=0x%x\n", column, page_addr);
	#endif
	/*  memcpy(info->dmabuf + info->datalen, 0x00, 64);*/
	b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
	writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);
	writeb(0x07, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
	info->done_data = &complete;

	info->datalen = 0;
	/* write to clear B2R */
	b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
	writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);
	/* printk(KERN_NOTICE "RB is %d\n", b2r_stat & 0x02);*/

	set_read_addr(mtd, &addr_cycle, column, page_addr);

	bank_stat = readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT1);
	writew(bank_stat|0x101, info->reg + WMT_NFC_ECC_BCH_INT_STAT1);

	/* printk(KERN_NOTICE "\r ECC OOB MODE(9)0x024 %8.8x\n",
	readl(info->reg + WMT_NFC_SMC_ENABLE));*/
	
	status = wmt_wait_chip_ready(mtd); /*Vincent 2008.11.3*/
	if (status)
		printk(KERN_ERR "The chip is not ready\n");
	writeb(NAND_CMD_READ0, info->reg + WMT_NFC_COMPORT0);
	if (addr_cycle == 4)
		writeb(NAND_CMD_READSTART, info->reg + WMT_NFC_COMPORT5_6);
	else if (addr_cycle == 5)
		writeb(NAND_CMD_READSTART, (unsigned char *)(info->reg + WMT_NFC_COMPORT5_6) + 1);

	writew(NAND2NFC|MUL_CMDS|((addr_cycle + 2)<<1)|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);

	
	/* read oob has no dma but assert B2R status */
	//printk("read oob wait for completion");
	wait_for_completion_timeout(&complete, NFC_TIMEOUT_TIME);
	status = wmt_nfc_transfer_ready(mtd);
	if (status)
		printk(KERN_NOTICE"oob read wait NFC_BUSY time out\n");
	//wmt_nand_ready(mtd);
	writeb(0x80, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);

	status = wmt_nfc_wait_idle(mtd, 0, command, mycolumn, mypage_addr);
//	if (command == NAND_CMD_READOOB) {
		/* disable_redunt_out_bch_ctrl(info, 0);*/
		/* writeb(readb(info->reg + WMT_NFC_CALC_CTRL) &0xFFFFFFFD ,
		info->reg + WMT_NFC_CALC_CTRL);*/ /*Vincent 2008.11.3*/
//	}

	if (status) {
		if (status == -4)
			return;
		printk(KERN_ERR "wmt_nfc_wait_idle status =%d\n", status);
		printk(KERN_ERR "command =0x%x\n", command);
		printk(KERN_ERR "Read ERR ,NFC is not idle\n");
		/*print_nand_register(mtd);*/
		writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
		info->reg + WMT_NFC_ECC_BCH_CTRL);
		/*while(1);*/
	}
	return;
}

/**
 * wmt_isbad_bbt - [NAND Interface] Check if a block is bad
 * @mtd:	MTD device structure
 * @offs:	offset in the device
 * @allowbbt:	allow access to bad block table region
 *
*/
int wmt_isbad_bbt(struct mtd_info *mtd, struct nand_chip *chip, int block)
{
	uint8_t res;

	if (!mtd || !chip) {
		printk(KERN_ERR "nand not init, check bad block fail.\n");
		return 1;
	}
	if (!chip->bbt) {
		printk(KERN_ERR "nand bbt not init, check bad block fail.\n");
		return 1;
	}

	/* Get block number * 2 */
	block <<= 1;
	res = (chip->bbt[block >> 3] >> (block & 0x06)) & 0x03;

	switch ((int)res) {
	case 0x00:
		return 0;
	case 0x01:
		return 1;
	case 0x02:
		return 1;
	}
	return 1;
}

/*
 * wmt_nand_cmdfunc - Send command to NAND large page device
 * @mtd:	MTD device structure
 * @command:	the command to be sent
 * @column:	the column address for this command, -1 if none
 * @page_addr:	the page address for this command, -1 if none
 *
 * Send command to NAND device. This is the version for the new large page
 * devices We dont have the separate regions as we have in the small page
 * devices.  We must emulate NAND_CMD_READOOB to keep the code compatible.
 */
static void wmt_nand_cmdfunc(struct mtd_info *mtd, unsigned command, int column, int page_addr)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	struct nand_chip *chip = mtd->priv;
	unsigned int addr_cycle = 0, b2r_stat, pmc_nand, chip_en;
	int status = -1, eslcpage_base = 0, eslcpage_mod = 0, base_page = 0, base_page_end = 0, eslcblk_base = 0;
	int good_blk = 0, bad_blk = 0, base_blk, base_blk_end, i, j, blk_page_shift;
	unsigned int blk_ofs = 0;
	int mycolumn, mypage_addr;
	DECLARE_COMPLETION(complete);
	
	if (mtd->id == 0xECDED57A) {
		if (page_addr >= (4096*128)) {
			page_addr = page_addr + 0x80000;
			//printk(KERN_NOTICE "cmd %x col:%x, page:0x%x\n", command, column, page_addr);
		}
	} else if (chip->cur_chip && chip->cur_chip->nand_id == 0xADD794DA && whole_eslc == 1 && command != NAND_CMD_SEQIN) {
		eslcpage_mod = page_addr%mtd->pagecnt;
		eslcpage_base = (page_addr - eslcpage_mod) << 1;
		if (prob_end == 0 && eslcpage_mod == (mtd->pagecnt-1)) {
			page_addr = eslcpage_base + eslcpage_mod*2+1;
		} else {
			page_addr = eslcpage_base + eslc_map_table[eslcpage_mod];
		}
		/*printk(KERN_NOTICE "dan cmd=0x%x page=0x%x eslcpage = 0x%x\n",
			command, tmp_page, page_addr);*/
	} else if (command == NAND_CMD_READ0 && chip->cur_chip && prob_end == 1 && 
	(chip->cur_chip->nand_id>>24) == NAND_MFR_HYNIX && whole_eslc != 1) {
		if (page_addr < par4_ofs) {
			eslcpage_mod = page_addr%mtd->pagecnt;
			eslcpage_base = page_addr - eslcpage_mod;
	
			if (page_addr < par1_ofs) {
				base_page = 0;
				base_page_end = par1_ofs;
			} else if (page_addr < par2_ofs) {
				base_page = par1_ofs;
				base_page_end = par2_ofs;
			} else if (page_addr < par3_ofs) {
				base_page = par2_ofs;
				base_page_end = par3_ofs;
			} else /*if (page_addr < par7_ofs)*/ {
				base_page = par3_ofs;
				base_page_end = par4_ofs;
			}
			blk_page_shift = chip->phys_erase_shift - chip->page_shift;
			eslcblk_base = eslcpage_base >> blk_page_shift;
			base_blk = base_page >> blk_page_shift;
			base_blk_end = base_page_end >> blk_page_shift;
			blk_ofs = ((eslcpage_base) - base_page) >> blk_page_shift;
			
			for (j = base_blk; j < eslcblk_base; j++) {
				status = wmt_isbad_bbt(mtd, chip, j);
				if (status) {
					#ifdef ELSC_DEBUG
					if (eslcpage_mod == 0 || eslcpage_mod == (mtd->pagecnt/2))
						printk("skip blk%d bad\n", j);
					#endif
					bad_blk++;
				}
			}
			blk_ofs = blk_ofs - bad_blk;
			blk_ofs = blk_ofs*2 + ((eslcpage_mod >= (mtd->pagecnt/2)) ? 1 : 0);

			for (i = base_blk; i < base_blk_end; i++) {
				status = wmt_isbad_bbt(mtd, chip, i);
				if (status == 0) {
					#ifdef ELSC_DEBUG
					if (eslcpage_mod == 0 || eslcpage_mod == (mtd->pagecnt/2))
						printk("cmdfunc: blk%d good\n",i);
					#endif
					good_blk++;
				} 
				#ifdef ELSC_DEBUG
				else {
					if (eslcpage_mod == 0 || eslcpage_mod == (mtd->pagecnt/2))
						printk("cmdfunc: skip blk%d bad\n", i);
					continue;
				}
				#endif
				if (good_blk >= (blk_ofs + 1)) {
					#ifdef ELSC_DEBUG
					if (eslcpage_mod == 0 || eslcpage_mod == (mtd->pagecnt/2))
						printk("cmdfunc read blk%d \n",i);
					#endif
					break;
				}
			}
			if (i >= base_blk_end) {
				if (eslcpage_mod == 0 || eslcpage_mod == (mtd->pagecnt/2))
					printk(KERN_ERR "eslc cmdfunc is out of partition size, skip page=0x%x, base_page_end=%d\n",
				page_addr, base_page_end);
				return;
			}
			blk_ofs = i << blk_page_shift;
			
			#ifdef ELSC_DEBUG
			if (eslcpage_mod == 0 || eslcpage_mod == (mtd->pagecnt/2))
				printk(KERN_NOTICE "cmdfunc eslc page=0x%x eslc page = 0x%x\n",
				page_addr, blk_ofs + eslc_map_table[(eslcpage_mod%(mtd->pagecnt/2))]);
			#endif
			page_addr = blk_ofs + eslc_map_table[(eslcpage_mod%(mtd->pagecnt/2))];
		}
	}
	mycolumn = column;
	mypage_addr = page_addr;
	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "enter in wmt_nand_cmdfunc() command: %x column:%x, page_addr:%x\n",
	command, column, page_addr);
	#endif
	info->isr_cmd = command;
	info->cur_page = page_addr;
	info->phase = 0;
	if (readl(info->reg + WMT_NFC_ECC_BCH_CTRL) & DIS_BCH_ECC)
		info->phase = 2;
	pmc_nand = *(volatile unsigned long *)PMCEU_ADDR;// |= (0x0010000);//add by vincent
	if (!(pmc_nand&0x0010000))
		printk(KERN_NOTICE "pmc_nand=0x%x\n", pmc_nand);

	chip_en = readb(info->reg + WMT_NFC_CHIP_ENABLE_CTRL);
	if ((chip_en&3) == 3) {
		printk(KERN_NOTICE "chip 0, or 1, is not select chip_sel=%x\n", chip_en);
		writeb(0xfe, info->reg + WMT_NFC_CHIP_ENABLE_CTRL);
	}

	switch (command) {
	case NAND_CMD_READ0:
		wmt_nand_page_read(mtd, command, column, page_addr);
		return;
	case NAND_CMD_READOOB:
		wmt_nand_oob_read(mtd, command, column, page_addr);
		return;
	case NAND_CMD_SEQIN:
	case NAND_CMD_ERASE1:
		/* printk(KERN_NOTICE "command is %x\n", command);*/
		if (column != -1) {
			writeb(column, info->reg + WMT_NFC_COMPORT1_2);
			addr_cycle++;
			/*#ifndef PAGE_ADDR*/
			if (mtd->writesize != 512) {
				writeb(column >> 8, (unsigned char *)(info->reg + WMT_NFC_COMPORT1_2) + 1);
				addr_cycle++;
			}/*#endif*/
			if (page_addr != -1) {
				/*#ifndef PAGE_ADDR*/
				if (mtd->writesize != 512) {
					writeb(page_addr, info->reg + WMT_NFC_COMPORT3_4);
					page_addr >>= 8;
					writeb(page_addr, (unsigned char *)(info->reg + WMT_NFC_COMPORT3_4) + 1);
					addr_cycle += 2;
				/*#else*/
				} else {
					writeb(page_addr, (unsigned char *)(info->reg + WMT_NFC_COMPORT1_2) + 1);
					page_addr >>= 8;
					writeb(page_addr, info->reg + WMT_NFC_COMPORT3_4);
					addr_cycle += 2;
				} /*#endif*/

				if (mtd->writesize == 2048) {
				/* One more address cycle for devices > 128MiB */
					if (chip->chipsize > (128 << 20)) {
						page_addr >>= 8;
						/*#ifndef PAGE_ADDR*/
						if (mtd->writesize != 512)
							writeb(page_addr, info->reg + WMT_NFC_COMPORT5_6);
						else /*#else*/
							writeb(page_addr, (unsigned char *)(info->reg + WMT_NFC_COMPORT3_4) + 1);
						/*#endif*/
						addr_cycle++;
					}
				} else if (mtd->writesize == 4096) {
					/* One more address cycle for devices > 256MiB */
					if (chip->chipsize > (256 << 20)) {
						page_addr >>= 8;
						/*#ifndef PAGE_ADDR*/
						if (mtd->writesize != 512)
							writeb(page_addr, info->reg + WMT_NFC_COMPORT5_6);
						else /*#else*/
							writeb(page_addr, (unsigned char *)(info->reg + WMT_NFC_COMPORT3_4) + 1);
						/*#endif*/
						addr_cycle++;
					}
				} else if (mtd->writesize == 8192) {
					/* One more address cycle for devices > 512MiB */
					if (chip->chipsize > (512 << 20)) {
						page_addr >>= 8;
						if (mtd->writesize != 512)
							writeb(page_addr, info->reg + WMT_NFC_COMPORT5_6);
						addr_cycle++;
					}
				} else if (mtd->writesize == 16384) {
					/* One more address cycle for devices > 1024MiB */
					if (chip->chipsize > (1024 << 20)) {
						page_addr >>= 8;
						writeb(page_addr, info->reg + WMT_NFC_COMPORT5_6);
						addr_cycle++;
					}
				} else {
					/* One more address cycle for devices > 32MiB */
					if (chip->chipsize > (32 << 20)) {
						page_addr >>= 8;
						/*#ifndef PAGE_ADDR*/
						if (mtd->writesize != 512)
							writeb(page_addr, info->reg + WMT_NFC_COMPORT5_6);
						else /*#else*/
							writeb(page_addr, (unsigned char *)(info->reg + WMT_NFC_COMPORT3_4) + 1);
						/*#endif*/
						addr_cycle++;
					}
				}
			}
		/*} else if (page_addr != -1) {*/
		} else if ((page_addr != -1) && (column == -1)) {
			writeb(page_addr & 0xff, info->reg + WMT_NFC_COMPORT1_2);
			page_addr >>= 8;
			writeb(page_addr & 0xff, (unsigned char *)(info->reg + WMT_NFC_COMPORT1_2) + 1);
			addr_cycle += 2;

			if (mtd->writesize == 2048) {
				/* One more address cycle for devices > 128MiB */
				if (chip->chipsize > (128 << 20)) {
					page_addr >>= 8;
					writeb(page_addr, info->reg + WMT_NFC_COMPORT3_4);
					addr_cycle++;
				}
			} else if (mtd->writesize == 4096) {
				/* One more address cycle for devices > 256MiB */
				if (chip->chipsize > (256 << 20)) {
					page_addr >>= 8;
					writeb(page_addr, info->reg + WMT_NFC_COMPORT3_4);
					addr_cycle++;
				}
			} else if (mtd->writesize == 8192) {
				/* One more address cycle for devices > 512MiB */
				if (chip->chipsize > (512 << 20)) {
					page_addr >>= 8;
					writeb(page_addr, info->reg + WMT_NFC_COMPORT3_4);
					addr_cycle++;
				}
			} else if (mtd->writesize == 16384) {
				/* One more address cycle for devices > 1024MiB */
				if (chip->chipsize > (1024 << 20)) {
					page_addr >>= 8;
					writeb(page_addr, info->reg + WMT_NFC_COMPORT3_4);
					addr_cycle++;
				}
			} else {
				/* One more address cycle for devices > 32MiB */
				if (chip->chipsize > (32 << 20)) {
					page_addr >>= 8;
					writeb(page_addr, info->reg + WMT_NFC_COMPORT3_4);
					addr_cycle++;
				}
			}
		}

		/* set command 1 cycle */
		writeb(command, info->reg + WMT_NFC_COMPORT0);
		if (command == NAND_CMD_SEQIN) {
			info->done_data = &complete;
			writew(((addr_cycle + 1)<<1)|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);
		} else {
			/* writeb(read(info->reg + WMT_NFC_NAND_TYPE_SEL) | WP_DISABLE ,
			info->reg + WMT_NFC_NAND_TYPE_SEL);*/
			writew(DPAHSE_DISABLE|((addr_cycle + 1)<<1)|NFC_TRIGGER|OLD_CMD,
			info->reg + WMT_NFC_COMCTRL);
		}

		if (command == NAND_CMD_ERASE1) {
			status = wmt_wait_cmd_ready(mtd);
			/* status = wmt_nfc_ready(mtd); */
			if (status)
					printk(KERN_ERR "command is not ready\n");
					writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
					info->reg + WMT_NFC_ECC_BCH_CTRL);
		}	else {
			wmt_wait_nfc_ready(info);
			status = wmt_nfc_transfer_ready(mtd);
			wait_for_completion_timeout(&complete, NFC_TIMEOUT_TIME);
			/*status = wmt_wait_dma_ready(mtd);*/ /*dannier mask*/
			if (status)	{
				printk(KERN_ERR "dma transfer data is not ready: %x\n",
				readb(info->reg + WMT_NFC_MISC_STAT_PORT));
				writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
				info->reg + WMT_NFC_ECC_BCH_CTRL);
				/*printk(KERN_NOTICE "\rwait transfer data is not ready: %x\n",
				readb(info->reg + WMT_NFC_MISC_STAT_PORT));*/
				/*print_nand_register(mtd);*/
				/* while (1);*/
				/* return;*/
			}
		}
		return;

	case NAND_CMD_PAGEPROG:
		/* case NAND_CMD_READSTART:*/
	case NAND_CMD_ERASE2:
		/* printk(KERN_NOTICE "command is %x\n", command);*/
		writeb(command, info->reg + WMT_NFC_COMPORT0);
		b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
		if (B2R&b2r_stat) {
			printk(KERN_NOTICE"flash B2R status assert command=0x%x\n",command);
			writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);
			status = wmt_wait_chip_ready(mtd); /*Vincent 2008.11.3*/
			if (status)
				printk(KERN_NOTICE"The chip is not ready\n");
		}

		if (NAND_CMD_ERASE2 == command) {
			b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
			writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);
			writeb(0x07, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
		}
		info->done_data = &complete;
		writew(DPAHSE_DISABLE|(1<<1)|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);

		info->datalen = 0;
		wait_for_completion_timeout(&complete, NFC_TIMEOUT_TIME);
		writeb(0x80, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
		#if 0  /* for debug */
		if (command == NAND_CMD_ERASE2) {
			wmt_read_nand_status(mtd, NAND_CMD_STATUS);
			if ((readb(info->reg + WMT_NFC_DATAPORT) & 0xff) == 0xc0) {
				printk(KERN_NOTICE "wmt_func: erase block OK\n");
				printk(KERN_NOTICE "read nand status is %x\n",
				readb(info->reg + WMT_NFC_DATAPORT) & 0xff);
			}	else
				printk(KERN_NOTICE "wmt_func: erase block failed\n");
		}
		#endif

		status = wmt_nfc_wait_idle(mtd, 1, 1, -1, -1); /* write page, don't check ecc */
		if (status < 0) {
			printk(KERN_ERR "page program or erase err, nand controller is not idle\n");
			/*print_nand_register(mtd);*/
			/* writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
			info->reg + WMT_NFC_ECC_BCH_CTRL);*/
			/* while (1);*/
			/* return;*/
			/* }*/
			#if 0
			status = wmt_read_nand_status(mtd, NAND_CMD_STATUS);
			if (status < 0)
				printk(KERN_NOTICE "\rNFC or NAND is not ready\n");
			else if (status & NAND_STATUS_FAIL)
				printk(KERN_NOTICE "\r status : fail\n");
			else if (!(status & NAND_STATUS_READY))
				printk(KERN_NOTICE "\r status : busy\n");
			else if (!(status & NAND_STATUS_WP))
				printk(KERN_NOTICE "\r status : protect\n");
			#endif
			return;
		}

		return;

	case NAND_CMD_RESET_NO_STATUS_READ:
	case NAND_CMD_HYNIX_RETRY_END:

		if (!chip->dev_ready)
			break;
		udelay(chip->chip_delay);
		writeb(command, info->reg + WMT_NFC_COMPORT0);
		/* write to clear B2R */
		b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
		writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);

		writew(DPAHSE_DISABLE|(0x01<<1)|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);
		status = wmt_nand_ready(mtd);
		if (status) {
			printk(KERN_ERR "Reset err, nand device is not ready\n");
			writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
			info->reg + WMT_NFC_ECC_BCH_CTRL);
		}

		return;
	
	case NAND_CMD_RESET:

		if (!chip->dev_ready)
			break;
		udelay(chip->chip_delay);
		writeb(command, info->reg + WMT_NFC_COMPORT0);
		/* write to clear B2R */
		b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
		writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);

		writew(DPAHSE_DISABLE|(0x01<<1)|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);
		status = wmt_nand_ready(mtd);
		if (status) {
			b2r_stat = readb(info->reg + WMT_NFC_CHIP_ENABLE_CTRL);
			printk(KERN_ERR "Reset err, nand device chip %d is not ready\n", ((~b2r_stat)&0xFF)>>1);
			writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
			info->reg + WMT_NFC_ECC_BCH_CTRL);
		}

		wmt_read_nand_status(mtd, NAND_CMD_STATUS);
		/*  while (!(chip->read_byte(mtd) & NAND_STATUS_READY));*/
		while (!((readb(info->reg + WMT_NFC_DATAPORT) & 0xff) & NAND_STATUS_READY))
			;
		#ifdef NAND_DEBUG
		printk(KERN_NOTICE "Reset status is ok\n");
		#endif
		return;

	case NAND_CMD_READID:

		status = wmt_nand_readID(mtd);
		#ifdef NAND_DEBUG
		printk(KERN_NOTICE "readID status is %d\n", status);
		#endif
		return;

	case NAND_GET_FEATURE:		
		status = nand_get_feature(mtd);		
	return;

	case NAND_CMD_STATUS:

		wmt_read_nand_status(mtd, command);
		return;

	case NAND_CMD_RNDIN:
		if (column != -1) {
			writeb(column, info->reg + WMT_NFC_COMPORT1_2);
			addr_cycle++;
			if (mtd->writesize != 512) {
				writeb(column >> 8, (unsigned char *)(info->reg + WMT_NFC_COMPORT1_2) + 1);
				addr_cycle++;
			}
		}
		info->done_data = &complete;
		/* set command 1 cycle */
		writeb(command, info->reg + WMT_NFC_COMPORT0);

		writew(((addr_cycle + 1)<<1)|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);
		wait_for_completion_timeout(&complete, NFC_TIMEOUT_TIME);
		status = wmt_nfc_wait_idle(mtd, 1, -1, -1, -1); /* don't check ecc, wait nfc idle */
		/*  status = wmt_wait_cmd_ready(mtd);*/
		/* status = wmt_nfc_ready(mtd);*/
		if (status)
			printk(KERN_ERR "Ramdom input err: nfc is not idle\n");

		return;

	case NAND_CMD_RNDOUT:

		if (column != -1) {
			writeb(column, info->reg + WMT_NFC_COMPORT1_2);
			writeb(column, info->reg + WMT_NFC_COMPORT1_2 + 1);
			addr_cycle += 2;
		}

		/* CLEAR ECC BIT */
		writeb(0x07, info->reg + WMT_NFC_REDUNT_ECC_STAT);
		writel(0xffffffff, info->reg + WMT_NFC_BANK18_ECC_STAT);
		/* write to clear B2R */
		b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
		writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);

		/* set command 1 cycle */
		writeb(command, info->reg + WMT_NFC_COMPORT0);

		writew(DPAHSE_DISABLE|((addr_cycle + 1)<<1)|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);

		status = wmt_wait_cmd_ready(mtd);
		/* status = wmt_nfc_ready(mtd);*/
		if (status) {
			printk(KERN_ERR "Ramdom output err: nfc command is not ready\n");
			/* return;*/
		}

		writeb(NAND_CMD_RNDOUTSTART, info->reg + WMT_NFC_COMPORT0);
		/* write to clear B2R */
		b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
		writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);

		writew(NAND2NFC|(1<<1)|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);

		status = wmt_wait_cmd_ready(mtd);
		/* status = wmt_nand_ready(mtd);*/
		if (status) {
			printk(KERN_ERR "Ramdom output err: nfc io transfer is not finished\n");
			/* return;*/
		}
		/* reduntant aera check ecc, wait nfc idle */
		status = wmt_nfc_wait_idle(mtd, 0, -1, -1, -1);
		/* status = wmt_nand_wait_idle(mtd);*/
		if (status)
			printk(KERN_ERR "Ramdom output err: nfc is not idle\n");
		return;


	case NAND_CMD_STATUS_ERROR:
	case NAND_CMD_STATUS_ERROR0:
		udelay(chip->chip_delay);
		return;


	default:
		/*
		 * If we don't have access to the busy pin, we apply the given
		 * command delay
		 */

		/* trigger command and addrress cycle */

		if (!chip->dev_ready) {
			udelay(chip->chip_delay);
			return;
		}
	}
	/* Apply this short delay always to ensure that we do wait tWB in */
	/* any case on any machine.*/
	/* ndelay(100);*/
	wmt_device_ready(mtd);
	/*if (((*(volatile unsigned long *)(GPIO_BASE_ADDR + 0x100))&6) == 2)
		spin_unlock(nand_lock);*/
}


static void wmt_nand_select_chip(struct mtd_info *mtd, int chipnr)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	unsigned int b2r_stat;
	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "\r enter in wmt_nand_select_chip()\n");
	#endif
	if (!((*(volatile unsigned long *)PMCEU_ADDR)&0x0010000))
		*(volatile unsigned long *)PMCEU_ADDR |= (0x0010000);
	if (chipnr > 1)
		printk(KERN_WARNING "There are only support two chip sets\n");

	b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
	writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);

    if (chipnr >= 0 && chipnr < 2)
        writeb(~(1<<chipnr), info->reg + WMT_NFC_CHIP_ENABLE_CTRL);
    else if (chipnr < 0)
        writeb(~0, info->reg + WMT_NFC_CHIP_ENABLE_CTRL);
    else                                                                                                                                     
        printk(KERN_WARNING "There are only support two chip sets. chipnr = %d\n", chipnr);
}


static void wmt_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "enter in wmt_nand_write_buf()\n");
	#endif
	memcpy(info->dmabuf + info->datalen, buf, len);

	info->datalen += len;
}

static void wmt_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "enter in wmt_nand_read_buf() len: %x infoDatalen :%x\n", len, info->datalen);
	#endif

	memcpy(buf, info->dmabuf + info->datalen, len);
	info->datalen += len;
}

static uint8_t wmt_read_byte(struct mtd_info *mtd)
{
	/* struct wmt_nand_mtd *nmtd = mtd->priv;*/
	/* struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);*/
	uint8_t d;
	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "enter in wmt_nand_read_byte()\n");
	#endif

	/* d = readb(info->reg + WMT_NFC_DATAPORT) & 0xff;*/
	 wmt_nand_read_buf(mtd, &d, 1);
	/* via_dev_dbg(&nmtd->info->platform->dev, "Read %02x\n", d);*/
	/* via_dev_dbg(info->platform->dev, "Read %02x\n", d);*/

	return d;
}

static int wmt_nand_read_oob(struct mtd_info *mtd, struct nand_chip *chip, int page, int sndcmd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	uint8_t *buf = chip->oob_poi;
	/* int length = mtd->oobsize;  */ /* prepad = chip->ecc.prepad, bytes = chip->ecc.bytes;*/
	/* int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;*/
	/* int eccsize = chip->ecc.size;*/
	uint8_t *bufpoi = buf;
#ifdef CONFIG_MTD_NAND_RANDOMIZER
	unsigned int rdmz_mark = 0, i = 0;
	unsigned char fifo[24];
#endif
	/* struct nand_oobfree *free = chip->ecc.layout->oobfree;*/
	/* uint32_t boffs;*/
	/* int pos;   */ /* toread, sndrnd = 1;*/

	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "\r enter in wmt_nand_read_oob() page =0x%x\n", page);
	#endif
	/* info->datalen = mtd->writesize;*/  /* oob data is placed in after info->dmabuf[2047]  */

	
	/*  for (i = 0; i < chip->ecc.steps; i++) {*/
	/*for (i = 0; i < 4; i++) {*/
	// read redundant area cmd
	info->oob_ecc_error = 0;
	//writew(mtd->writesize - 1, info->reg + WMT_NFC_DMA_COUNTER);
	writeb(readb(info->reg + WMT_NFC_SMC_ENABLE) | 0x2,
	info->reg + WMT_NFC_SMC_ENABLE);
	writeb((info->oob_ECC_bytes+1), info->reg + WMT_NFC_REMAINDER+1);
	if (info->ECC_mode != info->oob_ECC_mode)
		set_ecc_engine(info, info->oob_ECC_mode);
	//pos = info->oob_col/*+ i * (eccsize + chunk);*/
	//print_nand_register(mtd);
	chip->cmdfunc(mtd, NAND_CMD_READOOB, info->oob_col, page);
	if (info->ECC_mode != info->oob_ECC_mode)
		set_ecc_engine(info, info->ECC_mode);
	writeb(info->oob_ECC_bytes, info->reg + WMT_NFC_REMAINDER+1);
	writeb(readb(info->reg + WMT_NFC_SMC_ENABLE) & 0xfd,
	info->reg + WMT_NFC_SMC_ENABLE);

	// read last bank cmd	
	if (info->oob_ecc_error == 0x50) {
		//printk(KERN_NOTICE "Rebk page=%d\n", page);
		//pos = info->last_bank_col = pos - eccsize;//(eccsize + chip->ecc.bytes) * (chip->ecc.steps-1)
		writeb(readb(info->reg + WMT_NFC_ECC_BCH_CTRL) | 0x10, info->reg + WMT_NFC_ECC_BCH_CTRL);
		//printk("Re_oob fail,read last bk col=%d oob_col=%d\n", info->last_bank_col, info->oob_col);
		//print_nand_register(mtd);
		chip->cmdfunc(mtd, NAND_CMD_READ0, info->last_bank_col, page);
		writeb(readb(info->reg + WMT_NFC_ECC_BCH_CTRL) & ((~0x10)&0xFF), info->reg + WMT_NFC_ECC_BCH_CTRL);
		info->oob_ecc_error = 0;
		//printk(KERN_NOTICE "Rebk 8c=0x%x\n", readl(info->reg + WMT_NFC_ECC_BCH_CTRL));
	} else {
		#ifdef NAND_DEBUG
		int i;
		uint8_t *tmp = info->reg+ECC_FIFO_0;
		for (i=0;i<64;i++) {
			if (tmp[i]!=0xFF) {
				printk(KERN_NOTICE "FAIL-data not all FF, i=%d page=%d\n", i, page);
				break;
			}
		}
		if (i == 64)
			printk(KERN_NOTICE "ob pass\n");
		#endif
	}

	if (chip->cur_chip &&	chip->cur_chip->nand_id == 0xADD794DA && whole_eslc == 1) {
		int tmp_page = page;
		int eslcpage_mod = page%mtd->pagecnt;
		int eslcpage_base = (page - eslcpage_mod) << 1;
		if (prob_end == 0 && eslcpage_mod == (mtd->pagecnt-1)) {
			printk(KERN_NOTICE "dan r oob page=0x%x eslcpage = 0x%x\n",tmp_page, page);
			page = eslcpage_base + eslcpage_mod*2+1;
		} else {
			page = eslcpage_base + eslc_map_table[eslcpage_mod];
		}
	}
	
#ifdef CONFIG_MTD_NAND_RANDOMIZER
	if(mtd->is_randomizer) {
		if(mtd->id == 0x98de9482 || mtd->id == 0x98de8493) {
			memset(fifo, 0xff, 24);
			for(i = 0; i < 24; i++)
				fifo[i] = *((uint8_t *)(info->reg+ECC_FIFO_0 + i));
			normalize_data(page, mtd->writesize, 24, fifo);
			*(unsigned int *) &rdmz_mark = *(unsigned int *) &fifo[20];
			if (rdmz_mark == *(unsigned int *)wmt_rdmz) {
				normalize_data(page, mtd->writesize, 24, (unsigned char *)(info->reg + ECC_FIFO_0));
			}
			memcpy(bufpoi, info->reg+ECC_FIFO_0, 24);
		} else {
			rdmzier_oob((uint8_t *)&rdmz_mark, (uint8_t *)(info->reg+ECC_FIFO_5), 1, page, (mtd->writesize+20)/4);
			if (rdmz_mark == *(unsigned int *)wmt_rdmz) {
				rdmzier_oob(bufpoi, (uint8_t *)(info->reg+ECC_FIFO_0), 5, page, mtd->writesize/4);
			}	else {
				memcpy(bufpoi, info->reg+ECC_FIFO_0, 24);
			}
		} 
	} else {
		memcpy(bufpoi, info->reg+ECC_FIFO_0, 24);
	}
	//printk("re oob page=0x%x rdmz_mark=0x%x wmt_rdmz=0x%x fifo5=0x%x\n",page , rdmz_mark, *(unsigned int *)wmt_rdmz, *(unsigned int *)(info->reg+ECC_FIFO_5));
#else
	memcpy(bufpoi, info->reg+ECC_FIFO_0, 24);
#endif
	return 1;
}


/*
 * wmt_nand_read_raw_page
 * @mtd:	mtd info structure
 * @chip:	nand chip info structure
 * @page:	page number to read
 * @sndcmd:	flag whether to issue read command or not
 */
static int wmt_nand_read_raw_page(struct mtd_info *mtd, struct nand_chip *chip, int page)
{
	unsigned int tmp, bch, ecc_bit_mode;
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);

	tmp = readl(info->reg + WMT_NFC_NAND_TYPE_SEL);
	bch = readl(info->reg + WMT_NFC_ECC_BCH_CTRL);
	writeb((tmp & 0xfffffffc)+3,	info->reg + WMT_NFC_NAND_TYPE_SEL);
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) & 0xfffffff8, info->reg + WMT_NFC_ECC_BCH_CTRL);
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | DIS_BCH_ECC, info->reg + WMT_NFC_ECC_BCH_CTRL);
	writew(eccBCH_inetrrupt_disable, info->reg + WMT_NFC_ECC_BCH_INT_MASK);
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
	info->reg + WMT_NFC_ECC_BCH_CTRL);

	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);

	//info->datalen = mtd->writesize;
	//chip->read_buf(mtd, chip->oob_poi, 64);
	//memcpy(chip->oob_poi, info->reg+ECC_FIFO_0, 64);
	//nfc_ecc_set(info, 1);   /* on hardware ecc  */
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) & 0xfffffff7, info->reg + WMT_NFC_ECC_BCH_CTRL);
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | bch, info->reg + WMT_NFC_ECC_BCH_CTRL);
	writeb(tmp,	info->reg + WMT_NFC_NAND_TYPE_SEL);
	writew(eccBCH_inetrrupt_disable, info->reg + WMT_NFC_ECC_BCH_INT_MASK);
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
	info->reg + WMT_NFC_ECC_BCH_CTRL);

	ecc_bit_mode = mtd->dwECCBitNum;
	if (ecc_bit_mode > 24)
		ecc_bit_mode = (ecc_bit_mode == 40) ? 6 : (-1);
	else
		ecc_bit_mode = (ecc_bit_mode > 16) ? ((ecc_bit_mode/4) - 1) : (ecc_bit_mode/4);
	set_ecc_engine(info, ecc_bit_mode);  /* BCH ECC structure 12bit ecc engine*/
	
	return 0;
}


/*
 * wmt_nand_read_bb_oob - OOB data read function
 * @mtd:	mtd info structure
 * @chip:	nand chip info structure
 * @page:	page number to read
 * @sndcmd:	flag whether to issue read command or not
 */
static int wmt_nand_read_bb_oob(struct mtd_info *mtd, struct nand_chip *chip,
int page, int sndcmd)
{
	unsigned int tmp, bch, ecc_bit_mode;
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "\r enter in wmt_nand_read_bb_oob() page=0x%x\n", page);
	#endif
	tmp = readl(info->reg + WMT_NFC_NAND_TYPE_SEL);
	bch = readl(info->reg + WMT_NFC_ECC_BCH_CTRL);
	writeb((tmp & 0xfffffffc)+3,	info->reg + WMT_NFC_NAND_TYPE_SEL);
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) & 0xfffffff8, info->reg + WMT_NFC_ECC_BCH_CTRL);
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | DIS_BCH_ECC, info->reg + WMT_NFC_ECC_BCH_CTRL);
	writew(eccBCH_inetrrupt_disable, info->reg + WMT_NFC_ECC_BCH_INT_MASK);
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
	info->reg + WMT_NFC_ECC_BCH_CTRL);

	if (sndcmd) {
		chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
		sndcmd = 0;
	}
	if ((mtd->id>>24) == 0x45) {
		info->datalen = 0;
		chip->read_buf(mtd, chip->oob_poi - mtd->writesize, mtd->writesize + mtd->oobsize);
	} else if (mtd->id == 0xECDED57E && mtd->id2 == 0x68440000) {
		info->datalen = 0;
		chip->read_buf(mtd, chip->oob_poi, 1);
		info->datalen = mtd->writesize;
		chip->read_buf(mtd, chip->oob_poi+1, 63);
	} else {
		info->datalen = mtd->writesize;
		chip->read_buf(mtd, chip->oob_poi, 64);
	}
	//memcpy(chip->oob_poi, info->reg+ECC_FIFO_0, 64);
	//nfc_ecc_set(info, 1);   /* on hardware ecc  */
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) & 0xfffffff7, info->reg + WMT_NFC_ECC_BCH_CTRL);
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | bch, info->reg + WMT_NFC_ECC_BCH_CTRL);
	writeb(tmp,	info->reg + WMT_NFC_NAND_TYPE_SEL);
	writew(eccBCH_inetrrupt_disable, info->reg + WMT_NFC_ECC_BCH_INT_MASK);
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
	info->reg + WMT_NFC_ECC_BCH_CTRL);

	ecc_bit_mode = mtd->dwECCBitNum;
	if (ecc_bit_mode > 24)
		ecc_bit_mode = (ecc_bit_mode == 40) ? 6 : (-1);
	else
		ecc_bit_mode = (ecc_bit_mode > 16) ? ((ecc_bit_mode/4) - 1) : (ecc_bit_mode/4);
	set_ecc_engine(info, ecc_bit_mode);  /* BCH ECC structure 12bit ecc engine*/
	
	return sndcmd;
}


/* write oob is no longer support */
static int wmt_nand_write_oob(struct mtd_info *mtd, struct nand_chip *chip, int page)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	/*int i;*/
	unsigned int b2r_stat;
	/*int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;*/
	int eccsize = chip->ecc.size; /* length = mtd->oobsize;  */
	/* prepad = chip->ecc.prepad, bytes = chip->ecc.bytes;*/

	int pos, status = 0;
	/*int steps = chip->ecc.steps;*/  /* Vincent 2008.11.4*/
	const uint8_t *bufpoi = chip->oob_poi;
	/* struct nand_oobfree *free = chip->ecc.layout->oobfree;*/
	/* uint32_t boffs;*/
	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "\r enter in wmt_nand_write_oob()\n");
	#endif
	/*
	 * data-ecc-data-ecc ... ecc-oob
	 * or
	 * 512  7     1     5    0    3
	 * data-ecc-prepad-data-pad-oobecc ....
	 */

	/* 	for (i = 0; i < steps; i++) {*/
	/*for (i = 0; i < 4; i++) {*/
	b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
	writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);

	info->datalen = 0;
	/*chip->write_buf(mtd, bufpoi, 32);*/
	memcpy(info->reg+ECC_FIFO_0, bufpoi, 32);
	pos = eccsize * chip->ecc.steps + 8*4;
	/*pos = eccsize + i * (eccsize + chunk);*/
	/*wmt_nfc_dma_cfg(mtd, 32, 1, 1, i);*/
	chip->cmdfunc(mtd, NAND_CMD_SEQIN, pos, page);

	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
	/* printk(KERN_NOTICE "\r in wmt_nand_write_oob_new(): waitfunc_1\n");*/
	status = chip->waitfunc(mtd, chip);
	/* printk(KERN_NOTICE "\r in wmt_nand_write_oob_new(): waitfunc_2\n");*/
	if (status & NAND_STATUS_FAIL)
		return -EIO;
	/* } */
	return 0;

}

unsigned int reverse32 (unsigned int n)
{
	int i=0;
	unsigned int tmp = n, y=0;
	for(;i<31;i++) {
		y += tmp&0x00000001;
		tmp >>= 1;
		y   <<= 1;
	}
	y += tmp&0x00000001;
	return y;
}

int Gen_GF2(u8 bits, unsigned int  *buf)
{
//  assign bch_GF_40becc = 560'hC07F_89B1_A0DC_5D96_619F_32D0_4967_54F6_DE9D_4F93_F527_EF14_EFB0_FD53_9915_A82C_CD92_5528_8030_477D_EE3F_338A_59EC_5FA2_10AF_E2EF_DFAE_D244_DF31_4DA5_0762_B724_A002_9CEF_2DC1;
//  assign bch_GF_24becc = 560'h8E94_E024_8D90_9D2B_4525_72D1_EDD9_D098_FE73_0E8E_8D26_C2D2_2893_A3A0_485B_D0AB_6E0B_4992_9A35_6BD4_30EF;
//  assign bch_GF_12becc = 560'hE48_7325_6115_A567_84A6_940A_4C6E_6D7E_1205_E051;
//  assign bch_GF_8becc = 560'h15_F914_E07B_0C13_8741_C5C4_FB23;
//  assign bch_GF_4becc = 560'h4_5230_43AB_86AB;
	unsigned int bch_GF_40becc[] = { 0xC07F, 0x89B1A0DC, 0x5D96619F, 0x32D04967, 0x54F6DE9D, 0x4F93F527, 0xEF14EFB0, 0xFD539915, 0xA82CCD92, 0x55288030, 0x477DEE3F, 0x338A59EC, 0x5FA210AF, 0xE2EFDFAE, 0xD244DF31, 0x4DA50762, 0xB724A002, 0x9CEF2DC1};
	unsigned int bch_GF_24becc[] = { 0x8E94, 0xE0248D90, 0x9D2B4525, 0x72D1EDD9, 0xD098FE73, 0x0E8E8D26, 0xC2D22893, 0xA3A0485B, 0xD0AB6E0B, 0x49929A35, 0x6BD430EF};
	unsigned int bch_GF_12becc[] = { 0xE487325, 0x6115A567, 0x84A6940A, 0x4C6E6D7E, 0x1205E051};
	unsigned int bch_GF_8becc[] = { 0x15, 0xF914E07B, 0x0C138741, 0xC5C4FB23};
	unsigned int bch_GF_4becc[] = { 0x45230, 0x43AB86AB};
	unsigned int *p;
	int i,len,width;

  switch (bits) {
		case 4  : width = 51;   p = bch_GF_4becc;              break;
		case 8  : width = 103;  p = bch_GF_8becc;              break;
		case 12 : width = 155;  p = bch_GF_12becc;             break;
		case 24 : width = 335;  p = bch_GF_24becc;             break;
		case 40 : width = 559;  p = bch_GF_40becc;             break;
		default : width = 51;   p = bch_GF_4becc;              break;
	}
	len = width/32 +1;
	for(i=0;i<len;i++)
		buf[i] = *(p+len-1-i);

	return (width);
}

unsigned int Caculat_1b_bch( unsigned int *pariA, unsigned int *bch_GF2, unsigned int din, u8 pari_len, u8 pari_lb)
{
	//din: bit31-1 should be 0, only bit0 is valid
	//pari_len: the index of last DW of the parity
	//pari_lb:  the MSB   of the last DW 
	u8 i;
	unsigned int  mask  = ~(0xffffffff <<(pari_lb+1));
	unsigned int  lstdw = mask & pariA[pari_len];
	unsigned int  ldwMSB  = lstdw >> pari_lb ;
	//  for(i=pari_len;i>=0;i--)  printk("%8x",pariA[i]);printk("\n---before\n");
	for(i=pari_len;i>0;i--)	{
		pariA[i]= (pariA[i]<<1) +(pariA[i-1]>>31);
		if(din ^ ldwMSB)  pariA[i] = pariA[i] ^ bch_GF2[i]; 
	}
	pariA[0]= (pariA[0]<<1);
	if(din ^ ldwMSB)  pariA[i] = pariA[i]^ bch_GF2[i]; 
	//  for(i=pari_len;i>=0;i--)  printk("%8x",pariA[i]);printk("\n---after\n");
	return (ldwMSB );
}

int bch_encoder(unsigned int *p_parity, unsigned int *p_data, u8 bits, unsigned int datacnt)
{
	int  i,j;
	int  bchGF_msb;
	u8   pari_len,pari_lb;
	unsigned int  bch_GF2[18];
	unsigned int  tmp;
	unsigned int  *p, *p1;
	u8   *p2;//, p3[50];

	bchGF_msb = Gen_GF2( bits, bch_GF2);
	pari_len   = (u8)(bchGF_msb /32);
	pari_lb    = (u8)(bchGF_msb %32);
	//p = (unsigned int *)malloc((pari_len+2) * sizeof(unsigned int));
	p = (unsigned int *)kmalloc((pari_len+2) * sizeof(unsigned int), GFP_KERNEL);
  if (p == NULL) {
		printk("malloc Error!");
		return -1;
	} else {
		/*gen parity[ bchGF_msb:0] begin*/  
 		//Init  
		for(i=pari_len+1;i>=0;i--)
			*(p+i) = 0;
 		//Caculate 
		p1 = &p[1];
		for (i=0;i<datacnt;i++) {
			tmp = p_data[i];
			for (j=0;j<32;j++) {
	   		Caculat_1b_bch( p1, bch_GF2, tmp&0x00000001, pari_len, pari_lb);
	   		tmp >>= 1;
			}
		}
		//printk("encode finiah!pari_len=%d p_parity=0x%x\n",pari_len, (unsigned int)p_parity);
		/*gen parity[ bchGF_msb:0] end*/  

		/*reverse oder of parity begin*/
		p2 = (u8 *)p;
		//printk("pari_lb=%d p2=0x%x\n", pari_lb, (unsigned int)p2);
		p1 = (unsigned int *)(p2+3-(pari_lb/8));
		/*p2 = (p2+3-(pari_lb/8));
		for(i=0;i<((pari_len+1)*4);i++)
			p3[i] = p2[i];
		p1 = p3;
		*/
		//printk("p2=0x%x p3=0x%x\n", (unsigned int)p2, (unsigned int)p3);
		for(i=0;i<=pari_len;i++) {
			p_parity[pari_len-i] = reverse32(p1[i]);
		}
		/*reverse oder of parity end*/
	//printk("reverse finiah!\n");
	  kfree(p);    //release malloc
  }
  //printk("leave encode\n");
	return 0;
}

#if 0 //slow encode function
int encode_ecc(unsigned char *src_data, unsigned char *parity, unsigned int ecc_bit, unsigned char *c_len, unsigned int encode_len)
{
	//unsigned char src_data[512];//24
	//unsigned char parity[26];//42
	//unsigned char ecc_bit;
	unsigned char c_len1 = *c_len;
	unsigned int fail;

	//char in_char;
	int i;
	//int j,in_v;



	//for (i=0; i<encode_len; i++) src_data[i] = 0x00;
	// for (i = 0; i < encode_len; i += 2) {
	//		src_data[i] = 0xFF&(jj>>8);
	//		src_data[i+1] = 0xFF&jj;
	//		jj++;
	//		jj %= 0x10000;
	//		src_data[i] = 0x12;
	//		src_data[i+1] = 0x12;
	//	}
/*
	i = 0; j = 0;
	in_char = getchar();
	while (in_char != EOF) {
		in_v = hextoint(in_char);
		if (in_v != -1)	{
			if (j==0)	{
				src_data[i] = 0;
				src_data[i] += in_v * 16;
				j++;
			}	else {
				src_data[i] += in_v;
				i++;
				j = 0;
			}
		}
		in_char = getchar();
	}*/
	//printk("start encode\n");
	fail = wmt_bchencoder(src_data,parity,ecc_bit,&c_len1, encode_len);
	if (fail) 
		printk("----------------Encode Error Detected! code=%d-----------------\n",fail);
	else
		*c_len = c_len1;
	/*printk("\nCodeLengh=%d %d Parity=",*c_len, c_len1);
		for (i=(c_len1-1); i>=0; i--)
			printk("%02x ",parity[i]);
	printk("\n");*/

	return 0;
}

int hextoint(char hex)
// Convert HEX number to Integer
{
	int r, h;
	r = -1;
	h = (int)hex;
	if ((h >= 97) && (h <= 102))
			r = h - 87;
	else if ((h >= 65) && (h <= 70))
			r = h - 55;
	else if ((h >= 48) && (h <= 57))
			r = h - 48;
	else if ((h != 10) && (h != 13))
			printk("Error detected!!! hex=%c",hex);
	return r;
}


// This function is used to encode the BCH code for the input data
// data :        [IN] The information data to be encoded by BCH. The lendth of this buffer is fixed at 512Bytes.
// bch_code :    [OUT] Buffer pointer to keep the BCH code.
// bits :        [IN] The number of bits for the BCH error correcting capability.
// bch_codelen : [IN/OUT] This parameter is used to specify the length of the buffer bch_code in unit of byte for input for the
//               encoder. And will specify the length of encoded bch for the data with error correcting capability bits as output.
// RETURN :      0 indicates success. Nonzero indicates failure.
unsigned int wmt_bchencoder (unsigned char *data, unsigned char *bch_code, unsigned char bits, unsigned char *bch_codelen, unsigned int encode_len)
{
	unsigned char bch_codelen_in;
	unsigned char bch_i;
	/*unsigned char b_data[MAX_BANK_SIZE*8];
	unsigned char bch_sera[MAX_PARITY_SIZE*8];
	unsigned char bch_sera_tmp[MAX_PARITY_SIZE*8];*/
	unsigned char bch_sera_back;
	unsigned int  width;
	unsigned int i,j,k;
	unsigned long retval;
	unsigned char offset;

	unsigned char *bch_GF2;
	/*unsigned char bch_GF_4becc[MAX_PARITY_SIZE*8] = {0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
	unsigned char bch_GF_8becc[MAX_PARITY_SIZE*8] = {0,0,0,1,0,1,0,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,0,1,1,1,0,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
	unsigned char bch_GF_12becc[MAX_PARITY_SIZE*8] = {1,1,1,0,0,1,0,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,0,1,1,0,1,0,0,1,0,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,0,0,1,0,1,0,0,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
	unsigned char bch_GF_16becc[MAX_PARITY_SIZE*8] = {1,1,0,0,1,0,1,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,1,1,0,0,0,1,0,1,0,1,1,0,0,0,1,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,1,1,0,0,0,1,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
	unsigned char bch_GF_24becc[MAX_PARITY_SIZE*8] = {1,0,0,0,1,1,1,0,1,0,0,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,0,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,1,0,0,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,1,0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,0,0,0,1,0,1,0,1,0,1,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,1,0,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
	unsigned char bch_GF_40becc[MAX_PARITY_SIZE*8] = {1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,1,1,1,0,1,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,1,1,0,0,1,0,1,1,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,0,1,0,1,0,1,0,0,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,0,1,1,1,1,1,0,1,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,1,1,1,0,0,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,0,1,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1};*/

	// initialization
	retval = 0;
	for(i=0; i<MAX_PARITY_SIZE*8; i++) {
		bch_sera[i] = 0;
		bch_sera_tmp[i] = 0;
	}

	for (i=0; i <=(encode_len*8); i++) {
	if ((unsigned char)((unsigned int)(1<<(i%8))) & data[i/8])
		b_data[i] = 1;
	else
		b_data[i] = 0;
	}

	// select width and poly-nominal
	switch (bits)	{
		case 4  : width = 51;   bch_GF2 = bch_GF_4becc;              break;
		case 8  : width = 103;  bch_GF2 = bch_GF_8becc;              break;
		case 12 : width = 155;  bch_GF2 = bch_GF_12becc;             break;
		case 16 : width = 207;  bch_GF2 = bch_GF_16becc;             break;
		case 24 : width = 335;  bch_GF2 = bch_GF_24becc;             break;
		case 40 : width = 559;  bch_GF2 = bch_GF_40becc;             break;
		default : width = 51;   bch_GF2 = bch_GF_4becc; retval += 1; break;
	}

	// calculate the parity
	for (k=0; k<(encode_len*8); k++) {
		bch_i = b_data[k];
		bch_sera_back = bch_sera[width] ^ bch_i;
		bch_sera_tmp[0] = bch_sera_back;
		for (i=0; i<width; i++)	{
			bch_sera_tmp[i+1] = bch_sera[i] ^ (bch_sera_back * bch_GF2[width-(i+1)]);
		}
		for (i=0; i<=width; i++)
			bch_sera[i] = bch_sera_tmp[i];
	}

	i = 0;
	bch_code[0] = 0;
	bch_codelen_in = *bch_codelen;
	if(bits == 4 || bits == 12)
		offset = 4;
	else
		offset = 0;
	for (j = 0; j <= width; j++) {
		*bch_codelen = i+1;
		bch_code[i] += bch_sera[j] * (unsigned char)((unsigned int)(1<<(7-((j+offset)%8))));
		if (i>=bch_codelen_in) {
			retval += 2;
			break;
		}
		if((j+offset)%8==7) {
			i++;
			bch_code[i] = 0;
		}
	}

	return(retval);
}
#endif //end of #if 0 : slow encode function

/**
 * wmt_nand_read_page - hardware ecc syndrom based page read
 * @mtd:	mtd info structure
 * @chip:	nand chip info structure
 * @buf:	buffer to store read data
 *
 * The hw generator calculates the error syndrome automatically. Therefor
 * we need a special oob layout and handling.
 */
static int wmt_nand_read_page(struct mtd_info *mtd, struct nand_chip *chip,
						 uint8_t *buf, int page)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	int i = 0;
#ifdef CONFIG_MTD_NAND_RANDOMIZER
	unsigned int rdmz_mark = 0;
	unsigned char fifo[24];
#endif
	int status = -1, eslcpage_base = 0, eslcpage_mod = 0, base_page = 0, base_page_end = 0, eslcblk_base = 0;
	int good_blk = 0, bad_blk = 0, base_blk, base_blk_end, j, blk_page_shift;
	unsigned int blk_ofs = 0;

	#ifdef NAND_DEBUG
		printk(KERN_NOTICE "\r enter in wmt_nand_read_page()page=0x%x\n", page);
	#endif
	
	if (chip->cur_chip && chip->cur_chip->nand_id == 0xADD794DA && whole_eslc == 1) {
		/*int tmp_page = page;*/
		eslcpage_mod = page%mtd->pagecnt;
		eslcpage_base = (page - eslcpage_mod) << 1;
		if (prob_end == 0 && eslcpage_mod == (mtd->pagecnt-1)) {
			page = eslcpage_base + eslcpage_mod*2+1;
		} else {
			page = eslcpage_base + eslc_map_table[eslcpage_mod];
		}
		/*printk(KERN_NOTICE "dan data copy page=0x%x eslcpage = 0x%x\n",tmp_page, page);*/
	} else if (chip->cur_chip && prob_end == 1 && (chip->cur_chip->nand_id>>24) == NAND_MFR_HYNIX && whole_eslc != 1) {
		if (page < par4_ofs) {
			eslcpage_mod = page%mtd->pagecnt;
			eslcpage_base = page - eslcpage_mod;
	
			if (page < par1_ofs) {
				base_page = 0;
				base_page_end = par1_ofs;
			} else if (page < par2_ofs) {
				base_page = par1_ofs;
				base_page_end = par2_ofs;
			} else if (page < par3_ofs) {
				base_page = par2_ofs;
				base_page_end = par3_ofs;
			} else {
				base_page = par3_ofs;
				base_page_end = par4_ofs;
			}
			blk_page_shift = chip->phys_erase_shift - chip->page_shift;
			eslcblk_base = eslcpage_base >> blk_page_shift;
			base_blk = base_page >> blk_page_shift;
			base_blk_end = base_page_end >> blk_page_shift;
			blk_ofs = ((eslcpage_base) - base_page) >> blk_page_shift;
			
			for (j = base_blk; j < eslcblk_base; j++) {
				status = wmt_isbad_bbt(mtd, chip, j);
				if (status) {
					#ifdef ELSC_DEBUG
					if (eslcpage_mod == 0 || eslcpage_mod == (mtd->pagecnt/2))
						printk("skip blk%d bad\n", j);
					#endif
					bad_blk++;
				}
			}
			blk_ofs = blk_ofs - bad_blk;
			blk_ofs = blk_ofs*2 + ((eslcpage_mod >= (mtd->pagecnt/2)) ? 1 : 0);

			for (i = base_blk; i < base_blk_end; i++) {
				status = wmt_isbad_bbt(mtd, chip, i);
				if (status == 0) {
					#ifdef ELSC_DEBUG
					if (eslcpage_mod == 0 || eslcpage_mod == (mtd->pagecnt/2))
						printk("read_page: blk%d good\n",i);
					#endif
					good_blk++;
				} 
				#ifdef ELSC_DEBUG 
				else {
					if (eslcpage_mod == 0 || eslcpage_mod == (mtd->pagecnt/2))
						printk("read_page: skip blk%d bad\n", i);
					continue;
				}
				#endif
				if (good_blk >= (blk_ofs + 1)) {
					#ifdef ELSC_DEBUG
					if (eslcpage_mod == 0 || eslcpage_mod == (mtd->pagecnt/2))
						printk("read_page: read blk%d \n",i);
					#endif
					break;
				}
			}
			if (i >= base_blk_end) {
				printk(KERN_ERR "eslc read_page is out of partition size, skip page=0x%x, base_page_end=%x\n", page, base_page_end);
				return -1;
			}
			blk_ofs = i << blk_page_shift;
			
			#ifdef ELSC_DEBUG
			if (eslcpage_mod == 0 || eslcpage_mod == (mtd->pagecnt/2))
				printk("read_page eslc bf page=0x%x eslc page = 0x%x\n", page, blk_ofs + eslc_map_table[(eslcpage_mod%(mtd->pagecnt/2))]);
			#endif
			page = blk_ofs + eslc_map_table[(eslcpage_mod%(mtd->pagecnt/2))];
		}
	}
	
	info->datalen = 0;
	chip->read_buf(mtd, buf, mtd->writesize);

#ifdef CONFIG_MTD_NAND_RANDOMIZER
    if(mtd->is_randomizer) {
		if(mtd->id == 0x98de9482 || mtd->id == 0x98de8493) {
			for(i = 0; i < 24; i++)
				fifo[i] = *((uint8_t *)(info->reg+ECC_FIFO_0 + i));
			normalize_data(page, mtd->writesize, 24, fifo);
			rdmz_mark = *(unsigned int*)&fifo[20];
			if ((*(unsigned int *)(info->reg+ECC_FIFO_5)) == (*(unsigned int *)wmt_rdmz) || rdmz_mark == (*(unsigned int *)wmt_rdmz)) {
				normalize_data(page, 0, mtd->writesize, buf);
			}
		} else { 
			rdmzier_oob((uint8_t *)&rdmz_mark, (uint8_t *)(info->reg+ECC_FIFO_5), 1, page, (mtd->writesize+20)/4);
			if ((*(unsigned int *)(info->reg+ECC_FIFO_5)) == (*(unsigned int *)wmt_rdmz) || rdmz_mark == (*(unsigned int *)wmt_rdmz)) {
			    rdmzier(buf, mtd->writesize/4, page);
			}
	    }
	}
#endif
	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "\r enter in nand_read_page(): mtd->writesize is %d and oobsize is %d\n",
	mtd->writesize, mtd->oobsize);
	#endif
	/* memcpy(chip->oob_poi, info->reg+ECC_FIFO_0, mtd->oobsize);*/
	/* memset(chip->oob_poi, 0xff, mtd->oobsize);*/
	if (mtd->writesize == 2048) {
		/* writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & 0xF7,
		info->reg + WMT_NFC_CALC_CTRL);*/
		memcpy(chip->oob_poi, info->reg+ECC_FIFO_0, mtd->oobsize);
	} else if (mtd->writesize == 4096 || mtd->writesize >= 8192) {
		/* dannier test 0x34 are used or not when not hamming mode*/
		writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & 0xF7,
		info->reg + WMT_NFC_CALC_CTRL);
#ifdef CONFIG_MTD_NAND_RANDOMIZER
		if(mtd->is_randomizer) {
			if(mtd->id == 0x98de9482 || mtd->id == 0x98de8493) {
				if(rdmz_mark == (*(unsigned int *)wmt_rdmz))
					memcpy(chip->oob_poi, fifo, 20);
				else
					memcpy(chip->oob_poi, info->reg+ECC_FIFO_0, 20);
			} else {
				if(rdmz_mark == (*(unsigned int*)wmt_rdmz))
					rdmzier_oob((uint8_t *)chip->oob_poi, (uint8_t *)(info->reg+ECC_FIFO_0), 5/*20/4*/, page, mtd->writesize/4);
				else
					memcpy(chip->oob_poi, info->reg+ECC_FIFO_0, 20);
			}
		} else {
			memcpy(chip->oob_poi, info->reg+ECC_FIFO_0, 20);
		}
#else
		memcpy(chip->oob_poi, info->reg+ECC_FIFO_0, 20);
#endif

	} else {  /* pagesize = 512 */
		/* only reduntant area read enable */
		memcpy(chip->oob_poi, info->reg+ECC_FIFO_0, mtd->oobsize);
		#ifndef PAGE_READ_COUNTER
			writeb(readb(info->reg + WMT_NFC_SMC_ENABLE) & 0xfd,
			info->reg + WMT_NFC_SMC_ENABLE);
		#endif
		/* memcpy(chip->oob_poi, info->reg+ECC_FIFO_0, mtd->oobsize);*/
	}

	#if 0
	/* for debug  */
	int i;
	/* printk(KERN_NOTICE "data aera is -------------------------\n");*/
	/* for (i = 0; i < mtd->writesize; i += 4) {*/
	/* printk(KERN_NOTICE "%x %x %x %x\n",
	info->dmabuf[i], info->dmabuf[i+1], info->dmabuf[i+2], info->dmabuf[i+3]);*/
	/* }*/
	printk(KERN_NOTICE "spare aera is -------------------------\n");
	for (i = 0; i < mtd->oobsize; i += 4)
		printk(KERN_NOTICE "%x %x %x %x\n",
		chip->oob_poi[i], chip->oob_poi[i+1], chip->oob_poi[i+2], chip->oob_poi[i+3]);
	#endif

 /*   memcpy(chip->oob_poi, info->reg+ECC_FIFO_0, mtd->oobavail);*/
 /*   chip->read_buf(mtd, chip->oob_poi, mtd->oobavail); */  /* ????  */
	return 0;
}

/**
 *  wmt_nand_write_page_lowlevel - hardware ecc syndrom based page write
 *  @mtd:    mtd info structure
 *  @chip:  nand chip info structure
 *  @buf:  data buffer
 *
 *  The hw generator calculates the error syndrome automatically. Therefor
 *  we need a special oob layout and handling.
 *
 */
static void wmt_nand_write_page_lowlevel(struct mtd_info *mtd, struct nand_chip *chip, const uint8_t *buf)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	struct ECC_size_info ECC_size;
	unsigned char ecc_bit = 24/*40*/, c_len = 42;//70
	unsigned char *FIFO6 = (unsigned char *)(info->reg + ECC_FIFO_6);
	unsigned char *FIFO0 = (unsigned char *)(info->reg + ECC_FIFO_0);
	int status;
	//unsigned int now_time = 0, delay_time = 0;
	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "enter in wmt_nand_page_write_lowlevel() writesize %x\n", mtd->writesize);
	#endif
	unsigned int b2r_stat, data_len = 24, i;
	info->dma_finish = 0;
	b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
	writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);
	writeb(0x07, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
	info->datalen = 0;
	chip->write_buf(mtd, buf, mtd->writesize);
	wmt_nfc_dma_cfg(mtd, mtd->writesize, 1, 0, -1);  /*  2048bytes  */

	/* for debug  */
	#if 0
	int i;
	/* printk(KERN_NOTICE "data aera is -------------------------\n");*/
	/* for (i = 0; i < mtd->writesize; i += 4) {*/
	/* printk(KERN_NOTICE "%x %x %x %x\n",
	info->dmabuf[i], info->dmabuf[i+1], info->dmabuf[i+2], info->dmabuf[i+3]);*/
	/* info->dmabuf[i] = 0;*/
	/* info->dmabuf[i+1] = 0;*/
	/* info->dmabuf[i+2] = 0;*/
	/* info->dmabuf[i+3] = 0;*/
	/*  }*/
	printk(KERN_NOTICE "spare aera is -------------------------\n");
	for (i = 0; i < mtd->oobsize; i += 4)
		printk(KERN_NOTICE "%x %x %x %x\n",
		chip->oob_poi[i], chip->oob_poi[i+1], chip->oob_poi[i+2], chip->oob_poi[i+3]);
	#endif

	ECC_size.ecc_engine = info->ECC_mode;
	calculate_ECC_info(mtd, &ECC_size);
	ecc_bit = ECC_size.oob_max_bit_error;
	c_len = ECC_size.oob_ECC_bytes;
	
#ifdef CONFIG_MTD_NAND_RANDOMIZER
	if(mtd->is_randomizer)
	    *(unsigned int *)(chip->oob_poi + 20) = *(unsigned int *)wmt_rdmz;
#endif

	if (mtd->writesize == 2048) {
		/* writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & 0xF7, info->reg + WMT_NFC_CALC_CTRL);*/
		memcpy(info->reg+ECC_FIFO_0, chip->oob_poi, 20);
		//status = encode_ecc((unsigned char *)chip->oob_poi, parity, ecc_bit, &c_len, data_len);
		bch_encoder((unsigned int *)parity, (unsigned int *)chip->oob_poi, ecc_bit, data_len/4);
		for (i = 0; i < c_len; i++) {
			if (i >= 40) {
				writeb(readb(info->reg + WMT_NFC_CALC_CTRL) | 0x08,
				info->reg + WMT_NFC_CALC_CTRL);
				FIFO0[i-40] = parity[i];//parity[c_len-i-1];
			} else
				FIFO6[i] = parity[i];//parity[c_len-i-1];
		}
		writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & 0xF7,
		info->reg + WMT_NFC_CALC_CTRL);

	} else if (mtd->writesize == 4096 || mtd->writesize >= 8192) {
		writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & 0xF7,
		info->reg + WMT_NFC_CALC_CTRL);
#ifdef CONFIG_MTD_NAND_RANDOMIZER
		if(mtd->is_randomizer) {
			if(mtd->id == 0x98de9482 || mtd->id == 0x98de8493) {
				randomize_data(info->cur_page, mtd->writesize, 24, (uint8_t *)chip->oob_poi, (uint8_t*)(info->reg + ECC_FIFO_0));
			} else {
				rdmzier_oob((uint8_t *)(info->reg+ECC_FIFO_0), (uint8_t *)chip->oob_poi, 6/*20/4*/, info->cur_page, mtd->writesize/4);
			}
		} else {
			memcpy(info->reg+ECC_FIFO_0, chip->oob_poi, 20);
		}
#else
		memcpy(info->reg+ECC_FIFO_0, chip->oob_poi, 20);
#endif
		//now_time = wmt_read_oscr();
		//status = encode_ecc((unsigned char *)chip->oob_poi, parity, ecc_bit, &c_len, data_len);
		status = bch_encoder((unsigned int *)parity, (unsigned int *)chip->oob_poi, ecc_bit, data_len/4);
		//delay_time = wmt_read_oscr() - now_time;
		//printk(KERN_NOTICE"encode_t =%d \n", delay_time/3);
		for (i = 0; i < c_len; i++) {
			if (i >= 40) {
				writeb(readb(info->reg + WMT_NFC_CALC_CTRL) | 0x08,
				info->reg + WMT_NFC_CALC_CTRL);
				FIFO0[i-40] = parity[i];//parity[c_len-i-1];
			} else
				FIFO6[i] = parity[i];//parity[c_len-i-1];
		}
		writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & 0xF7,
		info->reg + WMT_NFC_CALC_CTRL);

	} else {
		memcpy(info->reg+ECC_FIFO_0, chip->oob_poi, 20);
		//status = encode_ecc((unsigned char *)chip->oob_poi, parity, ecc_bit, &c_len, data_len);
		bch_encoder((unsigned int *)parity, (unsigned int *)chip->oob_poi, ecc_bit, data_len/4);
		for (i = 0; i < c_len; i++) {
			if (i >= 40) {
				writeb(readb(info->reg + WMT_NFC_CALC_CTRL) | 0x08,
				info->reg + WMT_NFC_CALC_CTRL);
				FIFO0[i-40] = parity[i];//parity[c_len-i-1];
			} else
				FIFO6[i] = parity[i];//parity[c_len-i-1];
		}
		writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & 0xF7,
		info->reg + WMT_NFC_CALC_CTRL);
	}
	/* memcpy(info->reg+ECC_FIFO_0, chip->oob_poi, mtd->oobavail);*/
	/* chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);*/
}


#include <linux/vmalloc.h>
static int wmt_nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
const uint8_t *buf, int page, int cached, int raw)
{
	int status, i, j, eslcpage_mod = 0, eslcpage_base = 0, base_page = 0, eslcblk_base;
	int base_page_end, base_blk, base_blk_end, bad_blk = 0, good_blk = 0, blk_page_shift = 0;
	unsigned int blk_ofs = 0;
	unsigned int tmp_page = 0;
	//#ifdef NAND_BBT_BCH_ECC
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	//#endif
	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "enter in wmt_nand_write_page()\n");
	printk(KERN_NOTICE "raw = %d, and ecc_type = %d\n", raw, ecc_type);
	#endif

	if (chip->cur_chip && chip->cur_chip->nand_id == 0xADD794DA && whole_eslc == 1) {
		/*int tmp_page = page;*/
		eslcpage_mod = page%mtd->pagecnt;
		eslcpage_base = (page - eslcpage_mod) << 1;
		if (prob_end == 0 && eslcpage_mod == (mtd->pagecnt-1)) {
			page = eslcpage_base + eslcpage_mod*2+1;
		} else {
			page = eslcpage_base + eslc_map_table[eslcpage_mod];
		}
		/*printk(KERN_NOTICE "dan cmd=0x80-- page=0x%x eslcpage = 0x%x\n",tmp_page, page);*/
	} else if (chip->cur_chip && (chip->cur_chip->nand_id>>24) == NAND_MFR_HYNIX && whole_eslc != 1) {
		if (page < par4_ofs) {
			tmp_page = page;
			eslcpage_mod = page%mtd->pagecnt;
			eslcpage_base = page - eslcpage_mod;
			if (page < par1_ofs) {
				base_page = 0;
				base_page_end = par1_ofs;
			} else if (page < par2_ofs) {
				base_page = par1_ofs;
				base_page_end = par2_ofs;
			} else if (page < par3_ofs) {
				base_page = par2_ofs;
				base_page_end = par3_ofs;
			} else  {
				base_page = par3_ofs;
				base_page_end = par4_ofs;
			}
			blk_page_shift = chip->phys_erase_shift - chip->page_shift;
			eslcblk_base = eslcpage_base >> blk_page_shift;
			base_blk = base_page >> blk_page_shift; 
			base_blk_end = base_page_end >> blk_page_shift;
			blk_ofs = ((eslcpage_base) - base_page) >> blk_page_shift;

			for (j = base_blk; j < eslcblk_base; j++) {
				status = wmt_isbad_bbt(mtd, chip, j);
				if (status) {
					#ifdef ELSC_DEBUG
					if (eslcpage_mod == 0 || eslcpage_mod == (mtd->pagecnt/2))
						printk("skip blk%d bad\n", j);
					#endif
					bad_blk++;
				}
			}
			blk_ofs = blk_ofs - bad_blk;
			blk_ofs = blk_ofs*2 + ((eslcpage_mod >= (mtd->pagecnt/2)) ? 1 : 0);

			for (i = base_blk; i < base_blk_end; i++) {
				status = wmt_isbad_bbt(mtd, chip, i);
				if (status == 0) {
					#ifdef ELSC_DEBUG
					if (eslcpage_mod == 0 || eslcpage_mod == (mtd->pagecnt/2))
						printk("write_page: blk%d good\n",i);
						#endif
					good_blk++;
				} 
				#ifdef ELSC_DEBUG
				else {
					if (eslcpage_mod == 0 || eslcpage_mod == (mtd->pagecnt/2))
						printk("write_page: skip blk%d bad\n", i);
					continue;
				}
				#endif
				if (good_blk >= (blk_ofs + 1)) {
					#ifdef ELSC_DEBUG
					if (eslcpage_mod == 0 || eslcpage_mod == (mtd->pagecnt/2))
						printk("write blk%d \n",i);
					#endif
					break;
				}
			}
			if (i >= base_blk_end) {
				if (eslcpage_mod == 0 || eslcpage_mod == (mtd->pagecnt/2))
					printk(KERN_ERR "eslc write is out of partition size, skip page=0x%x, base_page_end=0x%x, end_blk=%d\n",
				page, base_page_end, i);
				return 0;
			}
			blk_ofs = i << blk_page_shift;
			
			if (eslc_write != 2) {
				#ifdef ELSC_DEBUG
				printk(KERN_NOTICE "page=0x%x----ENABLE ESLC\n", page);
				#endif
				eslc_write = 2;
				chip->cur_chip->set_parameter(mtd, ESLC_MODE, ECC_ERROR_VALUE);
			}

			#ifdef ELSC_DEBUG
			if (eslcpage_mod == 0 || eslcpage_mod == (mtd->pagecnt/2))
				printk(KERN_NOTICE "eslc mode write page=0x%x => eslc page = 0x%x\n",
			page, blk_ofs + eslc_map_table[(eslcpage_mod%(mtd->pagecnt/2))]);
			#endif
			page = blk_ofs + eslc_map_table[(eslcpage_mod%(mtd->pagecnt/2))];
			if(tmp_page%(mtd->pagecnt/2) == 0) {
				chip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page);
				chip->cmdfunc(mtd, NAND_CMD_ERASE2, -1, -1);
				#ifdef ELSC_DEBUG
				printk("eslc mode erase page=0x%x => eslc page = 0x%x\n", page, blk_ofs + eslc_map_table[(eslcpage_mod%(mtd->pagecnt/2))]);
				#endif
			}
		} else if (page >= (mtd->blkcnt-8)*mtd->pagecnt) {
			if (eslc_write != 2) {
				#ifdef ELSC_DEBUG
				printk(KERN_NOTICE "page=0x%x----ENABLE ESLC(BBT)\n", page);
				#endif
				eslc_write = 2;
				chip->cur_chip->set_parameter(mtd, ESLC_MODE, ECC_ERROR_VALUE);
			}
		} else if (eslc_write == 2) {
			chip->cur_chip->set_parameter(mtd, ESLC_MODE, DEFAULT_VALUE);
			eslc_write = 0;
			#ifdef ELSC_DEBUG
			printk(KERN_NOTICE "page=0x%x****DIS ESLC\n", page);
			#endif
		} 
	}

	info->cur_page = page;
	#ifdef CONFIG_MTD_NAND_RANDOMIZER
	if(mtd->is_randomizer) {
		memcpy(buffer_ramdomizer, buf, mtd->writesize);
		if(mtd->id == 0x98de9482 || mtd->id == 0x98de8493) {
//			printk(KERN_WARNING "randomize page data excute.. page = 0x%x\n", page);
			randomize_data(page, 0, mtd->writesize, buffer_ramdomizer, buffer_ramdomizer);
		} else {
		//	printk("write page rdmzier page data 0x%x\n", page);
			rdmzier(buffer_ramdomizer, mtd->writesize/4, page);
		}
		info->datalen = 0;
		chip->ecc.write_page(mtd, chip, buffer_ramdomizer);
	} else {
		info->datalen = 0;
		chip->ecc.write_page(mtd, chip, buf);
	}
	#else
	/*prinik(KERN_NOTICE "wmt_nand_write_page() write begin\n");*/
	info->datalen = 0;
	chip->ecc.write_page(mtd, chip, buf);
	#endif
		/*   }*/
	chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);
	status = nand_pdma_handler(mtd);
	nand_free_pdma(mtd);
	if (status)
		printk(KERN_ERR "check write pdma handler status= %x \n", status);

	/*
	 * *   * Cached progamming disabled for now, Not sure if its worth the
	 * *       * trouble. The speed gain is not very impressive. (2.3->2.6Mib/s)
	 * *           */
	cached = 0;

	if (!cached || !(chip->options & NAND_CACHEPRG)) {

		chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
		status = chip->waitfunc(mtd, chip);
		writeb(0x80, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
		/*
		* * See if operation failed and additional status checks are
		* * available
		* *      */
		if ((status & NAND_STATUS_FAIL) && (chip->errstat))
			status = chip->errstat(mtd, chip, FL_WRITING, status,	page);

		if (status & NAND_STATUS_FAIL)
		{
			goto GO_EIO;//return -EIO;
		}
	} else {
		chip->cmdfunc(mtd, NAND_CMD_CACHEDPROG, -1, -1);
		status = chip->waitfunc(mtd, chip);
	}


	#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
	/* Send command to read back the data */
	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);

	if (chip->verify_buf(mtd, buffer_ramdomizer, mtd->writesize))
	{
		goto GO_EIO;//return -EIO;
	}
	#endif
	/*if (set_eslc == 1 && page >= ((mtd->blkcnt-8)*mtd->pagecnt)) {
		chip->cur_chip->set_parameter(mtd, ESLC_MODE, DEFAULT_VALUE);
		eslc_write = 0;
		printk(KERN_NOTICE "dis eslc\n");
	}*/
	return 0;

GO_EIO:
	/*if (set_eslc == 1) {
		printk(KERN_NOTICE "dis eslc\n");
		eslc_write = 0;
		chip->cur_chip->set_parameter(mtd, ESLC_MODE, DEFAULT_VALUE);
	}*/
	return -EIO;
}


/* wmt_nand_init_chip
 *
 * init a single instance of an chip
 */

static void wmt_nand_init_chip(struct wmt_nand_info *info, struct wmt_nand_mtd *nmtd,
struct ECC_size_info *ECC_size)
{
	struct nand_chip *chip = &nmtd->chip;
	struct mtd_info *mtd = &nmtd->mtd;

	#if 0
	chip->cmdfunc      = wmt_nand_cmdfunc;
	chip->dev_ready    = wmt_device_ready;
	chip->read_byte    = wmt_read_byte;
	chip->write_buf    = wmt_nand_write_buf;
	chip->read_buf     = wmt_nand_read_buf;
	chip->select_chip  = wmt_nand_select_chip;
	chip->chip_delay   = 20;
	chip->priv	   = nmtd;
	chip->options	   = 0;
	chip->controller   = &info->controller;
	#endif

	/* chip->cmd_ctrl  = wmt_nand_hwcontrol;*/
	#if 0
	switch (info->cpu_type) {
	case TYPE_wmt:
		break;

	case TYPE_vt8620:
		break;

	case TYPE_vt8610:
		break;
	}
	#endif

	/* nmtd->set	   = set;*/
	if (hardware_ecc) {
		/*	chip->ecc.calculate = wmt_nand_calculate_ecc;*/
		/*	chip->ecc.correct   = wmt_nand_correct_data;*/

		if (mtd->writesize == 2048) {
			chip->ecc.size      = 512;
			chip->ecc.bytes     = 8;
			chip->ecc.steps     = 4;
			/*chip->ecc.layout    = &wmt_oobinfo_2048;*/
			chip->ecc.prepad    = 1;
			chip->ecc.postpad   = 8;
		} else if (mtd->writesize == 4096) {
			chip->ecc.size      = 512;
			if (ECC8BIT_ENGINE == 1)
				chip->ecc.bytes     = 20;
			//chip->ecc.bytes     = 16;
			else
			chip->ecc.bytes     = 8;

			chip->ecc.steps     = 8;
			/*chip->ecc.layout    = &wmt_oobinfo_4096;*/
			chip->ecc.prepad    = 1;
			chip->ecc.postpad   = 8;
		} else if (mtd->writesize == 8192) {
			chip->ecc.size      = 1024;
			chip->ecc.bytes     = 42;
			chip->ecc.steps     = 8;
			/*chip->ecc.layout    = &wmt_oobinfo_8192;*/
			chip->ecc.prepad    = 1;
			chip->ecc.postpad   = 8;
		} else if (mtd->writesize == 16384) {
			chip->ecc.size      = 1024;
			chip->ecc.bytes     = 70;
			chip->ecc.steps     = 16;
			/*chip->ecc.layout    = &wmt_oobinfo_16k;*/
			chip->ecc.prepad    = 1;
			chip->ecc.postpad   = 8;
		} else {   /*  512 page   */
			chip->ecc.size      = 512;
			chip->ecc.bytes      = 3;
			chip->ecc.steps     = 1;
			/*chip->ecc.layout    = &wmt_oobinfo_512;*/
			chip->ecc.prepad    = 4;
			chip->ecc.postpad   = 9;
		}
		if (mtd->writesize != 512) {
			chip->ecc.size      = (mtd->writesize/ECC_size->banks);
			chip->ecc.bytes     = ECC_size->ECC_bytes;
			chip->ecc.steps     = ECC_size->banks;
		}

		chip->write_page = wmt_nand_write_page;
		chip->ecc.write_page = wmt_nand_write_page_lowlevel;
		chip->ecc.write_oob = wmt_nand_write_oob;
		chip->ecc.read_page = wmt_nand_read_page;
		chip->ecc.read_oob = wmt_nand_read_oob;

		chip->ecc.read_bb_oob = wmt_nand_read_bb_oob;

		/*	switch (info->cpu_type) {*/
		/*	case TYPE_wmt:*/
		chip->ecc.hwctl	    = wmt_nand_enable_hwecc;
		/*	chip->ecc.calculate = wmt_nand_calculate_ecc;*/
		/*	break;*/
	#if 0
	case TYPE_vt8620:
		chip->ecc.hwctl     = vt8620_nand_enable_hwecc;
		chip->ecc.calculate = vt86203_nand_calculate_ecc;
		break;

	case TYPE_vt8610:
		chip->ecc.hwctl     = vt8610_nand_enable_hwecc;
		chip->ecc.calculate = vt8610_nand_calculate_ecc;
		break;
		}
	#endif
	} else
		chip->ecc.mode	    = NAND_ECC_SOFT;
}


static int wmt_nand_remove(struct platform_device *pdev)
{
	struct wmt_nand_info *info = dev_get_drvdata(&pdev->dev);

	/*  struct mtd_info *mtd = dev_get_drvdata(pdev);*/
	dev_set_drvdata(&pdev->dev, NULL);
	/*  platform_set_drvdata(pdev, NULL);*/
	/*  dev_set_drvdata(pdev, NULL);*/
	if (info == NULL)
		return 0;

	/* first thing we need to do is release all our mtds
	 * and their partitions, then go through freeing the
	 * resources used
	 */

	if (info->mtds != NULL) {
		struct wmt_nand_mtd *ptr = info->mtds;
	/* int mtdno;*/

	/* for (mtdno = 0; mtdno < info->mtd_count; mtdno++, ptr++) {*/
	/*     pr_debug("releasing mtd %d (%p)\n", mtdno, ptr);*/
		nand_release(&ptr->mtd);
	/*  }*/
		kfree(info->mtds);
	}

	/* free the common resources */

	if (info->reg != NULL) {
		//iounmap(info->reg);
		info->reg = NULL;
	}

	if (info->area != NULL) {
		release_resource(info->area);
		kfree(info->area);
		info->area = NULL;
	}
	kfree(info);
	vfree(buffer_ramdomizer);
	return 0;
}

#ifdef CONFIG_MTD_CMDLINE_PARTS

extern int mtdpart_setup(char *);

static int __init add_dynamic_parts(struct mtd_info *mtd)
{
	static const char *part_parsers[] = { "cmdlinepart", NULL };
	struct mtd_partition *parts;
	/*const struct omap_flash_part_config *cfg;
	char *part_str = NULL;
	size_t part_str_len;*/
	int c;

	/*cfg = omap_get_var_config(OMAP_TAG_FLASH_PART, &part_str_len);
	if (cfg != NULL) {
		part_str = kmalloc(part_str_len + 1, GFP_KERNEL);
		if (part_str == NULL)
			return -ENOMEM;
		memcpy(part_str, cfg->part_table, part_str_len);
		part_str[part_str_len] = '\0';
		mtdpart_setup(part_str);
	}*/
	c = parse_mtd_partitions(mtd, part_parsers, &parts, 0);
	/*if (part_str != NULL) {
		mtdpart_setup(NULL);
		kfree(part_str);
	}*/
	if (c <= 0)
		return -1;

 	mtd_device_register(mtd, parts, c);
	//add_mtd_partitions(mtd, parts, c);

	return 0;
}

#else

static inline int add_dynamic_parts(struct mtd_info *mtd)
{
	return -1;
}

#endif

	
/*Lch */
static int wmt_recovery_call(struct notifier_block *nb, unsigned long code, void *_cmd)
{
	struct mtd_info *mtd;
	struct nand_chip *chip;

	mtd = container_of(nb, struct mtd_info, reboot_notifier);
	chip = (struct nand_chip *)mtd->priv;
	if(chip->cur_chip && (mtd->id >>24 == NAND_MFR_HYNIX)) {
		*(volatile unsigned long *)PMCEU_ADDR |= (0x0010000);
		#ifdef RETRY_DEBUG
		printk("current try times: %d\n", chip->cur_chip->cur_try_times);
		#endif
		chip->select_chip(mtd, 0);
		chip->cur_chip->set_parameter(mtd, READ_RETRY_MODE, DEFAULT_VALUE);
		//chip->cur_chip->get_parameter(mtd,READ_RETRY_MODE);
		chip->select_chip(mtd, -1);
	}
	return NOTIFY_DONE;

#if 0
	mtd = container_of(nb, struct mtd_info, reboot_notifier);

	if((code == SYS_RESTART) && _cmd) {
		char *cmd = _cmd;
		if  (!strcmp(cmd, "recovery")) {
			err = search_mtd_table("android-data", &ret1);
			ret = (int)ret1;
			if (!err) {
			//	printk(KERN_EMERG "Lch jump2 android-data wmt_recovery_call.ret =%d\n",ret);
				struct erase_info einfo;
				loff_t to;
				memset(&einfo, 0, sizeof(einfo));
				to = nand_partitions[ret].offset;
				einfo.mtd = mtd;
				einfo.addr = (unsigned long)to;
				einfo.len = nand_partitions[ret].size;

			//	printk("android-data einfo.addr is %8.8x\n",einfo.addr);
			//	printk("android-data einfo.len is %8.8x\n",einfo.len);
			//	printk("android-data nand_partitions[%d].offset is %8.8x\n",ret,nand_partitions[ret].offset);
			//	printk("android-data nand_partitions[%d].size is %8.8x\n",ret,nand_partitions[ret].size);
				ret = nand_erase_nand(mtd, &einfo, 0xFF);
				if (ret < 0)
					printk("enand_erase_nand result is %x\n",ret);
			}

			err = search_mtd_table("android-cache", &ret1);
			ret = (int)ret1;
			if (!err) {
			//	printk(KERN_EMERG "Lch jump3 wmt_recovery_call.android-cache ret=%d\n",ret);
				struct erase_info einfo;
				loff_t to;
				memset(&einfo, 0, sizeof(einfo));
				to = nand_partitions[ret].offset;
				einfo.mtd = mtd;
				einfo.addr = (unsigned long)to;
				einfo.len = nand_partitions[ret].size;

			//	printk("android-cache einfo.addr is %8.8x\n",einfo.addr);
			//	printk("android-cache einfo.len is %8.8x\n",einfo.len);
			//	printk("android-data nand_partitions[%d].offset is %8.8x\n",ret,nand_partitions[ret].offset);
			//	printk("android-data nand_partitions[%d].size is %8.8x\n",ret,nand_partitions[ret].size);
				ret = nand_erase_nand(mtd, &einfo, 0xFF);
				if (ret < 0)
					printk("enand_erase_nand result is %x\n",ret);
			}
		}
	}


	return NOTIFY_DONE;
#endif
}

/**********************************************************************
Name  	 : nfc_pdma_isr
Function    :.
Calls		:
Called by	:
Parameter :
Author 	 : Dannier Chen
History	:
***********************************************************************/
static irqreturn_t nfc_pdma_isr(int irq, void *dev_id)
{
	struct wmt_nand_info *info = (struct wmt_nand_info *)dev_id;
	disable_irq_nosync(irq);
	//spin_lock(&host->lock);
	writel(0, info->reg + NFC_DMA_IER);
	//writel(/*readl(info->reg + NFC_DMA_ISR)&*/NAND_PDMA_IER_INT_STS, info->reg + NFC_DMA_ISR);
	//printk(" pdmaisr finish NFC_DMA_ISR=0x%x\n", readl(info->reg + NFC_DMA_ISR));
	//print_nand_register(info);
	info->dma_finish = 1;
	WARN_ON(info->done_data == NULL);
	complete(info->done_data);
	info->done_data = NULL;
	//info->done = NULL;
	//spin_unlock(&host->lock);
	enable_irq(irq);

	return IRQ_HANDLED;
}

/**********************************************************************
Name  	 : nfc_regular_isr
Function    :.
Calls		:
Called by	:
Parameter :
Author 	 : Dannier Chen
History	:
***********************************************************************/
//static irqreturn_t nfc_regular_isr(int irq, void *dev_id, struct pt_regs *regs)
irqreturn_t nfc_regular_isr(int irq, void *dev_id)
{

	struct wmt_nand_info *info = dev_id;
	struct mtd_info	*mtd = &info->mtds->mtd;
	unsigned int bank_stat1, bank_stat2=0,status = 0;

	disable_irq_nosync(irq);
	//spin_lock(&host->lock);
	//printk("isrCMD=0x%x\n", info->isr_cmd);
	//status = (readb(info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK)&0xFF);
	if (info->isr_cmd != 0 /*&& status*/) {
		/* only erase/write/read_oob operation enable B2R interrupt */
		//printk("isrCMD=0x%x\n", info->isr_cmd);
		status = (readb(info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK)&0xFF);
		if (status != 0x7) {
			printk("error: isr is not check busy interrup =0x%x, cmd = 0x%x\n", status, info->isr_cmd);
			dump_stack();
			//while(info->isr_cmd);
		}
		writeb(0x0F, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
		if (readb(info->reg + WMT_NFC_HOST_STAT_CHANGE) & B2R) {
			writeb(B2R, info->reg + WMT_NFC_HOST_STAT_CHANGE);
			if (readb(info->reg + WMT_NFC_HOST_STAT_CHANGE) & B2R)
				printk("[nfc_isr] B2R staus can't clear\n");
			/*if (info->isr_cmd == 0x50)
				printk("50 isr B2R info->cur_page=0x%x\n",info->cur_page);*/
			//goto isr_complete;
			WARN_ON(info->done_data == NULL);
			complete(info->done_data);
			info->done_data = NULL;
		}
	}
	if (info->isr_cmd == 0 || info->isr_cmd == 0x50) {
		wmt_wait_nfc_ready(info);
		bank_stat1 = readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT1);
		if (bank_stat1&(ERR_CORRECT | BCH_ERR)) {
			while (bank_stat1 != (ERR_CORRECT | BCH_ERR)) {
				//printk("1ECC status = 0x%x\n", bank_stat1);
				bank_stat2++;
				bank_stat1 = readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT1);
				//printk("2ECC status = 0x%x\n", bank_stat2);
				if (bank_stat2 >= 0x10000)
					break;
			}
			//printk("dma isrCMD=0x%x\n", info->isr_cmd);
			//printk("isrRe ecc err count = 0x%x\n", bank_stat2);
			if ((bank_stat1 & (ERR_CORRECT | BCH_ERR)) == (ERR_CORRECT | BCH_ERR)) {
				bank_stat2 = readw(info->reg + WMT_NFC_ECC_BCH_CTRL);
				/* 0: data, 1: reduntant area */
				//data_redunt_flag = bank_stat2 & 0x10;
				#ifdef NAND_DEBUG
				printk(KERN_NOTICE" BCH Read data ecc eror page_addr:%x cmd=%d\n", info->cur_page, info->isr_cmd);
				#endif
				if (bank_stat2 & BANK_DR) {
					bch_redunt_ecc_correct(mtd);
				} else {
					bch_data_ecc_correct(mtd);
				}
			} else
				printk("eccErr hw corr status not set bank_stat1=0x%x\n", bank_stat1);
		} /*else {
			printk("regular NOT isrWr busy\n");
		}*/
	}
	//spin_unlock(&host->lock);
	enable_irq(irq);

	return IRQ_HANDLED;
}

static int wmt_nand_probe(struct platform_device *pdev)
{
	/* struct wmt_platform_nand *plat = to_nand_plat(pdev);*/
	/*struct device *dev = &pdev->dev;*/
	struct wmt_nand_info *info;
	struct wmt_nand_mtd *nmtd;
	struct mtd_info *mtd;
	/*	struct wmt_nand_set *sets; */ /*  extend more chips and partitions structure*/
	struct resource *res;
	unsigned int ecc_bit_mode; //varlen;
	struct ECC_size_info ECC_size, *ECC_size_pt;
	char ret1;
	int err = 0, ret = 0; //, status = 0;
	unsigned char varval[100];
	int varlen = 32;
	int size;
	unsigned int mtd_num = NUM_NAND_PARTITIONS;
	prob_end = 0;
	eslc_write = 0;
	part_wr = 0;
	/*	int nr_sets;*/
	/*	int setno;*/
	/*err = -EINVAL;
	return err;*/

	ret = wmt_getsyspara("wmt.boot.dev", varval, &varlen);
	printk("wmt.boot.dev ret = %d\n", ret);
	if(!ret && (!strncmp(varval, "TF", 2) || (!strncmp(varval, "UDISK", 5))))
	{
		printk("Boot from SD  card or udisk card.\n");
		return -1;
	}

	ret = wmt_getsyspara("wmt.nand.eslc", varval, &varlen);
	printk("wmt.nand.eslc ret = %d\n", ret);
	if(!ret && (!strncmp(varval, "1", 1)))
	{
		printk("Whole nand in ESLC Mode.\n");
		whole_eslc = 1;
	} else {
		whole_eslc = 0;
	}

	*(volatile unsigned int *)(GPIO_BASE_ADDR + 0x200) &= ~(1<<1); /*PIN_SHARE_SDMMC1_NAND*/
	wmt_version = *(unsigned int *)(SYSTEM_CFG_CTRL_BASE_ADDR);
	/*	printk(KERN_NOTICE "CHIP version is %x\n", wmt_version);*/
	if (wmt_version == 0x34000101)
		return -1;  /* A0 chip not support nand flash */
	/*end wmt_revision: VT3400 A1 and Later...  */

	pr_debug("wmt_nand_probe(%p)\n", pdev);

	info = kmalloc(sizeof(*info), GFP_KERNEL);
	if (info == NULL) {
		dev_err(&pdev->dev, "no memory for flash info\n");
		err = -ENOMEM;
		goto exit_error;
	}

	memzero(info, sizeof(*info));
	dev_set_drvdata(&pdev->dev, info);
	platform_get_resource(pdev, IORESOURCE_MEM, 0);
	
	ret = request_irq(IRQ_NFC,
					nfc_regular_isr,
					IRQF_SHARED,			//SA_SHIRQ, /*SA_INTERRUPT, * that is okay?*/	//zhf: modified by James Tian, should be IRQF_SHARED?
					"NFC",
					(void *)info);
	if (ret) {
		printk(KERN_ALERT "[NFC driver] Failed to register regular ISR!\n");
		goto unmap;
	}

	ret = request_irq(IRQ_NFC_DMA,
					nfc_pdma_isr,
					IRQF_DISABLED,	//	SA_INTERRUPT,  //zhf: modified by James Tian
					"NFC",
					(void *)info);
	if (ret) {
		printk(KERN_ALERT "[NFC driver] Failed to register DMA ISR!\n");
		goto fr_regular_isr;
	}
	spin_lock_init(&info->controller.lock);
	init_waitqueue_head(&info->controller.wq);

	/* allocate and map the resource */

	/* currently we assume we have the one resource */
	res  = pdev->resource;
	size = res->end - res->start + 1;

	info->area = request_mem_region(res->start, size, pdev->name);

	if (info->area == NULL) {
		dev_err(&pdev->dev, "cannot reserve register region\n");
		err = -ENOENT;
		goto exit_error;
	}

	info->device     = &pdev->dev;
	/*	info->platform   = plat;*/
	info->reg = (void __iomem *)NF_CTRL_CFG_BASE_ADDR;/*ioremap(res->start, size);*/
	/*	info->cpu_type   = cpu_type;*/

	if (info->reg == NULL) {
		dev_err(&pdev->dev, "cannot reserve register region\n");
		err = -EIO;
		goto exit_error;
	}

/*
 * * extend more partitions
 *
	err = wmt_nand_inithw(info, pdev);
		if (err != 0)
		goto exit_error;

	sets = (plat != NULL) ? plat->sets : NULL;
	nr_sets = (plat != NULL) ? plat->nr_sets : 1;

	info->mtd_count = nr_sets;
*/
	/* allocate our information */

/*	size = nr_sets * sizeof(*info->mtds);*/
	size = sizeof(*info->mtds);
	info->mtds = kmalloc(size, GFP_KERNEL);
	if (info->mtds == NULL) {
		dev_err(&pdev->dev, "failed to allocate mtd storage\n");
		err = -ENOMEM;
		goto exit_error;
	}

	memzero(info->mtds, size);

	/* initialise all possible chips */

	nmtd = info->mtds;

	/* initialise the hardware */
	/*wmt_nfc_init(info, &nmtd->mtd);*/
	nfc_ecc_set(info, 1);  /* on hw ecc */
	
	mtd = &nmtd->mtd;
	info->dmabuf = dma_alloc_coherent(&pdev->dev, 17664 + 0x300, &info->dmaaddr, GFP_KERNEL);
	
	if (!info->dmabuf && (info->dmaaddr & 0x0f)) {
		err = -ENOMEM;
		goto out_free_dma;
	}
	/*	nmtd->chip.buffers = (void *)info->dmabuf + 2112;*/

	nmtd->chip.cmdfunc      = wmt_nand_cmdfunc;
	nmtd->chip.dev_ready    = wmt_device_ready;
	nmtd->chip.read_byte    = wmt_read_byte;
	nmtd->chip.write_buf    = wmt_nand_write_buf;
	nmtd->chip.read_buf     = wmt_nand_read_buf;
	nmtd->chip.select_chip  = wmt_nand_select_chip;
	nmtd->chip.get_para     = nand_get_para;
	nmtd->chip.chip_delay   = 20;
	nmtd->chip.priv	   = nmtd;
	nmtd->chip.options	   = NAND_BBT_LASTBLOCK | NAND_USE_FLASH_BBT | NAND_BBT_PERCHIP;
	/*	nmtd->chip.options	   = 0;*/
	/*	nmtd->chip.controller   = &info->controller;*/

	/*nmtd->chip.ecc.steps     = 1;
		nmtd->chip.ecc.prepad    = 1;
		nmtd->chip.ecc.postpad   = 8;*/

	nmtd->chip.ecc.mode	    = NAND_ECC_HW;
	/*nmtd->chip.ecc.mode	    = 0;*/


	/*	for (setno = 0; setno < nr_sets; setno++, nmtd++)*/
	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "initialising (%p, info %p)\n", nmtd, info);
	#endif
	/*	wmt_nand_init_chip(info, nmtd, sets);*/

	/* Set up DMA address */
	/*writel(info->dmaaddr & 0xffffffff, info->reg + NFC_DMA_DAR);*/

	/*info->dmabuf = readl(info->reg + WMT_NFC_DMA_TRANS_CONFIG);*/

	/* nmtd->nand.chip_delay = 0;*/

	/* Enable the following for a flash based bad block table */
	/*	nmtd->nand.options = NAND_USE_FLASH_BBT | NAND_NO_AUTOINCR | NAND_OWN_BUFFERS;*/

	#if 1
	if (mtd->writesize == 512) {
		printk(KERN_NOTICE "wmt_oobinfo_512 \n");
		nmtd->chip.ecc.layout = &wmt_oobinfo_512;
		nmtd->chip.bbt_td = &wmt_bbt_main_descr_512;
		nmtd->chip.bbt_md = &wmt_bbt_mirror_descr_512;
	} else { /*if (NAND_PAGE_SIZE == 4096 or 2048)*/
		nmtd->chip.bbt_td = &wmt_bbt_main_descr_2048;
		nmtd->chip.bbt_md = &wmt_bbt_mirror_descr_2048;
		nmtd->chip.retry_pattern = &wmt_rdtry_descr;
	}
	#endif


	nmtd->chip.cur_chip = NULL;
/*	if (nmtd->chip.cur_chip != NULL) {
		printk("chip.cur_chip is not null and set null\n");
		nmtd->chip.cur_chip = NULL;
	}*/

	/*nmtd->scan_res = nand_scan(&nmtd->mtd, (sets) ? sets->nr_chips : 1);*/

	nmtd->info	   = info;
	nmtd->mtd.priv	   = &nmtd->chip;
	nmtd->mtd.owner    = THIS_MODULE;
	nmtd->mtd.reboot_notifier.notifier_call = wmt_recovery_call;//Lch

	set_ecc_engine(info, 1);
	info->datalen = 0;
	ret1 = wmt_nfc_init(info, &nmtd->mtd);
	if (ret1 == 2)
		goto out_free_dma;
	writeb(0xff, info->reg + WMT_NFC_CHIP_ENABLE_CTRL); //chip disable 

#ifdef CONFIG_MTD_NAND_RANDOMIZER
	if(mtd->is_randomizer) {
		if(mtd->id == 0x98de9482 || mtd->id == 0x98de8493) {
			init_randomizer(nmtd->mtd.writesize, nmtd->mtd.oobsize, 1 << (nmtd->chip.phys_erase_shift - nmtd->chip.page_shift));
			printk("Toshiba randomizer init success.\n");
		} else 
			printk("wmt randomizer init success.");
		buffer_ramdomizer = vmalloc(nmtd->mtd.writesize + nmtd->mtd.oobsize);
		if(buffer_ramdomizer == NULL)
			goto out_free_dma;
	}
#endif

	ecc_bit_mode = mtd->dwECCBitNum;
	if (ecc_bit_mode > 24)
		ecc_bit_mode = (ecc_bit_mode == 40) ? 6 : (-1);
	else
		ecc_bit_mode = (ecc_bit_mode > 16) ? ((ecc_bit_mode/4) - 1) : (ecc_bit_mode/4);
	info->ECC_mode = ECC_size.ecc_engine = ecc_bit_mode;
	calculate_ECC_info(mtd, &ECC_size);
	writew((ECC_size.oob_ECC_bytes<<8)/*+ ECC_size.unprotect;*/, info->reg + WMT_NFC_REMAINDER);
	info->oob_ECC_bytes = ECC_size.oob_ECC_bytes;
	info->last_bank_dmaaddr = info->dmaaddr + mtd->writesize - ECC_size.bank_size;
	info->oob_col = mtd->writesize + (ECC_size.ECC_bytes * (ECC_size.banks-1));
	info->last_bank_col = info->oob_col - ECC_size.bank_size;
	info->oob_ECC_mode = ECC_size.oob_ECC_mode;
	info->oob_ecc_error = 0;
	printk(KERN_NOTICE "last_bank_dmaaddr=0x%x\n", info->last_bank_dmaaddr);
	printk(KERN_NOTICE "oob_col=%d\n", info->oob_col);
	printk(KERN_NOTICE "last_bank_col=%d\n", info->last_bank_col);
	ECC_size_pt = &ECC_size;
	wmt_nand_init_chip(info, nmtd, ECC_size_pt);
	/*rc = set_ECC_mode(mtd);
	if (rc)
		goto out_free_dma;*/

	printk(KERN_NOTICE "BCH ECC %d BIT mode\n", mtd->dwECCBitNum);
	set_ecc_engine(info, ecc_bit_mode);  /* BCH ECC new structure */
	

	if (mtd->writesize == 2048) {
		nmtd->chip.ecc.layout = &wmt_oobinfo_2048;
	} else if (mtd->writesize == 4096) {
		if (mtd->dwECCBitNum == 12)
			nmtd->chip.ecc.layout = &wmt_12bit_oobinfo_4096;
		else
			nmtd->chip.ecc.layout = &wmt_oobinfo_4096;
	} else if (mtd->writesize == 8192) {
		nmtd->chip.ecc.layout = &wmt_oobinfo_8192;
	} else if (mtd->writesize == 16384) {
		nmtd->chip.ecc.layout = &wmt_oobinfo_16k;
	} else {
		nmtd->chip.ecc.layout = &wmt_oobinfo_512;
		nmtd->chip.bbt_td = &wmt_bbt_main_descr_512;
		nmtd->chip.bbt_md = &wmt_bbt_mirror_descr_512;
	}


	nmtd->scan_res = nand_scan(&nmtd->mtd, MAX_CHIP);

	//For Android 4.1
	if(nand_partitions[6].size == MTDPART_SIZ_FULL)
		mtd_num -= 1;

	if (nmtd->chip.cur_chip && mtd->dwRetry) {
		/* Activating and initializing Dynamic Read Register */
		*(volatile unsigned long *)PMCEU_ADDR |= (0x0010000);
		if ( ((mtd->id>>24)&0xFF) == NAND_MFR_SANDISK) {
			sandisk_init_retry_register(mtd, nmtd->chip.cur_chip);
		} else if (mtd->id == 0xADD794DA && whole_eslc == 1) {
			nmtd->chip.cur_chip->set_parameter(mtd, ESLC_MODE, ECC_ERROR_VALUE);
			printk("set eslc mode whole chip\n");
		}
		*(volatile unsigned long *)PMCEU_ADDR &= ~(0x0010000);
	}

	if (nmtd->scan_res == 0) {
		#ifdef CONFIG_MTD_CMDLINE_PARTS
		err = add_dynamic_parts(&nmtd->mtd);
		if (err < 0) {
			printk(KERN_ERR "WMT_nand: uboot no dynamic partitions defined, use default static\n");
			mtd_device_register(&nmtd->mtd, nand_partitions, mtd_num);
			//add_mtd_partitions(&nmtd->mtd, nand_partitions, ARRAY_SIZE(nand_partitions));
		}
		#else
		mtd_device_register(&nmtd->mtd, nand_partitions, mtd_num/*nr_parts*/);
		//add_mtd_partitions(&nmtd->mtd, nand_partitions, ARRAY_SIZE(nand_partitions));
		#endif
	}

	//u-boot-logo and kernel-logo is configured by firmwareinstall package

	/*
	err = search_mtd_table("u-boot-logo", &ret1);
	ret = (int) ret1;
	varlen = 100;
	status = wmt_getsyspara("wmt.nfc.mtd.u-boot-logo", tmp, &varlen);
	sprintf(varval, "0x%llx", nand_partitions[ret].offset);
	if (!status || (strcmp(varval, tmp) == 0))
		status = 0;
	if (!err && status) {
		ret = wmt_setsyspara("wmt.nfc.mtd.u-boot-logo", varval);
		if (ret)
			printk(KERN_NOTICE "write u-boot-logo offset to env fail\n");
	} else if (err)
		printk(KERN_NOTICE "search u-boot-logo partition fail\n");

	err = search_mtd_table("kernel-logo", &ret1);
	ret = (int) ret1;
	varlen = 100;
	status = wmt_getsyspara("wmt.nfc.mtd.kernel-logo", tmp, &varlen);
	sprintf(varval, "0x%llx", nand_partitions[ret].offset);
	if (!status || (strcmp(varval, tmp) == 0))
		status = 0;
	if (!err && status) {
		ret = wmt_setsyspara("wmt.nfc.mtd.kernel-logo", varval);
		if (ret)
			printk(KERN_NOTICE "write kernel-logo offset to env fail\n");
	} else if (err)
		printk(KERN_NOTICE "search kernel-logo partition fail\n");*/

	/*if (((*(volatile unsigned long *)(GPIO_BASE_ADDR + 0x100))&6) == 2)
		spin_lock_init(nand_lock);*/


	register_reboot_notifier(&mtd->reboot_notifier);//Lch
	printk(KERN_NOTICE "nand initialised ok\n");
	prob_end = 1;
	return 0;

out_free_dma:
	dma_free_coherent(&pdev->dev, 17664 + 0x300, info->dmabuf, info->dmaaddr);
	
fr_regular_isr:
unmap:
exit_error:
	wmt_nand_remove(pdev);

	if (err == 0)
		err = -EINVAL;
	return err;
}

/* PM Support */
#ifdef CONFIG_PM
int wmt_nand_suspend(struct platform_device *pdev, pm_message_t state)
{
	/*struct wmt_nand_info *info = dev_get_drvdata(&pdev->dev);*/

	if (((*(volatile unsigned long *)(GPIO_BASE_ADDR + 0x100))&6) == 2) {
			*(volatile unsigned long *)PMCEU_ADDR |= (0x0010000);
		/*writel(0x0, info->reg + WMT_NFC_COMPORT0);
		writel(0x0, info->reg + WMT_NFC_COMPORT1_2);
		writel(0x0, info->reg + WMT_NFC_COMPORT3_4);
		writel(0x30, info->reg + WMT_NFC_COMPORT5_6);
		writel(0x1FF, info->reg + WMT_NFC_DMA_COUNTER);
		writel(0x41, info->reg + WMT_NFC_NAND_TYPE_SEL);
		writel(0x12123636, info->reg + WMT_NFC_READ_CYCLE_PULE_CTRL);
		writel(0x0, info->reg + WMT_NFC_CHIP_ENABLE_CTRL);
		writel(0x2, info->reg + WMT_NFC_CALC_CTRL);
		writel(0x101, info->reg + WMT_NFC_ECC_BCH_INT_MASK);
		writel(0x1, info->reg + WMT_NFC_NANDFLASH_BOOT);*/
		*(volatile unsigned long *)(NF_CTRL_CFG_BASE_ADDR + 0x88) |= (1<<5);
	printk(KERN_NOTICE "reset nand boot register NF_CTRL_CFG_BASE_ADDR + 0x88\n");
	*(volatile unsigned long *)(NF_CTRL_CFG_BASE_ADDR + 0x88) &= ~(1<<5);
	}
	printk(KERN_NOTICE "wmt_nand_suspend\n");
	return 0;
}

int wmt_nand_resume(struct platform_device *pdev)
{
	struct wmt_nand_info *info = dev_get_drvdata(&pdev->dev);
	struct wmt_nand_mtd *nmtd;
	int ret, ecc_bit_mode;
	struct ECC_size_info ECC_size;
	*(volatile unsigned long *)PMCEU_ADDR |= (0x0010000);/*add by vincent*/
	if (info) {
			nmtd = info->mtds;
		if (((*(volatile unsigned long *)(GPIO_BASE_ADDR + 0x100))&6) == 2)
			writel(0x0, info->reg + WMT_NFC_NANDFLASH_BOOT);
		/* initialise the hardware */
		ret = wmt_nfc_init(info, &nmtd->mtd);
		if (ret == 2)
			while(ret);
		nfc_ecc_set(info, 1);  /* on hw ecc */
		/* Set up DMA address */
		/*writel(info->dmaaddr & 0xffffffff, info->reg + NFC_DMA_DAR);*/
		ecc_bit_mode = (&nmtd->mtd)->dwECCBitNum;
		if (ecc_bit_mode > 24)
			ecc_bit_mode = (ecc_bit_mode == 40) ? 6 : (-1);
		else
			ecc_bit_mode = (ecc_bit_mode > 16) ? ((ecc_bit_mode/4) - 1) : (ecc_bit_mode/4);

		set_ecc_engine(info, ecc_bit_mode); /* BCH ECC */
		ECC_size.ecc_engine = ecc_bit_mode;
		calculate_ECC_info((&nmtd->mtd), &ECC_size);
		writew((ECC_size.oob_ECC_bytes<<8)/*+ ECC_size.unprotect;*/, info->reg + WMT_NFC_REMAINDER);

		printk(KERN_NOTICE "wmt_nand_resume OK\n");
	} else
		printk(KERN_NOTICE "wmt_nand_resume error\n");

	*(volatile unsigned long *)PMCEU_ADDR &= ~(0x0010000);/*add by vincent*/
	return 0;
}

#else /* else of #define PM */
#define wmt_nand_suspend NULL
#define wmt_nand_resume NULL
#endif

/*struct platform_driver wmt_nand_driver = {*/
struct platform_driver wmt_nand_driver = {
	.driver.name	= "nand",
	.probe = wmt_nand_probe,
	.remove = wmt_nand_remove,
	.suspend = wmt_nand_suspend,
	.resume = wmt_nand_resume
	/*
	.driiver = {
	.name	= "wmt-nand",
	.owner	= THIS_MODULE,
	},
	*/
};

static int __init wmt_nand_init(void)
{
	//printk(KERN_NOTICE "NAND Driver, WonderMedia Technologies, Inc\n");
	return platform_driver_register(&wmt_nand_driver);
}

static void __exit wmt_nand_exit(void)
{
	platform_driver_unregister(&wmt_nand_driver);
}

module_init(wmt_nand_init);
module_exit(wmt_nand_exit);

MODULE_AUTHOR("WonderMedia Technologies, Inc.");
MODULE_DESCRIPTION("WMT [Nand Flash Interface] driver");
MODULE_LICENSE("GPL");
