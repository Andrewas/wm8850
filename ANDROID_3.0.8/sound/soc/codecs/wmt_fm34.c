/*++ 
 * linux/sound/soc/codecs/wmt_fm34.c
 * WonderMedia echo cancellation driver
 *
 * Copyright c 2010  WonderMedia  Technologies, Inc.
 *
 * This program is free software: you can redistribute it and/or modify 
 * it under the terms of the GNU General Public License as published by 
 * the Free Software Foundation, either version 2 of the License, or 
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * GNU General Public License for more details. 
 *
 * You should have received a copy of the GNU General Public License 
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * WonderMedia Technologies, Inc.
 * 4F, 533, Chung-Cheng Road, Hsin-Tien, Taipei 231, R.O.C
--*/

#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>
#include <linux/delay.h>
#include <linux/pm.h>
#include <linux/i2c.h>
#include <linux/version.h>
#include <linux/slab.h>
#include <linux/workqueue.h>

#include <mach/hardware.h>
#include <mach/wmt_gpio.h>
#include <mach/gpio-cs.h>

#define FM34_DEVICE_ID      0x501a

extern int wmt_getsyspara(char *varname, unsigned char *varval, int *varlen);

struct fm34_ctrl_gpo {
	int enable;
	int idx;
	int bit;
	int active;
};

static struct fm34_ctrl_gpo fm34_gpo_rst;
static struct fm34_ctrl_gpo fm34_gpo_pwdn;
static struct fm34_ctrl_gpo fm34_gpo_bp;

struct fm34 {
	int (*read_dev)(struct fm34 *fm34, 
			    const u8 wdata[], int wsize, 
			    u8 rdata[], int rsize);
	int (*write_dev)(struct fm34 *fm34, const u8 wdata[], int wsize);
	void *control_data;
	struct device *dev;
	struct delayed_work delaywork;
};

static const u8 wmt_fm34_firmware[] = {
	0xFC, 0xF3, 0x3B, 0x22, 0xC0, 0x00, 0x04,
    0xFC, 0xF3, 0x3B, 0x22, 0xC1, 0x00, 0x04,
    0xFC, 0xF3, 0x3B, 0x22, 0xC2, 0x00, 0x03,
    0xFC, 0xF3, 0x3B, 0x22, 0xC3, 0x00, 0x03,
    0xFC, 0xF3, 0x3B, 0x22, 0xC6, 0x00, 0x0C,
    0xFC, 0xF3, 0x3B, 0x22, 0xC7, 0x00, 0x0C,
    0xFC, 0xF3, 0x3B, 0x22, 0xC8, 0x00, 0x2C,
    0xFC, 0xF3, 0x3B, 0x22, 0xD2, 0x82, 0x94,
    0xFC, 0xF3, 0x3B, 0x22, 0xEE, 0x00, 0x01,
    0xFC, 0xF3, 0x3B, 0x22, 0xF2, 0x00, 0x40,
    0xFC, 0xF3, 0x3B, 0x22, 0xF6, 0x00, 0x00,
    0xFC, 0xF3, 0x3B, 0x22, 0xF8, 0x80, 0x05,
    0xFC, 0xF3, 0x3B, 0x22, 0xF9, 0x10, 0x7F,
    0xFC, 0xF3, 0x3B, 0x22, 0xFA, 0x23, 0x8F,
    0xFC, 0xF3, 0x3B, 0x23, 0x01, 0x00, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x02, 0x01, 0x01,
    0xFC, 0xF3, 0x3B, 0x23, 0x03, 0x09, 0x01,
    0xFC, 0xF3, 0x3B, 0x23, 0x04, 0x03, 0x1E,
    0xFC, 0xF3, 0x3B, 0x23, 0x05, 0x00, 0x01,
    0xFC, 0xF3, 0x3B, 0x23, 0x07, 0xF0, 0xF0,
    0xFC, 0xF3, 0x3B, 0x23, 0x08, 0x08, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x0A, 0x1A, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x0C, 0x04, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x48, 0x08, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x49, 0x06, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x6E, 0x20, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x6F, 0x0A, 0x0A,
    0xFC, 0xF3, 0x3B, 0x23, 0x70, 0x0F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x73, 0x22, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x74, 0x18, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x75, 0x12, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x77, 0x30, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x7B, 0x00, 0x08,
    0xFC, 0xF3, 0x3B, 0x23, 0x86, 0x48, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x8C, 0x10, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x9C, 0x60, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x9D, 0x40, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x9E, 0x40, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xBD, 0x30, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xCE, 0x40, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xCF, 0x08, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xD0, 0x06, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xD1, 0x02, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xD2, 0x05, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xED, 0x05, 0x40,
    0xFC, 0xF3, 0x3B, 0x23, 0xEE, 0x08, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xD5, 0x20, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x60, 0x01, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x61, 0x08, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x62, 0x02, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x63, 0x60, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x64, 0x00, 0xB0,
    0xFC, 0xF3, 0x3B, 0x23, 0x80, 0x7F, 0xFF,
    0xFC, 0xF3, 0x3B, 0x23, 0x81, 0x40, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x82, 0x04, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x83, 0x04, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x84, 0x00, 0x04,
    0xFC, 0xF3, 0x3B, 0x23, 0x85, 0x00, 0x05,
    0xFC, 0xF3, 0x3B, 0x23, 0x8E, 0x70, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x90, 0xA9, 0x87,
    0xFC, 0xF3, 0x3B, 0x23, 0x91, 0x76, 0x54,
    0xFC, 0xF3, 0x3B, 0x23, 0x93, 0x44, 0x55,
    0xFC, 0xF3, 0x3B, 0x23, 0x94, 0x55, 0x66,
    0xFC, 0xF3, 0x3B, 0x23, 0x95, 0x66, 0x77,
    0xFC, 0xF3, 0x3B, 0x23, 0x96, 0x20, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x97, 0x30, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x98, 0x00, 0x20,
    0xFC, 0xF3, 0x3B, 0x23, 0xA5, 0x00, 0x06,
    0xFC, 0xF3, 0x3B, 0x23, 0xA8, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xA9, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xAA, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xAB, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xAC, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xAD, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xAE, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xAF, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xB0, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xB1, 0x7F, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x09, 0x08, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0xB3, 0x00, 0x06,
    0xFC, 0xF3, 0x3B, 0x23, 0xB4, 0x00, 0x01,
    0xFC, 0xF3, 0x3B, 0x23, 0x10, 0x48, 0x90,
    0xFC, 0xF3, 0x3B, 0x23, 0x2F, 0x01, 0x40,
    0xFC, 0xF3, 0x3B, 0x23, 0x32, 0x00, 0x30,
    0xFC, 0xF3, 0x3B, 0x23, 0x33, 0x00, 0x0C,
    0xFC, 0xF3, 0x3B, 0x23, 0x37, 0x00, 0x02,
    0xFC, 0xF3, 0x3B, 0x23, 0x39, 0x00, 0x01,
    0xFC, 0xF3, 0x3B, 0x23, 0x0D, 0x03, 0x00,
    0xFC, 0xF3, 0x3B, 0x23, 0x65, 0x08, 0x00,
    0xFC, 0xF3, 0x3B, 0x22, 0xFB, 0x00, 0x00
};

int fm34_check_functionality(struct fm34 *fm34)
{
	u8 rdata1, rdata2;
	int devid = 0;
	const u8 wdata1[] = {
		0xFC, 0xF3, 0x27, 0x37, 0xFF
	};
	const u8 wdata2[] = {
		0xFC, 0xF3, 0x60, 0x25
	};
	const u8 wdata3[] = {
		0xFC, 0xF3, 0x60, 0x26
	};
		
	if (fm34->write_dev(fm34, wdata1, sizeof(wdata1)))
		return 0;

	if (fm34->read_dev(fm34, wdata2, sizeof(wdata2), &rdata1, 1) ||
		fm34->read_dev(fm34, wdata3, sizeof(wdata3), &rdata2, 1))
		return 0;

	devid = (rdata2 << 8) | rdata1;
	printk("-->fm34_check_functionality: %x\n", devid);
	if (devid == FM34_DEVICE_ID)
		return 1;
	
	return 0;
}
EXPORT_SYMBOL(fm34_check_functionality);

static int fm34_i2c_write(struct fm34 *fm34, const u8 wdata[], int wsize)
{
	int ret;
	struct i2c_client *i2c = fm34->control_data;
	struct i2c_msg xfer[1];

	/*
	 * [MSG1]: fill the register address data
	 * fill the data Tx buffer
	 */
	xfer[0].addr = i2c->addr;
	xfer[0].flags = 0 ;
	xfer[0].flags &= ~(I2C_M_RD);
	xfer[0].buf = wdata;
	xfer[0].len = wsize;

	/* i2c_transfer returns number of messages transferred */
	ret = i2c_transfer(i2c->adapter, xfer, ARRAY_SIZE(xfer));
	if (ret != ARRAY_SIZE(xfer)) {
		pr_err("fm34_i2c_write err[%d]\n", ret);
		if (ret < 0)
			return ret;
		else
			return -EIO;
	} else
		return 0;
}

static int fm34_i2c_read(struct fm34 *fm34, 
			    const u8 wdata[], int wsize, 
			    u8 rdata[], int rsize)
{
	int ret;
	struct i2c_client *i2c = fm34->control_data;
	struct i2c_msg xfer[2];

	/* [MSG1] fill the register address data */
	xfer[0].addr = i2c->addr;
	xfer[0].flags = 2;	/* Read the register val */
	xfer[0].buf = wdata;
	xfer[0].len = wsize;
	
	/* [MSG2] fill the data rx buffer */
	xfer[1].addr = i2c->addr;
	xfer[1].flags = I2C_M_RD;	/* Read the register val */
	xfer[1].len = rsize;	/* only n bytes */
	xfer[1].buf = rdata;

	/* i2c_transfer returns number of messages transferred */
	ret = i2c_transfer(i2c->adapter, xfer, ARRAY_SIZE(xfer));
	if (ret != ARRAY_SIZE(xfer)) {
		pr_err("vt1603_i2c_read err[%d]\n", ret);
		if (ret < 0)
			return ret;
		else
			return -EIO;
	} else {
		return 0;
	}
}

static void fm34_timing_init()
{
	// pwdn high to power up fm34 module
	if (fm34_gpo_pwdn.enable) {
		gpio_enable(fm34_gpo_pwdn.idx, fm34_gpo_pwdn.bit, OUTPUT);
		gpio_set_value(fm34_gpo_pwdn.idx, fm34_gpo_pwdn.bit, HIGH);
		msleep(100);
	}

	// reset fm34 module
	if (fm34_gpo_rst.enable) {
		gpio_enable(fm34_gpo_rst.idx, fm34_gpo_rst.bit, OUTPUT);
		gpio_set_value(fm34_gpo_rst.idx, fm34_gpo_rst.bit, HIGH);
		msleep(10);
		gpio_set_value(fm34_gpo_rst.idx, fm34_gpo_rst.bit, LOW);
		msleep(10);
		gpio_set_value(fm34_gpo_rst.idx, fm34_gpo_rst.bit, HIGH);
		msleep(100);
	}

	// disable fm34 bypass
	if (fm34_gpo_bp.enable) {
		gpio_enable(fm34_gpo_bp.idx, fm34_gpo_bp.bit, OUTPUT);
		gpio_set_value(fm34_gpo_bp.idx, fm34_gpo_bp.bit, HIGH);
	}
}

static void fm34_do_work(struct work_struct *work)
{
	struct fm34 *fm34 = container_of(work, struct fm34, delaywork);

	fm34_timing_init();

	if (fm34_check_functionality(fm34) == 0) {
		pr_err("fm34_check_functionality: wrong device id\n");
	}
	
	fm34->write_dev(fm34, wmt_fm34_firmware, sizeof(wmt_fm34_firmware));
}

static int __devinit fm34_i2c_probe(struct i2c_client *i2c,
			    const struct i2c_device_id *id)
{
	struct fm34 *fm34;

	if (i2c_check_functionality(i2c->adapter, I2C_FUNC_I2C) == 0) {
		pr_err("i2c_check_functionality: can't talk I2C?\n");
		return -EIO;
	}

	fm34 = kzalloc(sizeof(struct fm34), GFP_KERNEL);
	if (fm34 == NULL)
		return -ENOMEM;

	fm34->dev = &i2c->dev;
	fm34->control_data = i2c;
	fm34->read_dev = fm34_i2c_read;
	fm34->write_dev = fm34_i2c_write;

	i2c_set_clientdata(i2c, fm34);
	dev_set_drvdata(fm34->dev, fm34);

	INIT_DELAYED_WORK(&fm34->delaywork, fm34_do_work);

	fm34_timing_init();

	if (fm34_check_functionality(fm34) == 0) {
		pr_err("fm34_check_functionality: wrong device id\n");
		return -EIO;
	}

	/* write the firmware to device */
	fm34->write_dev(fm34, wmt_fm34_firmware, sizeof(wmt_fm34_firmware));
	return 0;
}

static int __devexit fm34_i2c_remove(struct i2c_client *i2c)
{
	struct fm34 *fm34 = i2c_get_clientdata(i2c);
	kfree(fm34);
	return 0;
}

static int fm34_suspend(struct i2c_client *i2c, pm_message_t mesg)
{
	struct fm34 *fm34 = i2c_get_clientdata(i2c);
	cancel_delayed_work_sync(&fm34->delaywork);	
	return 0;
}
static int fm34_resume(struct i2c_client *i2c)
{
	struct fm34 *fm34 = i2c_get_clientdata(i2c);
	schedule_delayed_work(&fm34->delaywork, msecs_to_jiffies(2000));
	return 0;
}

static const struct i2c_device_id fm34_i2c_id[] = {
	{ "wmt-fm34", 0 },
	{ },
};
MODULE_DEVICE_TABLE(i2c, fm34_i2c_id);

static struct i2c_driver fm34_i2c_driver = {
	.driver = {
		.name = "wmt-fm34",
		.owner = THIS_MODULE,
	},
	.probe =    fm34_i2c_probe,
	.remove =   __devexit_p(fm34_i2c_remove),
	.suspend = fm34_suspend,
	.resume = fm34_resume,
	.id_table = fm34_i2c_id,
};	

static int __init fm34_init(void)
{
	int ret = -1;
	int len = 64;
	char buf[64];
	
    // parse u-boot parameter
	ret = wmt_getsyspara("wmt.gpo.fm34", buf, &len);
	if (ret == 0) {
		sscanf(buf, "[%d:%d:%d:%d]:[%d:%d:%d:%d]:[%d:%d:%d:%d]", 
			&fm34_gpo_rst.enable, &fm34_gpo_rst.idx, &fm34_gpo_rst.bit, &fm34_gpo_rst.active,
			&fm34_gpo_pwdn.enable, &fm34_gpo_pwdn.idx, &fm34_gpo_pwdn.bit, &fm34_gpo_pwdn.active,
			&fm34_gpo_bp.enable, &fm34_gpo_bp.idx, &fm34_gpo_bp.bit, &fm34_gpo_bp.active);
	}
	else {
		fm34_gpo_rst.enable = 0;
		fm34_gpo_pwdn.enable = 0;
		fm34_gpo_bp.enable = 0;
	}
	
	ret = i2c_add_driver(&fm34_i2c_driver);
	if (ret != 0)
		pr_err("Failed to register FM34 I2C driver: %d\n", ret);
	return ret;
}
module_init(fm34_init);

static void __exit fm34_exit(void)
{
	i2c_del_driver(&fm34_i2c_driver);
}
module_exit(fm34_exit);

MODULE_DESCRIPTION("WMT [ALSA SoC] driver");
MODULE_AUTHOR("WonderMedia Technologies, Inc.");
MODULE_LICENSE("GPL");
